{"version":3,"file":"render.CJy_g0Wp.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/elements/events.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/render.js"],"sourcesContent":["import { teardown } from '../../reactivity/effects.js';\nimport { all_registered_events, root_event_handles } from '../../render.js';\nimport { define_property, is_array } from '../../utils.js';\nimport { hydrating } from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * SSR adds onload and onerror attributes to catch those events before the hydration.\n * This function detects those cases, removes the attributes and replays the events.\n * @param {HTMLElement} dom\n */\nexport function replay_events(dom) {\n\tif (!hydrating) return;\n\n\tif (dom.onload) {\n\t\tdom.removeAttribute('onload');\n\t}\n\tif (dom.onerror) {\n\t\tdom.removeAttribute('onerror');\n\t}\n\t// @ts-expect-error\n\tconst event = dom.__e;\n\tif (event !== undefined) {\n\t\t// @ts-expect-error\n\t\tdom.__e = undefined;\n\t\tqueueMicrotask(() => {\n\t\t\tif (dom.isConnected) {\n\t\t\t\tdom.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} options\n */\nexport function create_event(event_name, dom, handler, options) {\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tif (!options.capture) {\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\thandle_event_propagation(dom, event);\n\t\t}\n\t\tif (!event.cancelBubble) {\n\t\t\treturn handler.call(this, event);\n\t\t}\n\t}\n\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\n\t// this bug. The same applies to wheel events.\n\tif (event_name.startsWith('pointer') || event_name === 'wheel') {\n\t\tqueue_micro_task(() => {\n\t\t\tdom.addEventListener(event_name, target_handler, options);\n\t\t});\n\t} else {\n\t\tdom.addEventListener(event_name, target_handler, options);\n\t}\n\n\treturn target_handler;\n}\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @template {HTMLElement} Element\n * @template {keyof HTMLElementEventMap} Type\n * @overload\n * @param {Element} element\n * @param {Type} type\n * @param {(this: Element, event: HTMLElementEventMap[Type]) => any} handler\n * @param {AddEventListenerOptions} [options]\n * @returns {() => void}\n */\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @overload\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n * @returns {() => void}\n */\n\n/**\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type, element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} handler\n * @param {boolean} capture\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tvar target_handler = create_event(event_name, dom, handler, options);\n\n\t// @ts-ignore\n\tif (dom === document.body || dom === window || dom === document) {\n\t\tteardown(() => {\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @param {EventTarget} handler_element\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(handler_element, event) {\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.parentNode || /** @type {any} */ (current_target).host || null;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-expect-error is used above\n\t\tcurrent_target = handler_element;\n\t}\n}\n","import { DEV } from 'esm-env';\nimport { clear_text_content, create_element, empty, init_operations } from './dom/operations.js';\nimport { HYDRATION_ERROR, HYDRATION_START, PassiveDelegatedEvents } from '../../constants.js';\nimport { flush_sync, push, pop, current_component_context } from './runtime.js';\nimport { effect_root, branch } from './reactivity/effects.js';\nimport {\n\thydrate_anchor,\n\thydrate_nodes,\n\thydrating,\n\tset_hydrate_nodes,\n\tset_hydrating\n} from './dom/hydration.js';\nimport { array_from } from './utils.js';\nimport { handle_event_propagation } from './dom/elements/events.js';\nimport { reset_head_anchor } from './dom/blocks/svelte-head.js';\nimport * as w from './warnings.js';\nimport * as e from './errors.js';\nimport { validate_component } from '../shared/validate.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * This is normally true — block effects should run their intro transitions —\n * but is false during hydration and mounting (unless `options.intro` is `true`)\n * and when creating the children of a `<svelte:element>` that just changed tag\n */\nexport let should_intro = true;\n\n/** @param {boolean} value */\nexport function set_should_intro(value) {\n\tshould_intro = value;\n}\n\n/**\n * @param {Element} text\n * @param {string} value\n * @returns {void}\n */\nexport function set_text(text, value) {\n\t// @ts-expect-error\n\tconst prev = (text.__t ??= text.nodeValue);\n\n\tif (prev !== value) {\n\t\t// @ts-expect-error\n\t\ttext.nodeValue = text.__t = value;\n\t}\n}\n\n/**\n * @param {Comment} anchor\n * @param {void | ((anchor: Comment, slot_props: Record<string, unknown>) => void)} slot_fn\n * @param {Record<string, unknown>} slot_props\n * @param {null | ((anchor: Comment) => void)} fallback_fn\n */\nexport function slot(anchor, slot_fn, slot_props, fallback_fn) {\n\tif (slot_fn === undefined) {\n\t\tif (fallback_fn !== null) {\n\t\t\tfallback_fn(anchor);\n\t\t}\n\t} else {\n\t\tslot_fn(anchor, slot_props);\n\t}\n}\n\n/**\n * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {import('../../index.js').ComponentType<import('../../index.js').SvelteComponent<Props>> | import('../../index.js').Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tanchor?: Node;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}: {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tanchor?: Node;\n * \t\tevents?: Record<string, (e: any) => any>;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function mount(component, options) {\n\tif (DEV) {\n\t\tvalidate_component(component);\n\t}\n\n\tconst anchor = options.anchor ?? options.target.appendChild(empty());\n\t// Don't flush previous effects to ensure order of outer effects stays consistent\n\treturn flush_sync(() => _mount(component, { ...options, anchor }), false);\n}\n\n/**\n * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {import('../../index.js').ComponentType<import('../../index.js').SvelteComponent<Props>> | import('../../index.js').Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t} : {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function hydrate(component, options) {\n\tif (DEV) {\n\t\tvalidate_component(component);\n\t}\n\n\tconst target = options.target;\n\tconst previous_hydrate_nodes = hydrate_nodes;\n\n\ttry {\n\t\t// Don't flush previous effects to ensure order of outer effects stays consistent\n\t\treturn flush_sync(() => {\n\t\t\tset_hydrating(true);\n\n\t\t\tvar node = target.firstChild;\n\t\t\twhile (\n\t\t\t\tnode &&\n\t\t\t\t(node.nodeType !== 8 || /** @type {Comment} */ (node).data !== HYDRATION_START)\n\t\t\t) {\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\n\t\t\tif (!node) {\n\t\t\t\tthrow HYDRATION_ERROR;\n\t\t\t}\n\n\t\t\tconst anchor = hydrate_anchor(node);\n\t\t\tconst instance = _mount(component, { ...options, anchor });\n\n\t\t\t// flush_sync will run this callback and then synchronously run any pending effects,\n\t\t\t// which don't belong to the hydration phase anymore - therefore reset it here\n\t\t\tset_hydrating(false);\n\n\t\t\treturn instance;\n\t\t}, false);\n\t} catch (error) {\n\t\tif (error === HYDRATION_ERROR) {\n\t\t\tif (options.recover === false) {\n\t\t\t\te.hydration_failed();\n\t\t\t}\n\n\t\t\t// If an error occured above, the operations might not yet have been initialised.\n\t\t\tinit_operations();\n\t\t\tclear_text_content(target);\n\n\t\t\tset_hydrating(false);\n\t\t\treturn mount(component, options);\n\t\t}\n\n\t\tthrow error;\n\t} finally {\n\t\tset_hydrating(!!previous_hydrate_nodes);\n\t\tset_hydrate_nodes(previous_hydrate_nodes);\n\t\treset_head_anchor();\n\t}\n}\n\n/**\n * @template {Record<string, any>} Exports\n * @param {import('../../index.js').ComponentType<import('../../index.js').SvelteComponent<any>> | import('../../index.js').Component<any>} Component\n * @param {{\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tanchor: Node;\n * \t\tprops?: any;\n * \t\tevents?: any;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nfunction _mount(Component, { target, anchor, props = {}, events, context, intro = false }) {\n\tinit_operations();\n\n\tconst registered_events = new Set();\n\n\tconst bound_event_listener = handle_event_propagation.bind(null, target);\n\tconst bound_document_event_listener = handle_event_propagation.bind(null, document);\n\n\t/** @param {Array<string>} events */\n\tconst event_handle = (events) => {\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tconst event_name = events[i];\n\t\t\tif (!registered_events.has(event_name)) {\n\t\t\t\tregistered_events.add(event_name);\n\t\t\t\t// Add the event listener to both the container and the document.\n\t\t\t\t// The container listener ensures we catch events from within in case\n\t\t\t\t// the outer content stops propagation of the event.\n\t\t\t\ttarget.addEventListener(\n\t\t\t\t\tevent_name,\n\t\t\t\t\tbound_event_listener,\n\t\t\t\t\tPassiveDelegatedEvents.includes(event_name)\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tpassive: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: undefined\n\t\t\t\t);\n\t\t\t\t// The document listener ensures we catch events that originate from elements that were\n\t\t\t\t// manually moved outside of the container (e.g. via manual portals).\n\t\t\t\tdocument.addEventListener(\n\t\t\t\t\tevent_name,\n\t\t\t\t\tbound_document_event_listener,\n\t\t\t\t\tPassiveDelegatedEvents.includes(event_name)\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tpassive: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: undefined\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t};\n\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\t/** @type {Exports} */\n\t// @ts-expect-error will be defined because the render effect runs synchronously\n\tlet component = undefined;\n\n\tconst unmount = effect_root(() => {\n\t\tbranch(() => {\n\t\t\tif (context) {\n\t\t\t\tpush({});\n\t\t\t\tvar ctx = /** @type {import('#client').ComponentContext} */ (current_component_context);\n\t\t\t\tctx.c = context;\n\t\t\t}\n\n\t\t\tif (events) {\n\t\t\t\t// We can't spread the object or else we'd lose the state proxy stuff, if it is one\n\t\t\t\t/** @type {any} */ (props).$$events = events;\n\t\t\t}\n\n\t\t\tshould_intro = intro;\n\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\n\t\t\tcomponent = Component(anchor, props) || {};\n\t\t\tshould_intro = true;\n\n\t\t\tif (context) {\n\t\t\t\tpop();\n\t\t\t}\n\t\t});\n\n\t\treturn () => {\n\t\t\tfor (const event_name of registered_events) {\n\t\t\t\ttarget.removeEventListener(event_name, bound_event_listener);\n\t\t\t\tdocument.removeEventListener(event_name, bound_event_listener);\n\t\t\t}\n\t\t\troot_event_handles.delete(event_handle);\n\t\t\tmounted_components.delete(component);\n\t\t};\n\t});\n\n\tmounted_components.set(component, unmount);\n\treturn component;\n}\n\n/**\n * References of the components that were mounted or hydrated.\n * Uses a `WeakMap` to avoid memory leaks.\n */\nlet mounted_components = new WeakMap();\n\n/**\n * Unmounts a component that was previously mounted using `mount` or `hydrate`.\n * @param {Record<string, any>} component\n */\nexport function unmount(component) {\n\tconst fn = mounted_components.get(component);\n\tif (DEV && !fn) {\n\t\tw.lifecycle_double_unmount();\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.trace('stack trace');\n\t}\n\tfn?.();\n}\n\n/**\n * @param {Record<string, any>} props\n * @returns {Record<string, any>}\n */\nexport function sanitize_slots(props) {\n\tconst sanitized = { ...props.$$slots };\n\tif (props.children) sanitized.default = props.children;\n\treturn sanitized;\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n */\nexport async function append_styles(target, style_sheet_id, styles) {\n\t// Wait a tick so that the template is added to the dom, else getRootNode() will yield wrong results\n\t// If it turns out that this results in noticeable flickering, we need to do something like doing the\n\t// append outside and adding code in mount that appends all stylesheets (similar to how we do it with event delegation)\n\tawait Promise.resolve();\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = create_element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tconst target = /** @type {Document} */ (append_styles_to).head || append_styles_to;\n\t\ttarget.appendChild(style);\n\t}\n}\n\n/**\n * @param {Node} node\n */\nfunction get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn /** @type {Document} */ (node.ownerDocument);\n}\n"],"names":["delegate","events","i","all_registered_events","fn","root_event_handles","handle_event_propagation","handler_element","event","owner_document","event_name","path","_a","current_target","path_idx","handled_at","at_idx","handler_idx","define_property","throw_error","other_errors","parent_element","delegated","is_array","data","error","set_text","text","value","slot","anchor","slot_fn","slot_props","fallback_fn","mount","component","options","empty","flush_sync","_mount","hydrate","target","previous_hydrate_nodes","hydrate_nodes","set_hydrating","node","HYDRATION_START","HYDRATION_ERROR","hydrate_anchor","instance","e.hydration_failed","init_operations","clear_text_content","set_hydrate_nodes","reset_head_anchor","Component","props","context","intro","registered_events","bound_event_listener","bound_document_event_listener","event_handle","PassiveDelegatedEvents","array_from","unmount","effect_root","branch","push","ctx","current_component_context","pop","mounted_components"],"mappings":"sQAsIO,SAASA,EAASC,EAAQ,CAChC,QAASC,EAAI,EAAGA,EAAID,EAAO,OAAQC,IAClCC,EAAsB,IAAIF,EAAOC,CAAC,CAAC,EAGpC,QAASE,KAAMC,EACdD,EAAGH,CAAM,CAEX,CAOO,SAASK,EAAyBC,EAAiBC,EAAO,OAChE,IAAIC,EAAsCF,EAAiB,cACvDG,EAAaF,EAAM,KACnBG,IAAOC,EAAAJ,EAAM,eAAN,YAAAI,EAAA,KAAAJ,KAA0B,CAAA,EACjCK,EAAgDF,EAAK,CAAC,GAAKH,EAAM,OAMjEM,EAAW,EAGXC,EAAaP,EAAM,OAEvB,GAAIO,EAAY,CACf,IAAIC,EAASL,EAAK,QAAQI,CAAU,EACpC,GACCC,IAAW,KACVT,IAAoB,UAAYA,IAAwC,QACxE,CAKDC,EAAM,OAASD,EACf,MACA,CAOD,IAAIU,EAAcN,EAAK,QAAQJ,CAAe,EAC9C,GAAIU,IAAgB,GAGnB,OAGGD,GAAUC,IACbH,EAAWE,EAEZ,CAMD,GAJAH,EAAyCF,EAAKG,CAAQ,GAAKN,EAAM,OAI7DK,IAAmBN,EAGvB,CAAAW,EAAgBV,EAAO,gBAAiB,CACvC,aAAc,GACd,KAAM,CACL,OAAOK,GAAkBJ,CACzB,CACH,CAAE,EAED,GAAI,CAUH,QANIU,EAIAC,EAAe,CAAA,EAEZP,IAAmB,MAAM,CAE/B,IAAIQ,EACHR,EAAe,YAAkCA,EAAgB,MAAQ,KAE1E,GAAI,CAEH,IAAIS,EAAYT,EAAe,KAAOH,CAAU,EAEhD,GAAIY,IAAc,QAAa,CAAsBT,EAAgB,SACpE,GAAIU,EAASD,CAAS,EAAG,CACxB,GAAI,CAAClB,EAAI,GAAGoB,CAAI,EAAIF,EACpBlB,EAAG,MAAMS,EAAgB,CAACL,EAAO,GAAGgB,CAAI,CAAC,CAC/C,MACMF,EAAU,KAAKT,EAAgBL,CAAK,CAGtC,OAAQiB,EAAO,CACXN,EACHC,EAAa,KAAKK,CAAK,EAEvBN,EAAcM,CAEf,CACD,GAAIjB,EAAM,cAAgBa,IAAmBd,GAAmBc,IAAmB,KAClF,MAEDR,EAAiBQ,CACjB,CAED,GAAIF,EAAa,CAChB,QAASM,KAASL,EAEjB,eAAe,IAAM,CACpB,MAAMK,CACX,CAAK,EAEF,MAAMN,CACN,CACH,QAAW,CAETX,EAAM,OAASD,EAEfM,EAAiBN,CACjB,EACF,CCpPO,MAAMJ,EAAwB,IAAI,IAG5BE,EAAqB,IAAI,IAmB/B,SAASqB,EAASC,EAAMC,EAAO,EAEvBD,EAAK,MAALA,EAAK,IAAQA,EAAK,cAEnBC,IAEZD,EAAK,UAAYA,EAAK,IAAMC,EAE9B,CAQO,SAASC,EAAKC,EAAQC,EAASC,EAAYC,EAAa,CAC1DF,IAAY,QAKfA,EAAQD,EAAQE,CAAU,CAE5B,CAyBO,SAASE,EAAMC,EAAWC,EAAS,CAKzC,MAAMN,EAASM,EAAQ,QAAUA,EAAQ,OAAO,YAAYC,EAAK,CAAE,EAEnE,OAAOC,EAAW,IAAMC,EAAOJ,EAAW,CAAE,GAAGC,EAAS,OAAAN,CAAM,CAAE,EAAG,EAAK,CACzE,CAyBO,SAASU,EAAQL,EAAWC,EAAS,CAK3C,MAAMK,EAASL,EAAQ,OACjBM,EAAyBC,EAE/B,GAAI,CAEH,OAAOL,EAAW,IAAM,CACvBM,EAAc,EAAI,EAGlB,QADIC,EAAOJ,EAAO,WAEjBI,IACCA,EAAK,WAAa,GAA6BA,EAAM,OAASC,IAE/DD,EAAOA,EAAK,YAGb,GAAI,CAACA,EACJ,MAAME,EAGP,MAAMjB,EAASkB,EAAeH,CAAI,EAC5BI,EAAWV,EAAOJ,EAAW,CAAE,GAAGC,EAAS,OAAAN,CAAM,CAAE,EAIzD,OAAAc,EAAc,EAAK,EAEZK,CACP,EAAE,EAAK,CACR,OAAQxB,EAAO,CACf,GAAIA,IAAUsB,EACb,OAAIX,EAAQ,UAAY,IACvBc,IAIDC,IACAC,EAAmBX,CAAM,EAEzBG,EAAc,EAAK,EACZV,EAAMC,EAAWC,CAAO,EAGhC,MAAMX,CACR,QAAW,CACTmB,EAAc,CAAC,CAACF,CAAsB,EACtCW,EAAkBX,CAAsB,EACxCY,GACA,CACF,CAeA,SAASf,EAAOgB,EAAW,CAAE,OAAAd,EAAQ,OAAAX,EAAQ,MAAA0B,EAAQ,CAAE,EAAE,OAAAvD,EAAQ,QAAAwD,EAAS,MAAAC,EAAQ,EAAK,EAAI,CAC1FP,IAEA,MAAMQ,EAAoB,IAAI,IAExBC,EAAuBtD,EAAyB,KAAK,KAAMmC,CAAM,EACjEoB,EAAgCvD,EAAyB,KAAK,KAAM,QAAQ,EAG5EwD,EAAgB7D,GAAW,CAChC,QAASC,EAAI,EAAGA,EAAID,EAAO,OAAQC,IAAK,CACvC,MAAMQ,EAAaT,EAAOC,CAAC,EACtByD,EAAkB,IAAIjD,CAAU,IACpCiD,EAAkB,IAAIjD,CAAU,EAIhC+B,EAAO,iBACN/B,EACAkD,EACAG,EAAuB,SAASrD,CAAU,EACvC,CACA,QAAS,EACT,EACA,MACR,EAGI,SAAS,iBACRA,EACAmD,EACAE,EAAuB,SAASrD,CAAU,EACvC,CACA,QAAS,EACT,EACA,MACR,EAEG,CACH,EAECoD,EAAaE,EAAW7D,CAAqB,CAAC,EAC9CE,EAAmB,IAAIyD,CAAY,EAInC,IAAI3B,EAEJ,MAAM8B,EAAUC,EAAY,KAC3BC,EAAO,IAAM,CACZ,GAAIV,EAAS,CACZW,EAAK,CAAE,CAAA,EACP,IAAIC,EAAyDC,EAC7DD,EAAI,EAAIZ,CACR,CAEGxD,IAEiBuD,EAAO,SAAWvD,GAKvCkC,EAAYoB,EAAUzB,EAAQ0B,CAAK,GAAK,CAAA,EAGpCC,GACHc,GAEJ,CAAG,EAEM,IAAM,CACZ,UAAW7D,KAAciD,EACxBlB,EAAO,oBAAoB/B,EAAYkD,CAAoB,EAC3D,SAAS,oBAAoBlD,EAAYkD,CAAoB,EAE9DvD,EAAmB,OAAOyD,CAAY,EACtCU,EAAmB,OAAOrC,CAAS,CACtC,EACE,EAED,OAAAqC,EAAmB,IAAIrC,EAAW8B,CAAO,EAClC9B,CACR,CAMA,IAAIqC,EAAqB,IAAI,QAMtB,SAASP,EAAQ9B,EAAW,CAClC,MAAM/B,EAAKoE,EAAmB,IAAIrC,CAAS,EAM3C/B,GAAA,MAAAA,GACD","x_google_ignoreList":[0,1]}