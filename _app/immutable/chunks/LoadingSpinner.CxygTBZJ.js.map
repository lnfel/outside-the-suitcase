{"version":3,"file":"LoadingSpinner.CxygTBZJ.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/blocks/await.js","../../../../../../src/lib/components/LoadingSpinner.svelte"],"sourcesContent":["import { is_promise, noop } from '../../../shared/utils.js';\nimport {\n\tcurrent_component_context,\n\tflush_sync,\n\tset_current_component_context,\n\tset_current_effect,\n\tset_current_reaction,\n\tset_dev_current_component_function\n} from '../../runtime.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { DEV } from 'esm-env';\nimport { queue_micro_task } from '../task.js';\nimport { hydrating } from '../hydration.js';\nimport { set, source } from '../../reactivity/sources.js';\n\nconst PENDING = 0;\nconst THEN = 1;\nconst CATCH = 2;\n\n/**\n * @template V\n * @param {Comment} anchor\n * @param {(() => Promise<V>)} get_input\n * @param {null | ((anchor: Node) => void)} pending_fn\n * @param {null | ((anchor: Node, value: import('#client').Source<V>) => void)} then_fn\n * @param {null | ((anchor: Node, error: unknown) => void)} catch_fn\n * @returns {void}\n */\nexport function await_block(anchor, get_input, pending_fn, then_fn, catch_fn) {\n\tvar component_context = current_component_context;\n\n\t/** @type {any} */\n\tvar component_function = DEV ? component_context?.function : null;\n\n\t/** @type {V | Promise<V>} */\n\tvar input;\n\n\t/** @type {import('#client').Effect | null} */\n\tvar pending_effect;\n\n\t/** @type {import('#client').Effect | null} */\n\tvar then_effect;\n\n\t/** @type {import('#client').Effect | null} */\n\tvar catch_effect;\n\n\tvar input_source = source(/** @type {V} */ (undefined));\n\tvar error_source = source(undefined);\n\tvar resolved = false;\n\n\t/**\n\t * @param {PENDING | THEN | CATCH} state\n\t * @param {boolean} restore\n\t */\n\tfunction update(state, restore) {\n\t\tresolved = true;\n\n\t\tif (restore) {\n\t\t\tset_current_effect(effect);\n\t\t\tset_current_reaction(effect); // TODO do we need both?\n\t\t\tset_current_component_context(component_context);\n\t\t\tif (DEV) set_dev_current_component_function(component_function);\n\t\t}\n\n\t\tif (state === PENDING && pending_fn) {\n\t\t\tif (pending_effect) resume_effect(pending_effect);\n\t\t\telse pending_effect = branch(() => pending_fn(anchor));\n\t\t}\n\n\t\tif (state === THEN && then_fn) {\n\t\t\tif (then_effect) resume_effect(then_effect);\n\t\t\telse then_effect = branch(() => then_fn(anchor, input_source));\n\t\t}\n\n\t\tif (state === CATCH && catch_fn) {\n\t\t\tif (catch_effect) resume_effect(catch_effect);\n\t\t\telse catch_effect = branch(() => catch_fn(anchor, error_source));\n\t\t}\n\n\t\tif (state !== PENDING && pending_effect) {\n\t\t\tpause_effect(pending_effect, () => (pending_effect = null));\n\t\t}\n\n\t\tif (state !== THEN && then_effect) {\n\t\t\tpause_effect(then_effect, () => (then_effect = null));\n\t\t}\n\n\t\tif (state !== CATCH && catch_effect) {\n\t\t\tpause_effect(catch_effect, () => (catch_effect = null));\n\t\t}\n\n\t\tif (restore) {\n\t\t\tif (DEV) set_dev_current_component_function(null);\n\t\t\tset_current_component_context(null);\n\t\t\tset_current_reaction(null);\n\t\t\tset_current_effect(null);\n\n\t\t\t// without this, the DOM does not update until two ticks after the promise\n\t\t\t// resolves, which is unexpected behaviour (and somewhat irksome to test)\n\t\t\tflush_sync();\n\t\t}\n\t}\n\n\tvar effect = block(() => {\n\t\tif (input === (input = get_input())) return;\n\n\t\tif (is_promise(input)) {\n\t\t\tvar promise = input;\n\n\t\t\tresolved = false;\n\n\t\t\tpromise.then(\n\t\t\t\t(value) => {\n\t\t\t\t\tif (promise !== input) return;\n\t\t\t\t\tset(input_source, value);\n\t\t\t\t\tupdate(THEN, true);\n\t\t\t\t},\n\t\t\t\t(error) => {\n\t\t\t\t\tif (promise !== input) return;\n\t\t\t\t\tset(error_source, error);\n\t\t\t\t\tupdate(CATCH, true);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif (hydrating) {\n\t\t\t\tif (pending_fn) {\n\t\t\t\t\tpending_effect = branch(() => pending_fn(anchor));\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// Wait a microtask before checking if we should show the pending state as\n\t\t\t\t// the promise might have resolved by the next microtask.\n\t\t\t\tqueue_micro_task(() => {\n\t\t\t\t\tif (!resolved) update(PENDING, true);\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tset(input_source, input);\n\t\t\tupdate(THEN, false);\n\t\t}\n\n\t\t// Inert effects are proactively detached from the effect tree. Returning a noop\n\t\t// teardown function is an easy way to ensure that this is not discarded\n\t\treturn noop;\n\t});\n}\n","<script>\n    let { class: className = \"\" } = $props()\n</script>\n\n<!-- See tailwind.config.js -->\n<div class=\"spinner animate-loading-spin {className}\"></div>\n\n<style>\n    .spinner {\n        width: 30px;\n        height: 30px;\n        border: 3px solid #b55829;\n    }\n</style>\n"],"names":["PENDING","THEN","CATCH","await_block","anchor","get_input","pending_fn","then_fn","catch_fn","component_context","current_component_context","input","pending_effect","then_effect","catch_effect","input_source","source","error_source","resolved","update","state","restore","set_current_effect","effect","set_current_reaction","set_current_component_context","resume_effect","branch","pause_effect","flush_sync","block","is_promise","promise","value","set","error","hydrating","queue_micro_task","noop","className"],"mappings":"iUAeA,MAAMA,EAAU,EACVC,EAAO,EACPC,EAAQ,EAWP,SAASC,EAAYC,EAAQC,EAAWC,EAAYC,EAASC,EAAU,CAC7E,IAAIC,EAAoBC,EAMpBC,EAGAC,EAGAC,EAGAC,EAEAC,EAAeC,EAAyB,QACxCC,EAAeD,EAAO,MAAS,EAC/BE,EAAW,GAMf,SAASC,EAAOC,EAAOC,EAAS,CAC/BH,EAAW,GAEPG,IACHC,EAAmBC,CAAM,EACzBC,EAAqBD,CAAM,EAC3BE,EAA8BhB,CAAiB,GAI5CW,IAAUpB,GAAWM,IACpBM,EAAgBc,EAAcd,CAAc,EAC3CA,EAAiBe,EAAO,IAAMrB,EAAWF,CAAM,CAAC,GAGlDgB,IAAUnB,GAAQM,IACjBM,EAAaa,EAAcb,CAAW,EACrCA,EAAcc,EAAO,IAAMpB,EAAQH,EAAQW,CAAY,CAAC,GAG1DK,IAAUlB,GAASM,IAClBM,EAAcY,EAAcZ,CAAY,EACvCA,EAAea,EAAO,IAAMnB,EAASJ,EAAQa,CAAY,CAAC,GAG5DG,IAAUpB,GAAWY,GACxBgB,EAAahB,EAAgB,IAAOA,EAAiB,IAAK,EAGvDQ,IAAUnB,GAAQY,GACrBe,EAAaf,EAAa,IAAOA,EAAc,IAAK,EAGjDO,IAAUlB,GAASY,GACtBc,EAAad,EAAc,IAAOA,EAAe,IAAK,EAGnDO,IAEHI,EAA8B,IAAI,EAClCD,EAAqB,IAAI,EACzBF,EAAmB,IAAI,EAIvBO,IAED,CAED,IAAIN,EAASO,EAAM,IAAM,CACxB,GAAInB,KAAWA,EAAQN,EAAS,GAEhC,IAAI0B,EAAWpB,CAAK,EAAG,CACtB,IAAIqB,EAAUrB,EAEdO,EAAW,GAEXc,EAAQ,KACNC,GAAU,CACND,IAAYrB,IAChBuB,EAAInB,EAAckB,CAAK,EACvBd,EAAOlB,EAAM,EAAI,EACjB,EACAkC,GAAU,CACNH,IAAYrB,IAChBuB,EAAIjB,EAAckB,CAAK,EACvBhB,EAAOjB,EAAO,EAAI,EAClB,CACL,EAEOkC,EACC9B,IACHM,EAAiBe,EAAO,IAAMrB,EAAWF,CAAM,CAAC,GAKjDiC,EAAiB,IAAM,CACjBnB,GAAUC,EAAOnB,EAAS,EAAI,CACxC,CAAK,CAEL,MACGkC,EAAInB,EAAcJ,CAAK,EACvBQ,EAAOlB,EAAM,EAAK,EAKnB,OAAOqC,EACT,CAAE,CACF,wCC/IiB,IAAAC,gBAAY,EAAE,sDAIWA,EAAS,GAAA,EAAA,gBAAA,CAAA","x_google_ignoreList":[0]}