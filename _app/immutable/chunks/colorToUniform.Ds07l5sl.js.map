{"version":3,"file":"colorToUniform.Ds07l5sl.js","sources":["../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/utils/createIdFromString.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getTestContext.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/getMaxFragmentPrecision.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/addProgramDefines.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/ensurePrecision.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/insertVersion.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/setProgramName.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gl/shader/program/preprocessors/stripVersion.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gl/shader/GlProgram.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getAttributeInfoFromFormat.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractAttributesFromGpuProgram.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/extractStructAndGroups.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/shader/const.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateGpuLayoutGroups.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/generateLayoutHash.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/utils/removeStructAndGroupDuplicates.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/GpuProgram.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/shader/types.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/shader/utils/getDefaultUniformValue.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/shader/UniformGroup.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/gpu/shader/BindGroup.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/types.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/shader/Shader.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/state/State.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/const.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/Buffer.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/ensureIsBuffer.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/utils/getGeometryBounds.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/geometry/Geometry.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/batcher/gpu/BatchGeometry.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/batcher/gl/utils/checkMaxIfStatementsInShader.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/batcher/gl/utils/maxRecommendedTextures.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/utils/data/ViewableBuffer.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/buffer/utils/fastCopy.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/state/const.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/state/getAdjustedBlendModeBlend.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/batcher/shared/BatchTextureArray.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/batcher/shared/Batcher.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/renderers/shared/texture/TexturePool.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/addBits.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileHooks.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileInputs.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/compileOutputs.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/compiler/utils/injectBits.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/compiler/compileHighShader.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/defaultProgramTemplate.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/globalUniformsBit.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/compileHighShaderToProgram.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/colorBit.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/generateTextureBatchBit.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/roundPixelsBit.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/rendering/high-shader/shader-bits/localUniformBit.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/scene/sprite/BatchableSprite.mjs","../../../../../../node_modules/.pnpm/pixi.js@8.1.8/node_modules/pixi.js/lib/scene/graphics/gpu/colorToUniform.mjs"],"sourcesContent":["\"use strict\";\nconst idCounts = /* @__PURE__ */ Object.create(null);\nconst idHash = /* @__PURE__ */ Object.create(null);\nfunction createIdFromString(value, groupId) {\n  let id = idHash[value];\n  if (id === void 0) {\n    if (idCounts[groupId] === void 0) {\n      idCounts[groupId] = 1;\n    }\n    idHash[value] = id = idCounts[groupId]++;\n  }\n  return id;\n}\n\nexport { createIdFromString };\n//# sourceMappingURL=createIdFromString.mjs.map\n","import { DOMAdapter } from '../../../../../environment/adapter.mjs';\n\n\"use strict\";\nlet context;\nfunction getTestContext() {\n  if (!context || context?.isContextLost()) {\n    const canvas = DOMAdapter.get().createCanvas();\n    context = canvas.getContext(\"webgl\", {});\n  }\n  return context;\n}\n\nexport { getTestContext };\n//# sourceMappingURL=getTestContext.mjs.map\n","import { getTestContext } from './getTestContext.mjs';\n\n\"use strict\";\nlet maxFragmentPrecision;\nfunction getMaxFragmentPrecision() {\n  if (!maxFragmentPrecision) {\n    maxFragmentPrecision = \"mediump\";\n    const gl = getTestContext();\n    if (gl) {\n      if (gl.getShaderPrecisionFormat) {\n        const shaderFragment = gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER, gl.HIGH_FLOAT);\n        maxFragmentPrecision = shaderFragment.precision ? \"highp\" : \"mediump\";\n      }\n    }\n  }\n  return maxFragmentPrecision;\n}\n\nexport { getMaxFragmentPrecision };\n//# sourceMappingURL=getMaxFragmentPrecision.mjs.map\n","\"use strict\";\nfunction addProgramDefines(src, isES300, isFragment) {\n  if (isES300)\n    return src;\n  if (isFragment) {\n    src = src.replace(\"out vec4 finalColor;\", \"\");\n    return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in varying\n        #define finalColor gl_FragColor\n        #define texture texture2D\n        #endif\n        ${src}\n        `;\n  }\n  return `\n        \n        #ifdef GL_ES // This checks if it is WebGL1\n        #define in attribute\n        #define out varying\n        #endif\n        ${src}\n        `;\n}\n\nexport { addProgramDefines };\n//# sourceMappingURL=addProgramDefines.mjs.map\n","\"use strict\";\nfunction ensurePrecision(src, options, isFragment) {\n  const maxSupportedPrecision = isFragment ? options.maxSupportedFragmentPrecision : options.maxSupportedVertexPrecision;\n  if (src.substring(0, 9) !== \"precision\") {\n    let precision = isFragment ? options.requestedFragmentPrecision : options.requestedVertexPrecision;\n    if (precision === \"highp\" && maxSupportedPrecision !== \"highp\") {\n      precision = \"mediump\";\n    }\n    return `precision ${precision} float;\n${src}`;\n  } else if (maxSupportedPrecision !== \"highp\" && src.substring(0, 15) === \"precision highp\") {\n    return src.replace(\"precision highp\", \"precision mediump\");\n  }\n  return src;\n}\n\nexport { ensurePrecision };\n//# sourceMappingURL=ensurePrecision.mjs.map\n","\"use strict\";\nfunction insertVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return `#version 300 es\n${src}`;\n}\n\nexport { insertVersion };\n//# sourceMappingURL=insertVersion.mjs.map\n","\"use strict\";\nconst fragmentNameCache = {};\nconst VertexNameCache = {};\nfunction setProgramName(src, { name = `pixi-program` }, isFragment = true) {\n  name = name.replace(/\\s+/g, \"-\");\n  name += isFragment ? \"-fragment\" : \"-vertex\";\n  const nameCache = isFragment ? fragmentNameCache : VertexNameCache;\n  if (nameCache[name]) {\n    nameCache[name]++;\n    name += `-${nameCache[name]}`;\n  } else {\n    nameCache[name] = 1;\n  }\n  if (src.indexOf(\"#define SHADER_NAME\") !== -1)\n    return src;\n  const shaderName = `#define SHADER_NAME ${name}`;\n  return `${shaderName}\n${src}`;\n}\n\nexport { setProgramName };\n//# sourceMappingURL=setProgramName.mjs.map\n","\"use strict\";\nfunction stripVersion(src, isES300) {\n  if (!isES300)\n    return src;\n  return src.replace(\"#version 300 es\", \"\");\n}\n\nexport { stripVersion };\n//# sourceMappingURL=stripVersion.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { getMaxFragmentPrecision } from './program/getMaxFragmentPrecision.mjs';\nimport { addProgramDefines } from './program/preprocessors/addProgramDefines.mjs';\nimport { ensurePrecision } from './program/preprocessors/ensurePrecision.mjs';\nimport { insertVersion } from './program/preprocessors/insertVersion.mjs';\nimport { setProgramName } from './program/preprocessors/setProgramName.mjs';\nimport { stripVersion } from './program/preprocessors/stripVersion.mjs';\n\n\"use strict\";\nconst processes = {\n  // strips any version headers..\n  stripVersion,\n  // adds precision string if not already present\n  ensurePrecision,\n  // add some defines if WebGL1 to make it more compatible with WebGL2 shaders\n  addProgramDefines,\n  // add the program name to the shader\n  setProgramName,\n  // add the version string to the shader header\n  insertVersion\n};\nconst programCache = /* @__PURE__ */ Object.create(null);\nconst _GlProgram = class _GlProgram {\n  /**\n   * Creates a shiny new GlProgram. Used by WebGL renderer.\n   * @param options - The options for the program.\n   */\n  constructor(options) {\n    options = { ..._GlProgram.defaultOptions, ...options };\n    const isES300 = options.fragment.indexOf(\"#version 300 es\") !== -1;\n    const preprocessorOptions = {\n      stripVersion: isES300,\n      ensurePrecision: {\n        requestedFragmentPrecision: options.preferredFragmentPrecision,\n        requestedVertexPrecision: options.preferredVertexPrecision,\n        maxSupportedVertexPrecision: \"highp\",\n        maxSupportedFragmentPrecision: getMaxFragmentPrecision()\n      },\n      setProgramName: {\n        name: options.name\n      },\n      addProgramDefines: isES300,\n      insertVersion: isES300\n    };\n    let fragment = options.fragment;\n    let vertex = options.vertex;\n    Object.keys(processes).forEach((processKey) => {\n      const processOptions = preprocessorOptions[processKey];\n      fragment = processes[processKey](fragment, processOptions, true);\n      vertex = processes[processKey](vertex, processOptions, false);\n    });\n    this.fragment = fragment;\n    this.vertex = vertex;\n    this._key = createIdFromString(`${this.vertex}:${this.fragment}`, \"gl-program\");\n  }\n  /** destroys the program */\n  destroy() {\n    this.fragment = null;\n    this.vertex = null;\n    this._attributeData = null;\n    this._uniformData = null;\n    this._uniformBlockData = null;\n    this.transformFeedbackVaryings = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex}:${options.fragment}`;\n    if (!programCache[key]) {\n      programCache[key] = new _GlProgram(options);\n    }\n    return programCache[key];\n  }\n};\n/** The default options used by the program. */\n_GlProgram.defaultOptions = {\n  preferredVertexPrecision: \"highp\",\n  preferredFragmentPrecision: \"mediump\"\n};\nlet GlProgram = _GlProgram;\n\nexport { GlProgram };\n//# sourceMappingURL=GlProgram.mjs.map\n","\"use strict\";\nconst attributeFormatData = {\n  uint8x2: { size: 2, stride: 2, normalised: false },\n  uint8x4: { size: 4, stride: 4, normalised: false },\n  sint8x2: { size: 2, stride: 2, normalised: false },\n  sint8x4: { size: 4, stride: 4, normalised: false },\n  unorm8x2: { size: 2, stride: 2, normalised: true },\n  unorm8x4: { size: 4, stride: 4, normalised: true },\n  snorm8x2: { size: 2, stride: 2, normalised: true },\n  snorm8x4: { size: 4, stride: 4, normalised: true },\n  uint16x2: { size: 2, stride: 4, normalised: false },\n  uint16x4: { size: 4, stride: 8, normalised: false },\n  sint16x2: { size: 2, stride: 4, normalised: false },\n  sint16x4: { size: 4, stride: 8, normalised: false },\n  unorm16x2: { size: 2, stride: 4, normalised: true },\n  unorm16x4: { size: 4, stride: 8, normalised: true },\n  snorm16x2: { size: 2, stride: 4, normalised: true },\n  snorm16x4: { size: 4, stride: 8, normalised: true },\n  float16x2: { size: 2, stride: 4, normalised: false },\n  float16x4: { size: 4, stride: 8, normalised: false },\n  float32: { size: 1, stride: 4, normalised: false },\n  float32x2: { size: 2, stride: 8, normalised: false },\n  float32x3: { size: 3, stride: 12, normalised: false },\n  float32x4: { size: 4, stride: 16, normalised: false },\n  uint32: { size: 1, stride: 4, normalised: false },\n  uint32x2: { size: 2, stride: 8, normalised: false },\n  uint32x3: { size: 3, stride: 12, normalised: false },\n  uint32x4: { size: 4, stride: 16, normalised: false },\n  sint32: { size: 1, stride: 4, normalised: false },\n  sint32x2: { size: 2, stride: 8, normalised: false },\n  sint32x3: { size: 3, stride: 12, normalised: false },\n  sint32x4: { size: 4, stride: 16, normalised: false }\n};\nfunction getAttributeInfoFromFormat(format) {\n  return attributeFormatData[format] ?? attributeFormatData.float32;\n}\n\nexport { getAttributeInfoFromFormat };\n//# sourceMappingURL=getAttributeInfoFromFormat.mjs.map\n","import { getAttributeInfoFromFormat } from '../../../shared/geometry/utils/getAttributeInfoFromFormat.mjs';\n\n\"use strict\";\nconst WGSL_TO_VERTEX_TYPES = {\n  f32: \"float32\",\n  \"vec2<f32>\": \"float32x2\",\n  \"vec3<f32>\": \"float32x3\",\n  \"vec4<f32>\": \"float32x4\",\n  vec2f: \"float32x2\",\n  vec3f: \"float32x3\",\n  vec4f: \"float32x4\",\n  i32: \"sint32\",\n  \"vec2<i32>\": \"sint32x2\",\n  \"vec3<i32>\": \"sint32x3\",\n  \"vec4<i32>\": \"sint32x4\",\n  u32: \"uint32\",\n  \"vec2<u32>\": \"uint32x2\",\n  \"vec3<u32>\": \"uint32x3\",\n  \"vec4<u32>\": \"uint32x4\",\n  bool: \"uint32\",\n  \"vec2<bool>\": \"uint32x2\",\n  \"vec3<bool>\": \"uint32x3\",\n  \"vec4<bool>\": \"uint32x4\"\n};\nfunction extractAttributesFromGpuProgram({ source, entryPoint }) {\n  const results = {};\n  const mainVertStart = source.indexOf(`fn ${entryPoint}`);\n  if (mainVertStart !== -1) {\n    const arrowFunctionStart = source.indexOf(\"->\", mainVertStart);\n    if (arrowFunctionStart !== -1) {\n      const functionArgsSubstring = source.substring(mainVertStart, arrowFunctionStart);\n      const inputsRegex = /@location\\((\\d+)\\)\\s+([a-zA-Z0-9_]+)\\s*:\\s*([a-zA-Z0-9_<>]+)(?:,|\\s|$)/g;\n      let match;\n      while ((match = inputsRegex.exec(functionArgsSubstring)) !== null) {\n        const format = WGSL_TO_VERTEX_TYPES[match[3]] ?? \"float32\";\n        results[match[2]] = {\n          location: parseInt(match[1], 10),\n          format,\n          stride: getAttributeInfoFromFormat(format).stride,\n          offset: 0,\n          instance: false,\n          start: 0\n        };\n      }\n    }\n  }\n  return results;\n}\n\nexport { extractAttributesFromGpuProgram };\n//# sourceMappingURL=extractAttributesFromGpuProgram.mjs.map\n","\"use strict\";\nfunction extractStructAndGroups(wgsl) {\n  const linePattern = /(^|[^/])@(group|binding)\\(\\d+\\)[^;]+;/g;\n  const groupPattern = /@group\\((\\d+)\\)/;\n  const bindingPattern = /@binding\\((\\d+)\\)/;\n  const namePattern = /var(<[^>]+>)? (\\w+)/;\n  const typePattern = /:\\s*(\\w+)/;\n  const structPattern = /struct\\s+(\\w+)\\s*{([^}]+)}/g;\n  const structMemberPattern = /(\\w+)\\s*:\\s*([\\w\\<\\>]+)/g;\n  const structName = /struct\\s+(\\w+)/;\n  const groups = wgsl.match(linePattern)?.map((item) => ({\n    group: parseInt(item.match(groupPattern)[1], 10),\n    binding: parseInt(item.match(bindingPattern)[1], 10),\n    name: item.match(namePattern)[2],\n    isUniform: item.match(namePattern)[1] === \"<uniform>\",\n    type: item.match(typePattern)[1]\n  }));\n  if (!groups) {\n    return {\n      groups: [],\n      structs: []\n    };\n  }\n  const structs = wgsl.match(structPattern)?.map((struct) => {\n    const name = struct.match(structName)[1];\n    const members = struct.match(structMemberPattern).reduce((acc, member) => {\n      const [name2, type] = member.split(\":\");\n      acc[name2.trim()] = type.trim();\n      return acc;\n    }, {});\n    if (!members) {\n      return null;\n    }\n    return { name, members };\n  }).filter(({ name }) => groups.some((group) => group.type === name)) ?? [];\n  return {\n    groups,\n    structs\n  };\n}\n\nexport { extractStructAndGroups };\n//# sourceMappingURL=extractStructAndGroups.mjs.map\n","\"use strict\";\nvar ShaderStage = /* @__PURE__ */ ((ShaderStage2) => {\n  ShaderStage2[ShaderStage2[\"VERTEX\"] = 1] = \"VERTEX\";\n  ShaderStage2[ShaderStage2[\"FRAGMENT\"] = 2] = \"FRAGMENT\";\n  ShaderStage2[ShaderStage2[\"COMPUTE\"] = 4] = \"COMPUTE\";\n  return ShaderStage2;\n})(ShaderStage || {});\n\nexport { ShaderStage };\n//# sourceMappingURL=const.mjs.map\n","import { ShaderStage } from '../../../shared/shader/const.mjs';\n\n\"use strict\";\nfunction generateGpuLayoutGroups({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = [];\n    }\n    if (group.isUniform) {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.VERTEX | ShaderStage.FRAGMENT,\n        buffer: {\n          type: \"uniform\"\n        }\n      });\n    } else if (group.type === \"sampler\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        sampler: {\n          type: \"filtering\"\n        }\n      });\n    } else if (group.type === \"texture_2d\") {\n      layout[group.group].push({\n        binding: group.binding,\n        visibility: ShaderStage.FRAGMENT,\n        texture: {\n          sampleType: \"float\",\n          viewDimension: \"2d\",\n          multisampled: false\n        }\n      });\n    }\n  }\n  return layout;\n}\n\nexport { generateGpuLayoutGroups };\n//# sourceMappingURL=generateGpuLayoutGroups.mjs.map\n","\"use strict\";\nfunction generateLayoutHash({ groups }) {\n  const layout = [];\n  for (let i = 0; i < groups.length; i++) {\n    const group = groups[i];\n    if (!layout[group.group]) {\n      layout[group.group] = {};\n    }\n    layout[group.group][group.name] = group.binding;\n  }\n  return layout;\n}\n\nexport { generateLayoutHash };\n//# sourceMappingURL=generateLayoutHash.mjs.map\n","\"use strict\";\nfunction removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups) {\n  const structNameSet = /* @__PURE__ */ new Set();\n  const dupeGroupKeySet = /* @__PURE__ */ new Set();\n  const structs = [...vertexStructsAndGroups.structs, ...fragmentStructsAndGroups.structs].filter((struct) => {\n    if (structNameSet.has(struct.name)) {\n      return false;\n    }\n    structNameSet.add(struct.name);\n    return true;\n  });\n  const groups = [...vertexStructsAndGroups.groups, ...fragmentStructsAndGroups.groups].filter((group) => {\n    const key = `${group.name}-${group.binding}`;\n    if (dupeGroupKeySet.has(key)) {\n      return false;\n    }\n    dupeGroupKeySet.add(key);\n    return true;\n  });\n  return { structs, groups };\n}\n\nexport { removeStructAndGroupDuplicates };\n//# sourceMappingURL=removeStructAndGroupDuplicates.mjs.map\n","import { createIdFromString } from '../../shared/utils/createIdFromString.mjs';\nimport { extractAttributesFromGpuProgram } from './utils/extractAttributesFromGpuProgram.mjs';\nimport { extractStructAndGroups } from './utils/extractStructAndGroups.mjs';\nimport { generateGpuLayoutGroups } from './utils/generateGpuLayoutGroups.mjs';\nimport { generateLayoutHash } from './utils/generateLayoutHash.mjs';\nimport { removeStructAndGroupDuplicates } from './utils/removeStructAndGroupDuplicates.mjs';\n\n\"use strict\";\nconst programCache = /* @__PURE__ */ Object.create(null);\nclass GpuProgram {\n  /**\n   * Create a new GpuProgram\n   * @param options - The options for the gpu program\n   */\n  constructor(options) {\n    /**\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    const { fragment, vertex, layout, gpuLayout, name } = options;\n    this.name = name;\n    this.fragment = fragment;\n    this.vertex = vertex;\n    if (fragment.source === vertex.source) {\n      const structsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = structsAndGroups;\n    } else {\n      const vertexStructsAndGroups = extractStructAndGroups(vertex.source);\n      const fragmentStructsAndGroups = extractStructAndGroups(fragment.source);\n      this.structsAndGroups = removeStructAndGroupDuplicates(vertexStructsAndGroups, fragmentStructsAndGroups);\n    }\n    this.layout = layout ?? generateLayoutHash(this.structsAndGroups);\n    this.gpuLayout = gpuLayout ?? generateGpuLayoutGroups(this.structsAndGroups);\n    this.autoAssignGlobalUniforms = !!(this.layout[0]?.globalUniforms !== void 0);\n    this.autoAssignLocalUniforms = !!(this.layout[1]?.localUniforms !== void 0);\n    this._generateProgramKey();\n  }\n  // TODO maker this pure\n  _generateProgramKey() {\n    const { vertex, fragment } = this;\n    const bigKey = vertex.source + fragment.source + vertex.entryPoint + fragment.entryPoint;\n    this._layoutKey = createIdFromString(bigKey, \"program\");\n  }\n  get attributeData() {\n    this._attributeData ?? (this._attributeData = extractAttributesFromGpuProgram(this.vertex));\n    return this._attributeData;\n  }\n  /** destroys the program */\n  destroy() {\n    this.gpuLayout = null;\n    this.layout = null;\n    this.structsAndGroups = null;\n    this.fragment = null;\n    this.vertex = null;\n  }\n  /**\n   * Helper function that creates a program for a given source.\n   * It will check the program cache if the program has already been created.\n   * If it has that one will be returned, if not a new one will be created and cached.\n   * @param options - The options for the program.\n   * @returns A program using the same source\n   */\n  static from(options) {\n    const key = `${options.vertex.source}:${options.fragment.source}:${options.fragment.entryPoint}:${options.vertex.entryPoint}`;\n    if (!programCache[key]) {\n      programCache[key] = new GpuProgram(options);\n    }\n    return programCache[key];\n  }\n}\n\nexport { GpuProgram };\n//# sourceMappingURL=GpuProgram.mjs.map\n","\"use strict\";\nconst UNIFORM_TYPES_VALUES = [\n  \"f32\",\n  \"i32\",\n  \"vec2<f32>\",\n  \"vec3<f32>\",\n  \"vec4<f32>\",\n  \"mat2x2<f32>\",\n  \"mat3x3<f32>\",\n  \"mat4x4<f32>\",\n  \"mat3x2<f32>\",\n  \"mat4x2<f32>\",\n  \"mat2x3<f32>\",\n  \"mat4x3<f32>\",\n  \"mat2x4<f32>\",\n  \"mat3x4<f32>\"\n];\nconst UNIFORM_TYPES_MAP = UNIFORM_TYPES_VALUES.reduce((acc, type) => {\n  acc[type] = true;\n  return acc;\n}, {});\n\nexport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES };\n//# sourceMappingURL=types.mjs.map\n","\"use strict\";\nfunction getDefaultUniformValue(type, size) {\n  switch (type) {\n    case \"f32\":\n      return 0;\n    case \"vec2<f32>\":\n      return new Float32Array(2 * size);\n    case \"vec3<f32>\":\n      return new Float32Array(3 * size);\n    case \"vec4<f32>\":\n      return new Float32Array(4 * size);\n    case \"mat2x2<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        1\n      ]);\n    case \"mat3x3<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        1\n      ]);\n    case \"mat4x4<f32>\":\n      return new Float32Array([\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1,\n        0,\n        0,\n        0,\n        0,\n        1\n      ]);\n  }\n  return null;\n}\n\nexport { getDefaultUniformValue };\n//# sourceMappingURL=getDefaultUniformValue.mjs.map\n","import { uid } from '../../../../utils/data/uid.mjs';\nimport { createIdFromString } from '../utils/createIdFromString.mjs';\nimport { UNIFORM_TYPES_MAP, UNIFORM_TYPES_VALUES } from './types.mjs';\nimport { getDefaultUniformValue } from './utils/getDefaultUniformValue.mjs';\n\n\"use strict\";\nconst _UniformGroup = class _UniformGroup {\n  /**\n   * Create a new Uniform group\n   * @param uniformStructures - The structures of the uniform group\n   * @param options - The optional parameters of this uniform group\n   */\n  constructor(uniformStructures, options) {\n    /** used internally to know if a uniform group was used in the last render pass */\n    this._touched = 0;\n    /** a unique id for this uniform group used through the renderer */\n    this.uid = uid(\"uniform\");\n    /** a resource type, used to identify how to handle it when its in a bind group / shader resource */\n    this._resourceType = \"uniformGroup\";\n    /** the resource id used internally by the renderer to build bind group keys */\n    this._resourceId = uid(\"resource\");\n    /** used ito identify if this is a uniform group */\n    this.isUniformGroup = true;\n    /**\n     * used to flag if this Uniform groups data is different from what it has stored in its buffer / on the GPU\n     * @internal\n     * @ignore\n     */\n    this._dirtyId = 0;\n    // implementing the interface - UniformGroup are not destroyed\n    this.destroyed = false;\n    options = { ..._UniformGroup.defaultOptions, ...options };\n    this.uniformStructures = uniformStructures;\n    const uniforms = {};\n    for (const i in uniformStructures) {\n      const uniformData = uniformStructures[i];\n      uniformData.name = i;\n      uniformData.size = uniformData.size ?? 1;\n      if (!UNIFORM_TYPES_MAP[uniformData.type]) {\n        throw new Error(`Uniform type ${uniformData.type} is not supported. Supported uniform types are: ${UNIFORM_TYPES_VALUES.join(\", \")}`);\n      }\n      uniformData.value ?? (uniformData.value = getDefaultUniformValue(uniformData.type, uniformData.size));\n      uniforms[i] = uniformData.value;\n    }\n    this.uniforms = uniforms;\n    this._dirtyId = 1;\n    this.ubo = options.ubo;\n    this.isStatic = options.isStatic;\n    this._signature = createIdFromString(Object.keys(uniforms).map(\n      (i) => `${i}-${uniformStructures[i].type}`\n    ).join(\"-\"), \"uniform-group\");\n  }\n  /** Call this if you want the uniform groups data to be uploaded to the GPU only useful if `isStatic` is true. */\n  update() {\n    this._dirtyId++;\n  }\n};\n/** The default options used by the uniform group. */\n_UniformGroup.defaultOptions = {\n  /** if true the UniformGroup is handled as an Uniform buffer object. */\n  ubo: false,\n  /** if true, then you are responsible for when the data is uploaded to the GPU by calling `update()` */\n  isStatic: false\n};\nlet UniformGroup = _UniformGroup;\n\nexport { UniformGroup };\n//# sourceMappingURL=UniformGroup.mjs.map\n","\"use strict\";\nclass BindGroup {\n  /**\n   * Create a new instance eof the Bind Group.\n   * @param resources - The resources that are bound together for use by a shader.\n   */\n  constructor(resources) {\n    /** The resources that are bound together for use by a shader. */\n    this.resources = /* @__PURE__ */ Object.create(null);\n    this._dirty = true;\n    let index = 0;\n    for (const i in resources) {\n      const resource = resources[i];\n      this.setResource(resource, index++);\n    }\n    this._updateKey();\n  }\n  /**\n   * Updates the key if its flagged as dirty. This is used internally to\n   * match this bind group to a WebGPU BindGroup.\n   * @internal\n   * @ignore\n   */\n  _updateKey() {\n    if (!this._dirty)\n      return;\n    this._dirty = false;\n    const keyParts = [];\n    let index = 0;\n    for (const i in this.resources) {\n      keyParts[index++] = this.resources[i]._resourceId;\n    }\n    this._key = keyParts.join(\"|\");\n  }\n  /**\n   * Set a resource at a given index. this function will\n   * ensure that listeners will be removed from the current resource\n   * and added to the new resource.\n   * @param resource - The resource to set.\n   * @param index - The index to set the resource at.\n   */\n  setResource(resource, index) {\n    const currentResource = this.resources[index];\n    if (resource === currentResource)\n      return;\n    if (currentResource) {\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    resource.on?.(\"change\", this.onResourceChange, this);\n    this.resources[index] = resource;\n    this._dirty = true;\n  }\n  /**\n   * Returns the resource at the current specified index.\n   * @param index - The index of the resource to get.\n   * @returns - The resource at the specified index.\n   */\n  getResource(index) {\n    return this.resources[index];\n  }\n  /**\n   * Used internally to 'touch' each resource, to ensure that the GC\n   * knows that all resources in this bind group are still being used.\n   * @param tick - The current tick.\n   * @internal\n   * @ignore\n   */\n  _touch(tick) {\n    const resources = this.resources;\n    for (const i in resources) {\n      resources[i]._touched = tick;\n    }\n  }\n  /** Destroys this bind group and removes all listeners. */\n  destroy() {\n    const resources = this.resources;\n    for (const i in resources) {\n      const resource = resources[i];\n      resource.off?.(\"change\", this.onResourceChange, this);\n    }\n    this.resources = null;\n  }\n  onResourceChange(resource) {\n    this._dirty = true;\n    if (resource.destroyed) {\n      const resources = this.resources;\n      for (const i in resources) {\n        if (resources[i] === resource) {\n          resources[i] = null;\n        }\n      }\n    } else {\n      this._updateKey();\n    }\n  }\n}\n\nexport { BindGroup };\n//# sourceMappingURL=BindGroup.mjs.map\n","\"use strict\";\nvar RendererType = /* @__PURE__ */ ((RendererType2) => {\n  RendererType2[RendererType2[\"WEBGL\"] = 1] = \"WEBGL\";\n  RendererType2[RendererType2[\"WEBGPU\"] = 2] = \"WEBGPU\";\n  RendererType2[RendererType2[\"BOTH\"] = 3] = \"BOTH\";\n  return RendererType2;\n})(RendererType || {});\n\nexport { RendererType };\n//# sourceMappingURL=types.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { GlProgram } from '../../gl/shader/GlProgram.mjs';\nimport { BindGroup } from '../../gpu/shader/BindGroup.mjs';\nimport { GpuProgram } from '../../gpu/shader/GpuProgram.mjs';\nimport { RendererType } from '../../types.mjs';\nimport { UniformGroup } from './UniformGroup.mjs';\n\n\"use strict\";\nclass Shader extends EventEmitter {\n  constructor(options) {\n    super();\n    /**\n     * A record of the uniform groups and resources used by the shader.\n     * This is used by WebGL renderer to sync uniform data.\n     * @internal\n     * @ignore\n     */\n    this._uniformBindMap = /* @__PURE__ */ Object.create(null);\n    this._ownedBindGroups = [];\n    let {\n      gpuProgram,\n      glProgram,\n      groups,\n      resources,\n      compatibleRenderers,\n      groupMap\n    } = options;\n    this.gpuProgram = gpuProgram;\n    this.glProgram = glProgram;\n    if (compatibleRenderers === void 0) {\n      compatibleRenderers = 0;\n      if (gpuProgram)\n        compatibleRenderers |= RendererType.WEBGPU;\n      if (glProgram)\n        compatibleRenderers |= RendererType.WEBGL;\n    }\n    this.compatibleRenderers = compatibleRenderers;\n    const nameHash = {};\n    if (!resources && !groups) {\n      resources = {};\n    }\n    if (resources && groups) {\n      throw new Error(\"[Shader] Cannot have both resources and groups\");\n    } else if (!gpuProgram && groups && !groupMap) {\n      throw new Error(\"[Shader] No group map or WebGPU shader provided - consider using resources instead.\");\n    } else if (!gpuProgram && groups && groupMap) {\n      for (const i in groupMap) {\n        for (const j in groupMap[i]) {\n          const uniformName = groupMap[i][j];\n          nameHash[uniformName] = {\n            group: i,\n            binding: j,\n            name: uniformName\n          };\n        }\n      }\n    } else if (gpuProgram && groups && !groupMap) {\n      const groupData = gpuProgram.structsAndGroups.groups;\n      groupMap = {};\n      groupData.forEach((data) => {\n        groupMap[data.group] = groupMap[data.group] || {};\n        groupMap[data.group][data.binding] = data.name;\n        nameHash[data.name] = data;\n      });\n    } else if (resources) {\n      if (!gpuProgram) {\n        groupMap = {};\n        groups = {\n          99: new BindGroup()\n        };\n        this._ownedBindGroups.push(groups[99]);\n        let bindTick = 0;\n        for (const i in resources) {\n          nameHash[i] = { group: 99, binding: bindTick, name: i };\n          groupMap[99] = groupMap[99] || {};\n          groupMap[99][bindTick] = i;\n          bindTick++;\n        }\n      } else {\n        const groupData = gpuProgram.structsAndGroups.groups;\n        groupMap = {};\n        groupData.forEach((data) => {\n          groupMap[data.group] = groupMap[data.group] || {};\n          groupMap[data.group][data.binding] = data.name;\n          nameHash[data.name] = data;\n        });\n      }\n      groups = {};\n      for (const i in resources) {\n        const name = i;\n        let value = resources[i];\n        if (!value.source && !value._resourceType) {\n          value = new UniformGroup(value);\n        }\n        const data = nameHash[name];\n        if (data) {\n          if (!groups[data.group]) {\n            groups[data.group] = new BindGroup();\n            this._ownedBindGroups.push(groups[data.group]);\n          }\n          groups[data.group].setResource(value, data.binding);\n        }\n      }\n    }\n    this.groups = groups;\n    this._uniformBindMap = groupMap;\n    this.resources = this._buildResourceAccessor(groups, nameHash);\n  }\n  /**\n   * Sometimes a resource group will be provided later (for example global uniforms)\n   * In such cases, this method can be used to let the shader know about the group.\n   * @param name - the name of the resource group\n   * @param groupIndex - the index of the group (should match the webGPU shader group location)\n   * @param bindIndex - the index of the bind point (should match the webGPU shader bind point)\n   */\n  addResource(name, groupIndex, bindIndex) {\n    var _a, _b;\n    (_a = this._uniformBindMap)[groupIndex] || (_a[groupIndex] = {});\n    (_b = this._uniformBindMap[groupIndex])[bindIndex] || (_b[bindIndex] = name);\n    if (!this.groups[groupIndex]) {\n      this.groups[groupIndex] = new BindGroup();\n      this._ownedBindGroups.push(this.groups[groupIndex]);\n    }\n  }\n  _buildResourceAccessor(groups, nameHash) {\n    const uniformsOut = {};\n    for (const i in nameHash) {\n      const data = nameHash[i];\n      Object.defineProperty(uniformsOut, data.name, {\n        get() {\n          return groups[data.group].getResource(data.binding);\n        },\n        set(value) {\n          groups[data.group].setResource(value, data.binding);\n        }\n      });\n    }\n    return uniformsOut;\n  }\n  /**\n   * Use to destroy the shader when its not longer needed.\n   * It will destroy the resources and remove listeners.\n   * @param destroyPrograms - if the programs should be destroyed as well.\n   * Make sure its not being used by other shaders!\n   */\n  destroy(destroyPrograms = false) {\n    this.emit(\"destroy\", this);\n    if (destroyPrograms) {\n      this.gpuProgram?.destroy();\n      this.glProgram?.destroy();\n    }\n    this.gpuProgram = null;\n    this.glProgram = null;\n    this.removeAllListeners();\n    this._uniformBindMap = null;\n    this._ownedBindGroups.forEach((bindGroup) => {\n      bindGroup.destroy();\n    });\n    this._ownedBindGroups = null;\n    this.resources = null;\n    this.groups = null;\n  }\n  static from(options) {\n    const { gpu, gl, ...rest } = options;\n    let gpuProgram;\n    let glProgram;\n    if (gpu) {\n      gpuProgram = GpuProgram.from(gpu);\n    }\n    if (gl) {\n      glProgram = GlProgram.from(gl);\n    }\n    return new Shader({\n      gpuProgram,\n      glProgram,\n      ...rest\n    });\n  }\n}\n\nexport { Shader };\n//# sourceMappingURL=Shader.mjs.map\n","\"use strict\";\nconst blendModeIds = {\n  normal: 0,\n  add: 1,\n  multiply: 2,\n  screen: 3,\n  overlay: 4,\n  erase: 5,\n  \"normal-npm\": 6,\n  \"add-npm\": 7,\n  \"screen-npm\": 8\n};\nconst BLEND = 0;\nconst OFFSET = 1;\nconst CULLING = 2;\nconst DEPTH_TEST = 3;\nconst WINDING = 4;\nconst DEPTH_MASK = 5;\nconst _State = class _State {\n  constructor() {\n    this.data = 0;\n    this.blendMode = \"normal\";\n    this.polygonOffset = 0;\n    this.blend = true;\n    this.depthMask = true;\n  }\n  /**\n   * Activates blending of the computed fragment color values.\n   * @default true\n   */\n  get blend() {\n    return !!(this.data & 1 << BLEND);\n  }\n  set blend(value) {\n    if (!!(this.data & 1 << BLEND) !== value) {\n      this.data ^= 1 << BLEND;\n    }\n  }\n  /**\n   * Activates adding an offset to depth values of polygon's fragments\n   * @default false\n   */\n  get offsets() {\n    return !!(this.data & 1 << OFFSET);\n  }\n  set offsets(value) {\n    if (!!(this.data & 1 << OFFSET) !== value) {\n      this.data ^= 1 << OFFSET;\n    }\n  }\n  /** The culling settings for this state none - No culling back - Back face culling front - Front face culling */\n  set cullMode(value) {\n    if (value === \"none\") {\n      this.culling = false;\n      return;\n    }\n    this.culling = true;\n    this.clockwiseFrontFace = value === \"front\";\n  }\n  get cullMode() {\n    if (!this.culling) {\n      return \"none\";\n    }\n    return this.clockwiseFrontFace ? \"front\" : \"back\";\n  }\n  /**\n   * Activates culling of polygons.\n   * @default false\n   */\n  get culling() {\n    return !!(this.data & 1 << CULLING);\n  }\n  set culling(value) {\n    if (!!(this.data & 1 << CULLING) !== value) {\n      this.data ^= 1 << CULLING;\n    }\n  }\n  /**\n   * Activates depth comparisons and updates to the depth buffer.\n   * @default false\n   */\n  get depthTest() {\n    return !!(this.data & 1 << DEPTH_TEST);\n  }\n  set depthTest(value) {\n    if (!!(this.data & 1 << DEPTH_TEST) !== value) {\n      this.data ^= 1 << DEPTH_TEST;\n    }\n  }\n  /**\n   * Enables or disables writing to the depth buffer.\n   * @default true\n   */\n  get depthMask() {\n    return !!(this.data & 1 << DEPTH_MASK);\n  }\n  set depthMask(value) {\n    if (!!(this.data & 1 << DEPTH_MASK) !== value) {\n      this.data ^= 1 << DEPTH_MASK;\n    }\n  }\n  /**\n   * Specifies whether or not front or back-facing polygons can be culled.\n   * @default false\n   */\n  get clockwiseFrontFace() {\n    return !!(this.data & 1 << WINDING);\n  }\n  set clockwiseFrontFace(value) {\n    if (!!(this.data & 1 << WINDING) !== value) {\n      this.data ^= 1 << WINDING;\n    }\n  }\n  /**\n   * The blend mode to be applied when this state is set. Apply a value of `normal` to reset the blend mode.\n   * Setting this mode to anything other than NO_BLEND will automatically switch blending on.\n   * @default 'normal'\n   */\n  get blendMode() {\n    return this._blendMode;\n  }\n  set blendMode(value) {\n    this.blend = value !== \"none\";\n    this._blendMode = value;\n    this._blendModeId = blendModeIds[value] || 0;\n  }\n  /**\n   * The polygon offset. Setting this property to anything other than 0 will automatically enable polygon offset fill.\n   * @default 0\n   */\n  get polygonOffset() {\n    return this._polygonOffset;\n  }\n  set polygonOffset(value) {\n    this.offsets = !!value;\n    this._polygonOffset = value;\n  }\n  toString() {\n    return `[pixi.js/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`;\n  }\n  /**\n   * A quickly getting an instance of a State that is configured for 2d rendering.\n   * @returns a new State with values set for 2d rendering\n   */\n  static for2d() {\n    const state = new _State();\n    state.depthTest = false;\n    state.blend = true;\n    return state;\n  }\n};\n_State.default2d = _State.for2d();\nlet State = _State;\n\nexport { State };\n//# sourceMappingURL=State.mjs.map\n","\"use strict\";\nvar BufferUsage = /* @__PURE__ */ ((BufferUsage2) => {\n  BufferUsage2[BufferUsage2[\"MAP_READ\"] = 1] = \"MAP_READ\";\n  BufferUsage2[BufferUsage2[\"MAP_WRITE\"] = 2] = \"MAP_WRITE\";\n  BufferUsage2[BufferUsage2[\"COPY_SRC\"] = 4] = \"COPY_SRC\";\n  BufferUsage2[BufferUsage2[\"COPY_DST\"] = 8] = \"COPY_DST\";\n  BufferUsage2[BufferUsage2[\"INDEX\"] = 16] = \"INDEX\";\n  BufferUsage2[BufferUsage2[\"VERTEX\"] = 32] = \"VERTEX\";\n  BufferUsage2[BufferUsage2[\"UNIFORM\"] = 64] = \"UNIFORM\";\n  BufferUsage2[BufferUsage2[\"STORAGE\"] = 128] = \"STORAGE\";\n  BufferUsage2[BufferUsage2[\"INDIRECT\"] = 256] = \"INDIRECT\";\n  BufferUsage2[BufferUsage2[\"QUERY_RESOLVE\"] = 512] = \"QUERY_RESOLVE\";\n  BufferUsage2[BufferUsage2[\"STATIC\"] = 1024] = \"STATIC\";\n  return BufferUsage2;\n})(BufferUsage || {});\n\nexport { BufferUsage };\n//# sourceMappingURL=const.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { BufferUsage } from './const.mjs';\n\n\"use strict\";\nclass Buffer extends EventEmitter {\n  /**\n   * Creates a new Buffer with the given options\n   * @param options - the options for the buffer\n   */\n  constructor(options) {\n    let { data, size } = options;\n    const { usage, label, shrinkToFit } = options;\n    super();\n    /**\n     * emits when the underlying buffer has changed shape (i.e. resized)\n     * letting the renderer know that it needs to discard the old buffer on the GPU and create a new one\n     * @event change\n     */\n    /**\n     * emits when the underlying buffer data has been updated. letting the renderer know\n     * that it needs to update the buffer on the GPU\n     * @event update\n     */\n    /**\n     * emits when the buffer is destroyed. letting the renderer know that it needs to destroy the buffer on the GPU\n     * @event destroy\n     */\n    /**\n     * a unique id for this uniform group used through the renderer\n     * @internal\n     * @ignore\n     */\n    this.uid = uid(\"buffer\");\n    /**\n     * a resource type, used to identify how to handle it when its in a bind group / shader resource\n     * @internal\n     * @ignore\n     */\n    this._resourceType = \"buffer\";\n    /**\n     * the resource id used internally by the renderer to build bind group keys\n     * @internal\n     * @ignore\n     */\n    this._resourceId = uid(\"resource\");\n    /**\n     * used internally to know if a uniform group was used in the last render pass\n     * @internal\n     * @ignore\n     */\n    this._touched = 0;\n    /**\n     * @internal\n     * @ignore\n     */\n    this._updateID = 1;\n    /**\n     * should the GPU buffer be shrunk when the data becomes smaller?\n     * changing this will cause the buffer to be destroyed and a new one created on the GPU\n     * this can be expensive, especially if the buffer is already big enough!\n     * setting this to false will prevent the buffer from being shrunk. This will yield better performance\n     * if you are constantly setting data that is changing size often.\n     * @default true\n     */\n    this.shrinkToFit = true;\n    /**\n     * Has the buffer been destroyed?\n     * @readonly\n     */\n    this.destroyed = false;\n    if (data instanceof Array) {\n      data = new Float32Array(data);\n    }\n    this._data = data;\n    size = size ?? data?.byteLength;\n    const mappedAtCreation = !!data;\n    this.descriptor = {\n      size,\n      usage,\n      mappedAtCreation,\n      label\n    };\n    this.shrinkToFit = shrinkToFit ?? true;\n  }\n  /** the data in the buffer */\n  get data() {\n    return this._data;\n  }\n  set data(value) {\n    this.setDataWithSize(value, value.length, true);\n  }\n  /** whether the buffer is static or not */\n  get static() {\n    return !!(this.descriptor.usage & BufferUsage.STATIC);\n  }\n  set static(value) {\n    if (value) {\n      this.descriptor.usage |= BufferUsage.STATIC;\n    } else {\n      this.descriptor.usage &= ~BufferUsage.STATIC;\n    }\n  }\n  /**\n   * Sets the data in the buffer to the given value. This will immediately update the buffer on the GPU.\n   * If you only want to update a subset of the buffer, you can pass in the size of the data.\n   * @param value - the data to set\n   * @param size - the size of the data in bytes\n   * @param syncGPU - should the buffer be updated on the GPU immediately?\n   */\n  setDataWithSize(value, size, syncGPU) {\n    this._updateID++;\n    this._updateSize = size * value.BYTES_PER_ELEMENT;\n    if (this._data === value) {\n      if (syncGPU)\n        this.emit(\"update\", this);\n      return;\n    }\n    const oldData = this._data;\n    this._data = value;\n    if (oldData.length !== value.length) {\n      if (!this.shrinkToFit && value.byteLength < oldData.byteLength) {\n        if (syncGPU)\n          this.emit(\"update\", this);\n      } else {\n        this.descriptor.size = value.byteLength;\n        this._resourceId = uid(\"resource\");\n        this.emit(\"change\", this);\n      }\n      return;\n    }\n    if (syncGPU)\n      this.emit(\"update\", this);\n  }\n  /**\n   * updates the buffer on the GPU to reflect the data in the buffer.\n   * By default it will update the entire buffer. If you only want to update a subset of the buffer,\n   * you can pass in the size of the buffer to update.\n   * @param sizeInBytes - the new size of the buffer in bytes\n   */\n  update(sizeInBytes) {\n    this._updateSize = sizeInBytes ?? this._updateSize;\n    this._updateID++;\n    this.emit(\"update\", this);\n  }\n  /** Destroys the buffer */\n  destroy() {\n    this.destroyed = true;\n    this.emit(\"destroy\", this);\n    this.emit(\"change\", this);\n    this._data = null;\n    this.descriptor = null;\n    this.removeAllListeners();\n  }\n}\n\nexport { Buffer };\n//# sourceMappingURL=Buffer.mjs.map\n","import { Buffer } from '../../buffer/Buffer.mjs';\nimport { BufferUsage } from '../../buffer/const.mjs';\n\n\"use strict\";\nfunction ensureIsBuffer(buffer, index) {\n  if (!(buffer instanceof Buffer)) {\n    let usage = index ? BufferUsage.INDEX : BufferUsage.VERTEX;\n    if (buffer instanceof Array) {\n      if (index) {\n        buffer = new Uint32Array(buffer);\n        usage = BufferUsage.INDEX | BufferUsage.COPY_DST;\n      } else {\n        buffer = new Float32Array(buffer);\n        usage = BufferUsage.VERTEX | BufferUsage.COPY_DST;\n      }\n    }\n    buffer = new Buffer({\n      data: buffer,\n      label: index ? \"index-mesh-buffer\" : \"vertex-mesh-buffer\",\n      usage\n    });\n  }\n  return buffer;\n}\n\nexport { ensureIsBuffer };\n//# sourceMappingURL=ensureIsBuffer.mjs.map\n","\"use strict\";\nfunction getGeometryBounds(geometry, attributeId, bounds) {\n  const attribute = geometry.getAttribute(attributeId);\n  if (!attribute) {\n    bounds.minX = 0;\n    bounds.minY = 0;\n    bounds.maxX = 0;\n    bounds.maxY = 0;\n    return bounds;\n  }\n  const data = attribute.buffer.data;\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n  const byteSize = data.BYTES_PER_ELEMENT;\n  const offset = (attribute.offset || 0) / byteSize;\n  const stride = (attribute.stride || 2 * 4) / byteSize;\n  for (let i = offset; i < data.length; i += stride) {\n    const x = data[i];\n    const y = data[i + 1];\n    if (x > maxX)\n      maxX = x;\n    if (y > maxY)\n      maxY = y;\n    if (x < minX)\n      minX = x;\n    if (y < minY)\n      minY = y;\n  }\n  bounds.minX = minX;\n  bounds.minY = minY;\n  bounds.maxX = maxX;\n  bounds.maxY = maxY;\n  return bounds;\n}\n\nexport { getGeometryBounds };\n//# sourceMappingURL=getGeometryBounds.mjs.map\n","import EventEmitter from 'eventemitter3';\nimport { Bounds } from '../../../../scene/container/bounds/Bounds.mjs';\nimport { uid } from '../../../../utils/data/uid.mjs';\nimport { Buffer } from '../buffer/Buffer.mjs';\nimport { ensureIsBuffer } from './utils/ensureIsBuffer.mjs';\nimport { getGeometryBounds } from './utils/getGeometryBounds.mjs';\n\n\"use strict\";\nfunction ensureIsAttribute(attribute) {\n  if (attribute instanceof Buffer || Array.isArray(attribute) || attribute.BYTES_PER_ELEMENT) {\n    attribute = {\n      buffer: attribute\n    };\n  }\n  attribute.buffer = ensureIsBuffer(attribute.buffer, false);\n  return attribute;\n}\nclass Geometry extends EventEmitter {\n  /**\n   * Create a new instance of a geometry\n   * @param options - The options for the geometry.\n   */\n  constructor(options) {\n    const { attributes, indexBuffer, topology } = options;\n    super();\n    /** The unique id of the geometry. */\n    this.uid = uid(\"geometry\");\n    /**\n     * the layout key will be generated by WebGPU all geometries that have the same structure\n     * will have the same layout key. This is used to cache the pipeline layout\n     * @internal\n     * @ignore\n     */\n    this._layoutKey = 0;\n    /** the instance count of the geometry to draw */\n    this.instanceCount = 1;\n    this._bounds = new Bounds();\n    this._boundsDirty = true;\n    this.attributes = attributes;\n    this.buffers = [];\n    this.instanceCount = options.instanceCount || 1;\n    for (const i in attributes) {\n      const attribute = attributes[i] = ensureIsAttribute(attributes[i]);\n      const bufferIndex = this.buffers.indexOf(attribute.buffer);\n      if (bufferIndex === -1) {\n        this.buffers.push(attribute.buffer);\n        attribute.buffer.on(\"update\", this.onBufferUpdate, this);\n        attribute.buffer.on(\"change\", this.onBufferUpdate, this);\n      }\n    }\n    if (indexBuffer) {\n      this.indexBuffer = ensureIsBuffer(indexBuffer, true);\n      this.buffers.push(this.indexBuffer);\n    }\n    this.topology = topology || \"triangle-list\";\n  }\n  onBufferUpdate() {\n    this._boundsDirty = true;\n    this.emit(\"update\", this);\n  }\n  /**\n   * Returns the requested attribute.\n   * @param id - The name of the attribute required\n   * @returns - The attribute requested.\n   */\n  getAttribute(id) {\n    return this.attributes[id];\n  }\n  /**\n   * Returns the index buffer\n   * @returns - The index buffer.\n   */\n  getIndex() {\n    return this.indexBuffer;\n  }\n  /**\n   * Returns the requested buffer.\n   * @param id - The name of the buffer required.\n   * @returns - The buffer requested.\n   */\n  getBuffer(id) {\n    return this.getAttribute(id).buffer;\n  }\n  /**\n   * Used to figure out how many vertices there are in this geometry\n   * @returns the number of vertices in the geometry\n   */\n  getSize() {\n    for (const i in this.attributes) {\n      const attribute = this.attributes[i];\n      const buffer = attribute.buffer;\n      return buffer.data.length / (attribute.stride / 4 || attribute.size);\n    }\n    return 0;\n  }\n  /** Returns the bounds of the geometry. */\n  get bounds() {\n    if (!this._boundsDirty)\n      return this._bounds;\n    this._boundsDirty = false;\n    return getGeometryBounds(this, \"aPosition\", this._bounds);\n  }\n  /**\n   * destroys the geometry.\n   * @param destroyBuffers - destroy the buffers associated with this geometry\n   */\n  destroy(destroyBuffers = false) {\n    this.emit(\"destroy\", this);\n    this.removeAllListeners();\n    if (destroyBuffers) {\n      this.buffers.forEach((buffer) => buffer.destroy());\n    }\n    this.attributes = null;\n    this.buffers = null;\n    this.indexBuffer = null;\n    this._bounds = null;\n  }\n}\n\nexport { Geometry };\n//# sourceMappingURL=Geometry.mjs.map\n","import { Buffer } from '../../renderers/shared/buffer/Buffer.mjs';\nimport { BufferUsage } from '../../renderers/shared/buffer/const.mjs';\nimport { Geometry } from '../../renderers/shared/geometry/Geometry.mjs';\n\n\"use strict\";\nconst placeHolderBufferData = new Float32Array(1);\nconst placeHolderIndexData = new Uint32Array(1);\nclass BatchGeometry extends Geometry {\n  constructor() {\n    const vertexSize = 6;\n    const attributeBuffer = new Buffer({\n      data: placeHolderBufferData,\n      label: \"attribute-batch-buffer\",\n      usage: BufferUsage.VERTEX | BufferUsage.COPY_DST,\n      shrinkToFit: false\n    });\n    const indexBuffer = new Buffer({\n      data: placeHolderIndexData,\n      label: \"index-batch-buffer\",\n      usage: BufferUsage.INDEX | BufferUsage.COPY_DST,\n      // | BufferUsage.STATIC,\n      shrinkToFit: false\n    });\n    const stride = vertexSize * 4;\n    super({\n      attributes: {\n        aPosition: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 0,\n          location: 1\n        },\n        aUV: {\n          buffer: attributeBuffer,\n          format: \"float32x2\",\n          stride,\n          offset: 2 * 4,\n          location: 3\n        },\n        aColor: {\n          buffer: attributeBuffer,\n          format: \"unorm8x4\",\n          stride,\n          offset: 4 * 4,\n          location: 0\n        },\n        aTextureIdAndRound: {\n          buffer: attributeBuffer,\n          format: \"uint16x2\",\n          stride,\n          offset: 5 * 4,\n          location: 2\n        }\n      },\n      indexBuffer\n    });\n  }\n}\n\nexport { BatchGeometry };\n//# sourceMappingURL=BatchGeometry.mjs.map\n","\"use strict\";\nconst fragTemplate = [\n  \"precision mediump float;\",\n  \"void main(void){\",\n  \"float test = 0.1;\",\n  \"%forloop%\",\n  \"gl_FragColor = vec4(0.0);\",\n  \"}\"\n].join(\"\\n\");\nfunction generateIfTestSrc(maxIfs) {\n  let src = \"\";\n  for (let i = 0; i < maxIfs; ++i) {\n    if (i > 0) {\n      src += \"\\nelse \";\n    }\n    if (i < maxIfs - 1) {\n      src += `if(test == ${i}.0){}`;\n    }\n  }\n  return src;\n}\nfunction checkMaxIfStatementsInShader(maxIfs, gl) {\n  if (maxIfs === 0) {\n    throw new Error(\"Invalid value of `0` passed to `checkMaxIfStatementsInShader`\");\n  }\n  const shader = gl.createShader(gl.FRAGMENT_SHADER);\n  while (true) {\n    const fragmentSrc = fragTemplate.replace(/%forloop%/gi, generateIfTestSrc(maxIfs));\n    gl.shaderSource(shader, fragmentSrc);\n    gl.compileShader(shader);\n    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {\n      maxIfs = maxIfs / 2 | 0;\n    } else {\n      break;\n    }\n  }\n  return maxIfs;\n}\n\nexport { checkMaxIfStatementsInShader };\n//# sourceMappingURL=checkMaxIfStatementsInShader.mjs.map\n","import { getTestContext } from '../../../renderers/gl/shader/program/getTestContext.mjs';\nimport { checkMaxIfStatementsInShader } from './checkMaxIfStatementsInShader.mjs';\n\n\"use strict\";\nlet maxTexturesPerBatchCache = null;\nfunction getMaxTexturesPerBatch() {\n  if (maxTexturesPerBatchCache)\n    return maxTexturesPerBatchCache;\n  const gl = getTestContext();\n  maxTexturesPerBatchCache = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n  maxTexturesPerBatchCache = checkMaxIfStatementsInShader(\n    maxTexturesPerBatchCache,\n    gl\n  );\n  return maxTexturesPerBatchCache;\n}\n\nexport { getMaxTexturesPerBatch };\n//# sourceMappingURL=maxRecommendedTextures.mjs.map\n","\"use strict\";\nclass ViewableBuffer {\n  constructor(sizeOrBuffer) {\n    if (typeof sizeOrBuffer === \"number\") {\n      this.rawBinaryData = new ArrayBuffer(sizeOrBuffer);\n    } else if (sizeOrBuffer instanceof Uint8Array) {\n      this.rawBinaryData = sizeOrBuffer.buffer;\n    } else {\n      this.rawBinaryData = sizeOrBuffer;\n    }\n    this.uint32View = new Uint32Array(this.rawBinaryData);\n    this.float32View = new Float32Array(this.rawBinaryData);\n    this.size = this.rawBinaryData.byteLength;\n  }\n  /** View on the raw binary data as a `Int8Array`. */\n  get int8View() {\n    if (!this._int8View) {\n      this._int8View = new Int8Array(this.rawBinaryData);\n    }\n    return this._int8View;\n  }\n  /** View on the raw binary data as a `Uint8Array`. */\n  get uint8View() {\n    if (!this._uint8View) {\n      this._uint8View = new Uint8Array(this.rawBinaryData);\n    }\n    return this._uint8View;\n  }\n  /**  View on the raw binary data as a `Int16Array`. */\n  get int16View() {\n    if (!this._int16View) {\n      this._int16View = new Int16Array(this.rawBinaryData);\n    }\n    return this._int16View;\n  }\n  /** View on the raw binary data as a `Int32Array`. */\n  get int32View() {\n    if (!this._int32View) {\n      this._int32View = new Int32Array(this.rawBinaryData);\n    }\n    return this._int32View;\n  }\n  /** View on the raw binary data as a `Float64Array`. */\n  get float64View() {\n    if (!this._float64Array) {\n      this._float64Array = new Float64Array(this.rawBinaryData);\n    }\n    return this._float64Array;\n  }\n  /** View on the raw binary data as a `BigUint64Array`. */\n  get bigUint64View() {\n    if (!this._bigUint64Array) {\n      this._bigUint64Array = new BigUint64Array(this.rawBinaryData);\n    }\n    return this._bigUint64Array;\n  }\n  /**\n   * Returns the view of the given type.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *    `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - typed array of given type\n   */\n  view(type) {\n    return this[`${type}View`];\n  }\n  /** Destroys all buffer references. Do not use after calling this. */\n  destroy() {\n    this.rawBinaryData = null;\n    this._int8View = null;\n    this._uint8View = null;\n    this._int16View = null;\n    this.uint16View = null;\n    this._int32View = null;\n    this.uint32View = null;\n    this.float32View = null;\n  }\n  /**\n   * Returns the size of the given type in bytes.\n   * @param type - One of `int8`, `uint8`, `int16`,\n   *   `uint16`, `int32`, `uint32`, and `float32`.\n   * @returns - size of the type in bytes\n   */\n  static sizeOf(type) {\n    switch (type) {\n      case \"int8\":\n      case \"uint8\":\n        return 1;\n      case \"int16\":\n      case \"uint16\":\n        return 2;\n      case \"int32\":\n      case \"uint32\":\n      case \"float32\":\n        return 4;\n      default:\n        throw new Error(`${type} isn't a valid view type`);\n    }\n  }\n}\n\nexport { ViewableBuffer };\n//# sourceMappingURL=ViewableBuffer.mjs.map\n","\"use strict\";\nfunction fastCopy(sourceBuffer, destinationBuffer) {\n  const lengthDouble = sourceBuffer.byteLength / 8 | 0;\n  const sourceFloat64View = new Float64Array(sourceBuffer, 0, lengthDouble);\n  const destinationFloat64View = new Float64Array(destinationBuffer, 0, lengthDouble);\n  destinationFloat64View.set(sourceFloat64View);\n  const remainingBytes = sourceBuffer.byteLength - lengthDouble * 8;\n  if (remainingBytes > 0) {\n    const sourceUint8View = new Uint8Array(sourceBuffer, lengthDouble * 8, remainingBytes);\n    const destinationUint8View = new Uint8Array(destinationBuffer, lengthDouble * 8, remainingBytes);\n    destinationUint8View.set(sourceUint8View);\n  }\n}\n\nexport { fastCopy };\n//# sourceMappingURL=fastCopy.mjs.map\n","\"use strict\";\nconst BLEND_TO_NPM = {\n  normal: \"normal-npm\",\n  add: \"add-npm\",\n  screen: \"screen-npm\"\n};\nvar STENCIL_MODES = /* @__PURE__ */ ((STENCIL_MODES2) => {\n  STENCIL_MODES2[STENCIL_MODES2[\"DISABLED\"] = 0] = \"DISABLED\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_ADD\"] = 1] = \"RENDERING_MASK_ADD\";\n  STENCIL_MODES2[STENCIL_MODES2[\"MASK_ACTIVE\"] = 2] = \"MASK_ACTIVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"RENDERING_MASK_REMOVE\"] = 3] = \"RENDERING_MASK_REMOVE\";\n  STENCIL_MODES2[STENCIL_MODES2[\"NONE\"] = 4] = \"NONE\";\n  return STENCIL_MODES2;\n})(STENCIL_MODES || {});\n\nexport { BLEND_TO_NPM, STENCIL_MODES };\n//# sourceMappingURL=const.mjs.map\n","import { BLEND_TO_NPM } from './const.mjs';\n\n\"use strict\";\nfunction getAdjustedBlendModeBlend(blendMode, textureSource) {\n  if (textureSource.alphaMode === \"no-premultiply-alpha\") {\n    return BLEND_TO_NPM[blendMode] || blendMode;\n  }\n  return blendMode;\n}\n\nexport { getAdjustedBlendModeBlend };\n//# sourceMappingURL=getAdjustedBlendModeBlend.mjs.map\n","\"use strict\";\nclass BatchTextureArray {\n  constructor() {\n    /** Respective locations for textures. */\n    this.ids = /* @__PURE__ */ Object.create(null);\n    this.textures = [];\n    this.count = 0;\n  }\n  /** Clear the textures and their locations. */\n  clear() {\n    for (let i = 0; i < this.count; i++) {\n      const t = this.textures[i];\n      this.textures[i] = null;\n      this.ids[t.uid] = null;\n    }\n    this.count = 0;\n  }\n}\n\nexport { BatchTextureArray };\n//# sourceMappingURL=BatchTextureArray.mjs.map\n","import { uid } from '../../../utils/data/uid.mjs';\nimport { ViewableBuffer } from '../../../utils/data/ViewableBuffer.mjs';\nimport { fastCopy } from '../../renderers/shared/buffer/utils/fastCopy.mjs';\nimport { getAdjustedBlendModeBlend } from '../../renderers/shared/state/getAdjustedBlendModeBlend.mjs';\nimport { getMaxTexturesPerBatch } from '../gl/utils/maxRecommendedTextures.mjs';\nimport { BatchTextureArray } from './BatchTextureArray.mjs';\n\n\"use strict\";\nclass Batch {\n  constructor() {\n    this.renderPipeId = \"batch\";\n    this.action = \"startBatch\";\n    // TODO - eventually this could be useful for flagging batches as dirty and then only rebuilding those ones\n    // public elementStart = 0;\n    // public elementSize = 0;\n    // for drawing..\n    this.start = 0;\n    this.size = 0;\n    this.blendMode = \"normal\";\n    this.canBundle = true;\n  }\n  destroy() {\n    this.textures = null;\n    this.gpuBindGroup = null;\n    this.bindGroup = null;\n    this.batcher = null;\n  }\n}\nlet BATCH_TICK = 0;\nconst _Batcher = class _Batcher {\n  constructor(options = {}) {\n    this.uid = uid(\"batcher\");\n    this.dirty = true;\n    this.batchIndex = 0;\n    this.batches = [];\n    // specifics.\n    this._vertexSize = 6;\n    this._elements = [];\n    this._batchPool = [];\n    this._batchPoolIndex = 0;\n    this._textureBatchPool = [];\n    this._textureBatchPoolIndex = 0;\n    options = { ..._Batcher.defaultOptions, ...options };\n    const { vertexSize, indexSize } = options;\n    this.attributeBuffer = new ViewableBuffer(vertexSize * this._vertexSize * 4);\n    this.indexBuffer = new Uint16Array(indexSize);\n    this._maxTextures = getMaxTexturesPerBatch();\n  }\n  begin() {\n    this.batchIndex = 0;\n    this.elementSize = 0;\n    this.elementStart = 0;\n    this.indexSize = 0;\n    this.attributeSize = 0;\n    this._batchPoolIndex = 0;\n    this._textureBatchPoolIndex = 0;\n    this._batchIndexStart = 0;\n    this._batchIndexSize = 0;\n    this.dirty = true;\n  }\n  add(batchableObject) {\n    this._elements[this.elementSize++] = batchableObject;\n    batchableObject.indexStart = this.indexSize;\n    batchableObject.location = this.attributeSize;\n    batchableObject.batcher = this;\n    this.indexSize += batchableObject.indexSize;\n    this.attributeSize += batchableObject.vertexSize * this._vertexSize;\n  }\n  checkAndUpdateTexture(batchableObject, texture) {\n    const textureId = batchableObject.batch.textures.ids[texture._source.uid];\n    if (!textureId && textureId !== 0)\n      return false;\n    batchableObject.textureId = textureId;\n    batchableObject.texture = texture;\n    return true;\n  }\n  updateElement(batchableObject) {\n    this.dirty = true;\n    batchableObject.packAttributes(\n      this.attributeBuffer.float32View,\n      this.attributeBuffer.uint32View,\n      batchableObject.location,\n      batchableObject.textureId\n    );\n  }\n  /**\n   * breaks the batcher. This happens when a batch gets too big,\n   * or we need to switch to a different type of rendering (a filter for example)\n   * @param instructionSet\n   */\n  break(instructionSet) {\n    const elements = this._elements;\n    let textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n    textureBatch.clear();\n    if (!elements[this.elementStart])\n      return;\n    const firstElement = elements[this.elementStart];\n    let blendMode = getAdjustedBlendModeBlend(firstElement.blendMode, firstElement.texture._source);\n    if (this.attributeSize * 4 > this.attributeBuffer.size) {\n      this._resizeAttributeBuffer(this.attributeSize * 4);\n    }\n    if (this.indexSize > this.indexBuffer.length) {\n      this._resizeIndexBuffer(this.indexSize);\n    }\n    const f32 = this.attributeBuffer.float32View;\n    const u32 = this.attributeBuffer.uint32View;\n    const iBuffer = this.indexBuffer;\n    let size = this._batchIndexSize;\n    let start = this._batchIndexStart;\n    let action = \"startBatch\";\n    let batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n    const maxTextures = this._maxTextures;\n    for (let i = this.elementStart; i < this.elementSize; ++i) {\n      const element = elements[i];\n      elements[i] = null;\n      const texture = element.texture;\n      const source = texture._source;\n      const adjustedBlendMode = getAdjustedBlendModeBlend(element.blendMode, source);\n      const blendModeChange = blendMode !== adjustedBlendMode;\n      if (source._batchTick === BATCH_TICK && !blendModeChange) {\n        element.textureId = source._textureBindLocation;\n        size += element.indexSize;\n        element.packAttributes(f32, u32, element.location, element.textureId);\n        element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n        element.batch = batch;\n        continue;\n      }\n      source._batchTick = BATCH_TICK;\n      if (textureBatch.count >= maxTextures || blendModeChange) {\n        this._finishBatch(\n          batch,\n          start,\n          size - start,\n          textureBatch,\n          blendMode,\n          instructionSet,\n          action\n        );\n        action = \"renderBatch\";\n        start = size;\n        blendMode = adjustedBlendMode;\n        textureBatch = this._textureBatchPool[this._textureBatchPoolIndex++] || new BatchTextureArray();\n        textureBatch.clear();\n        batch = this._batchPool[this._batchPoolIndex++] || new Batch();\n        ++BATCH_TICK;\n      }\n      element.textureId = source._textureBindLocation = textureBatch.count;\n      textureBatch.ids[source.uid] = textureBatch.count;\n      textureBatch.textures[textureBatch.count++] = source;\n      element.batch = batch;\n      size += element.indexSize;\n      element.packAttributes(f32, u32, element.location, element.textureId);\n      element.packIndex(iBuffer, element.indexStart, element.location / this._vertexSize);\n    }\n    if (textureBatch.count > 0) {\n      this._finishBatch(\n        batch,\n        start,\n        size - start,\n        textureBatch,\n        blendMode,\n        instructionSet,\n        action\n      );\n      start = size;\n      ++BATCH_TICK;\n    }\n    this.elementStart = this.elementSize;\n    this._batchIndexStart = start;\n    this._batchIndexSize = size;\n  }\n  _finishBatch(batch, indexStart, indexSize, textureBatch, blendMode, instructionSet, action) {\n    batch.gpuBindGroup = null;\n    batch.action = action;\n    batch.batcher = this;\n    batch.textures = textureBatch;\n    batch.blendMode = blendMode;\n    batch.start = indexStart;\n    batch.size = indexSize;\n    ++BATCH_TICK;\n    instructionSet.add(batch);\n  }\n  finish(instructionSet) {\n    this.break(instructionSet);\n  }\n  /**\n   * Resizes the attribute buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureAttributeBuffer(size) {\n    if (size * 4 <= this.attributeBuffer.size)\n      return;\n    this._resizeAttributeBuffer(size * 4);\n  }\n  /**\n   * Resizes the index buffer to the given size (1 = 1 float32)\n   * @param size - the size in vertices to ensure (not bytes!)\n   */\n  ensureIndexBuffer(size) {\n    if (size <= this.indexBuffer.length)\n      return;\n    this._resizeIndexBuffer(size);\n  }\n  _resizeAttributeBuffer(size) {\n    const newSize = Math.max(size, this.attributeBuffer.size * 2);\n    const newArrayBuffer = new ViewableBuffer(newSize);\n    fastCopy(this.attributeBuffer.rawBinaryData, newArrayBuffer.rawBinaryData);\n    this.attributeBuffer = newArrayBuffer;\n  }\n  _resizeIndexBuffer(size) {\n    const indexBuffer = this.indexBuffer;\n    let newSize = Math.max(size, indexBuffer.length * 1.5);\n    newSize += newSize % 2;\n    const newIndexBuffer = newSize > 65535 ? new Uint32Array(newSize) : new Uint16Array(newSize);\n    if (newIndexBuffer.BYTES_PER_ELEMENT !== indexBuffer.BYTES_PER_ELEMENT) {\n      for (let i = 0; i < indexBuffer.length; i++) {\n        newIndexBuffer[i] = indexBuffer[i];\n      }\n    } else {\n      fastCopy(indexBuffer.buffer, newIndexBuffer.buffer);\n    }\n    this.indexBuffer = newIndexBuffer;\n  }\n  destroy() {\n    for (let i = 0; i < this.batches.length; i++) {\n      this.batches[i].destroy();\n    }\n    this.batches = null;\n    for (let i = 0; i < this._elements.length; i++) {\n      this._elements[i].batch = null;\n    }\n    this._elements = null;\n    this.indexBuffer = null;\n    this.attributeBuffer.destroy();\n    this.attributeBuffer = null;\n  }\n};\n_Batcher.defaultOptions = {\n  vertexSize: 4,\n  indexSize: 6\n};\nlet Batcher = _Batcher;\n\nexport { Batch, Batcher };\n//# sourceMappingURL=Batcher.mjs.map\n","import { nextPow2 } from '../../../../maths/misc/pow2.mjs';\nimport { TextureSource } from './sources/TextureSource.mjs';\nimport { Texture } from './Texture.mjs';\n\n\"use strict\";\nlet count = 0;\nclass TexturePoolClass {\n  /**\n   * @param textureOptions - options that will be passed to BaseRenderTexture constructor\n   * @param {SCALE_MODE} [textureOptions.scaleMode] - See {@link SCALE_MODE} for possible values.\n   */\n  constructor(textureOptions) {\n    this._poolKeyHash = /* @__PURE__ */ Object.create(null);\n    this._texturePool = {};\n    this.textureOptions = textureOptions || {};\n    this.enableFullScreen = false;\n  }\n  /**\n   * Creates texture with params that were specified in pool constructor.\n   * @param pixelWidth - Width of texture in pixels.\n   * @param pixelHeight - Height of texture in pixels.\n   * @param antialias\n   */\n  createTexture(pixelWidth, pixelHeight, antialias) {\n    const textureSource = new TextureSource({\n      ...this.textureOptions,\n      width: pixelWidth,\n      height: pixelHeight,\n      resolution: 1,\n      antialias,\n      autoGarbageCollect: true\n    });\n    return new Texture({\n      source: textureSource,\n      label: `texturePool_${count++}`\n    });\n  }\n  /**\n   * Gets a Power-of-Two render texture or fullScreen texture\n   * @param frameWidth - The minimum width of the render texture.\n   * @param frameHeight - The minimum height of the render texture.\n   * @param resolution - The resolution of the render texture.\n   * @param antialias\n   * @returns The new render texture.\n   */\n  getOptimalTexture(frameWidth, frameHeight, resolution = 1, antialias) {\n    let po2Width = Math.ceil(frameWidth * resolution - 1e-6);\n    let po2Height = Math.ceil(frameHeight * resolution - 1e-6);\n    po2Width = nextPow2(po2Width);\n    po2Height = nextPow2(po2Height);\n    const key = (po2Width << 17) + (po2Height << 1) + (antialias ? 1 : 0);\n    if (!this._texturePool[key]) {\n      this._texturePool[key] = [];\n    }\n    let texture = this._texturePool[key].pop();\n    if (!texture) {\n      texture = this.createTexture(po2Width, po2Height, antialias);\n    }\n    texture.source._resolution = resolution;\n    texture.source.width = po2Width / resolution;\n    texture.source.height = po2Height / resolution;\n    texture.source.pixelWidth = po2Width;\n    texture.source.pixelHeight = po2Height;\n    texture.frame.x = 0;\n    texture.frame.y = 0;\n    texture.frame.width = frameWidth;\n    texture.frame.height = frameHeight;\n    texture.updateUvs();\n    this._poolKeyHash[texture.uid] = key;\n    return texture;\n  }\n  /**\n   * Gets extra texture of the same size as input renderTexture\n   * @param texture - The texture to check what size it is.\n   * @param antialias - Whether to use antialias.\n   * @returns A texture that is a power of two\n   */\n  getSameSizeTexture(texture, antialias = false) {\n    const source = texture.source;\n    return this.getOptimalTexture(texture.width, texture.height, source._resolution, antialias);\n  }\n  /**\n   * Place a render texture back into the pool.\n   * @param renderTexture - The renderTexture to free\n   */\n  returnTexture(renderTexture) {\n    const key = this._poolKeyHash[renderTexture.uid];\n    this._texturePool[key].push(renderTexture);\n  }\n  /**\n   * Clears the pool.\n   * @param destroyTextures - Destroy all stored textures.\n   */\n  clear(destroyTextures) {\n    destroyTextures = destroyTextures !== false;\n    if (destroyTextures) {\n      for (const i in this._texturePool) {\n        const textures = this._texturePool[i];\n        if (textures) {\n          for (let j = 0; j < textures.length; j++) {\n            textures[j].destroy(true);\n          }\n        }\n      }\n    }\n    this._texturePool = {};\n  }\n}\nconst TexturePool = new TexturePoolClass();\n\nexport { TexturePool, TexturePoolClass };\n//# sourceMappingURL=TexturePool.mjs.map\n","import { warn } from '../../../../utils/logging/warn.mjs';\n\n\"use strict\";\nfunction addBits(srcParts, parts, name) {\n  if (srcParts) {\n    for (const i in srcParts) {\n      const id = i.toLocaleLowerCase();\n      const part = parts[id];\n      if (part) {\n        let sanitisedPart = srcParts[i];\n        if (i === \"header\") {\n          sanitisedPart = sanitisedPart.replace(/@in\\s+[^;]+;\\s*/g, \"\").replace(/@out\\s+[^;]+;\\s*/g, \"\");\n        }\n        if (name) {\n          part.push(`//----${name}----//`);\n        }\n        part.push(sanitisedPart);\n      } else {\n        warn(`${i} placement hook does not exist in shader`);\n      }\n    }\n  }\n}\n\nexport { addBits };\n//# sourceMappingURL=addBits.mjs.map\n","\"use strict\";\nconst findHooksRx = /\\{\\{(.*?)\\}\\}/g;\nfunction compileHooks(programSrc) {\n  const parts = {};\n  const partMatches = programSrc.match(findHooksRx)?.map((hook) => hook.replace(/[{()}]/g, \"\")) ?? [];\n  partMatches.forEach((hook) => {\n    parts[hook] = [];\n  });\n  return parts;\n}\n\nexport { compileHooks, findHooksRx };\n//# sourceMappingURL=compileHooks.mjs.map\n","\"use strict\";\nfunction extractInputs(fragmentSource, out) {\n  let match;\n  const regex = /@in\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction compileInputs(fragments, template, sort = false) {\n  const results = [];\n  extractInputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractInputs(fragment.header, results);\n    }\n  });\n  const mainInput = results;\n  if (sort) {\n    mainInput.sort();\n  }\n  const finalString = mainInput.map((inValue, i) => `       @location(${i}) ${inValue},`).join(\"\\n\");\n  let cleanedString = template.replace(/@in\\s+[^;]+;\\s*/g, \"\");\n  cleanedString = cleanedString.replace(\"{{in}}\", `\n${finalString}\n`);\n  return cleanedString;\n}\n\nexport { compileInputs };\n//# sourceMappingURL=compileInputs.mjs.map\n","\"use strict\";\nfunction extractOutputs(fragmentSource, out) {\n  let match;\n  const regex = /@out\\s+([^;]+);/g;\n  while ((match = regex.exec(fragmentSource)) !== null) {\n    out.push(match[1]);\n  }\n}\nfunction extractVariableName(value) {\n  const regex = /\\b(\\w+)\\s*:/g;\n  const match = regex.exec(value);\n  return match ? match[1] : \"\";\n}\nfunction stripVariable(value) {\n  const regex = /@.*?\\s+/g;\n  return value.replace(regex, \"\");\n}\nfunction compileOutputs(fragments, template) {\n  const results = [];\n  extractOutputs(template, results);\n  fragments.forEach((fragment) => {\n    if (fragment.header) {\n      extractOutputs(fragment.header, results);\n    }\n  });\n  let index = 0;\n  const mainStruct = results.sort().map((inValue) => {\n    if (inValue.indexOf(\"builtin\") > -1) {\n      return inValue;\n    }\n    return `@location(${index++}) ${inValue}`;\n  }).join(\",\\n\");\n  const mainStart = results.sort().map((inValue) => `       var ${stripVariable(inValue)};`).join(\"\\n\");\n  const mainEnd = `return VSOutput(\n                ${results.sort().map((inValue) => ` ${extractVariableName(inValue)}`).join(\",\\n\")});`;\n  let compiledCode = template.replace(/@out\\s+[^;]+;\\s*/g, \"\");\n  compiledCode = compiledCode.replace(\"{{struct}}\", `\n${mainStruct}\n`);\n  compiledCode = compiledCode.replace(\"{{start}}\", `\n${mainStart}\n`);\n  compiledCode = compiledCode.replace(\"{{return}}\", `\n${mainEnd}\n`);\n  return compiledCode;\n}\n\nexport { compileOutputs };\n//# sourceMappingURL=compileOutputs.mjs.map\n","\"use strict\";\nfunction injectBits(templateSrc, fragmentParts) {\n  let out = templateSrc;\n  for (const i in fragmentParts) {\n    const parts = fragmentParts[i];\n    const toInject = parts.join(\"\\n\");\n    if (toInject.length) {\n      out = out.replace(`{{${i}}}`, `//-----${i} START-----//\n${parts.join(\"\\n\")}\n//----${i} FINISH----//`);\n    } else {\n      out = out.replace(`{{${i}}}`, \"\");\n    }\n  }\n  return out;\n}\n\nexport { injectBits };\n//# sourceMappingURL=injectBits.mjs.map\n","import { addBits } from './utils/addBits.mjs';\nimport { compileHooks } from './utils/compileHooks.mjs';\nimport { compileInputs } from './utils/compileInputs.mjs';\nimport { compileOutputs } from './utils/compileOutputs.mjs';\nimport { injectBits } from './utils/injectBits.mjs';\n\n\"use strict\";\nconst cacheMap = /* @__PURE__ */ Object.create(null);\nconst bitCacheMap = /* @__PURE__ */ new Map();\nlet CACHE_UID = 0;\nfunction compileHighShader({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  const { vertex, fragment } = compileInputsAndOutputs(template, bits);\n  cacheMap[cacheId] = compileBits(vertex, fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileHighShaderGl({\n  template,\n  bits\n}) {\n  const cacheId = generateCacheId(template, bits);\n  if (cacheMap[cacheId])\n    return cacheMap[cacheId];\n  cacheMap[cacheId] = compileBits(template.vertex, template.fragment, bits);\n  return cacheMap[cacheId];\n}\nfunction compileInputsAndOutputs(template, bits) {\n  const vertexFragments = bits.map((shaderBit) => shaderBit.vertex).filter((v) => !!v);\n  const fragmentFragments = bits.map((shaderBit) => shaderBit.fragment).filter((v) => !!v);\n  let compiledVertex = compileInputs(vertexFragments, template.vertex, true);\n  compiledVertex = compileOutputs(vertexFragments, compiledVertex);\n  const compiledFragment = compileInputs(fragmentFragments, template.fragment, true);\n  return {\n    vertex: compiledVertex,\n    fragment: compiledFragment\n  };\n}\nfunction generateCacheId(template, bits) {\n  return bits.map((highFragment) => {\n    if (!bitCacheMap.has(highFragment)) {\n      bitCacheMap.set(highFragment, CACHE_UID++);\n    }\n    return bitCacheMap.get(highFragment);\n  }).sort((a, b) => a - b).join(\"-\") + template.vertex + template.fragment;\n}\nfunction compileBits(vertex, fragment, bits) {\n  const vertexParts = compileHooks(vertex);\n  const fragmentParts = compileHooks(fragment);\n  bits.forEach((shaderBit) => {\n    addBits(shaderBit.vertex, vertexParts, shaderBit.name);\n    addBits(shaderBit.fragment, fragmentParts, shaderBit.name);\n  });\n  return {\n    vertex: injectBits(vertex, vertexParts),\n    fragment: injectBits(fragment, fragmentParts)\n  };\n}\n\nexport { compileHighShader, compileHighShaderGl };\n//# sourceMappingURL=compileHighShader.mjs.map\n","\"use strict\";\nconst vertexGPUTemplate = (\n  /* wgsl */\n  `\n    @in aPosition: vec2<f32>;\n    @in aUV: vec2<f32>;\n\n    @out @builtin(position) vPosition: vec4<f32>;\n    @out vUV : vec2<f32>;\n    @out vColor : vec4<f32>;\n\n    {{header}}\n\n    struct VSOutput {\n        {{struct}}\n    };\n\n    @vertex\n    fn main( {{in}} ) -> VSOutput {\n\n        var worldTransformMatrix = globalUniforms.uWorldTransformMatrix;\n        var modelMatrix = mat3x3<f32>(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        var position = aPosition;\n        var uv = aUV;\n\n        {{start}}\n        \n        vColor = vec4<f32>(1., 1., 1., 1.);\n\n        {{main}}\n\n        vUV = uv;\n\n        var modelViewProjectionMatrix = globalUniforms.uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        vPosition =  vec4<f32>((modelViewProjectionMatrix *  vec3<f32>(position, 1.0)).xy, 0.0, 1.0);\n       \n        vColor *= globalUniforms.uWorldColorAlpha;\n\n        {{end}}\n\n        {{return}}\n    };\n`\n);\nconst fragmentGPUTemplate = (\n  /* wgsl */\n  `\n    @in vUV : vec2<f32>;\n    @in vColor : vec4<f32>;\n   \n    {{header}}\n\n    @fragment\n    fn main(\n        {{in}}\n      ) -> @location(0) vec4<f32> {\n        \n        {{start}}\n\n        var outColor:vec4<f32>;\n      \n        {{main}}\n        \n        return outColor * vColor;\n      };\n`\n);\nconst vertexGlTemplate = (\n  /* glsl */\n  `\n    in vec2 aPosition;\n    in vec2 aUV;\n\n    out vec4 vColor;\n    out vec2 vUV;\n\n    {{header}}\n\n    void main(void){\n\n        mat3 worldTransformMatrix = uWorldTransformMatrix;\n        mat3 modelMatrix = mat3(\n            1.0, 0.0, 0.0,\n            0.0, 1.0, 0.0,\n            0.0, 0.0, 1.0\n          );\n        vec2 position = aPosition;\n        vec2 uv = aUV;\n        \n        {{start}}\n        \n        vColor = vec4(1.);\n        \n        {{main}}\n        \n        vUV = uv;\n        \n        mat3 modelViewProjectionMatrix = uProjectionMatrix * worldTransformMatrix * modelMatrix;\n\n        gl_Position = vec4((modelViewProjectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);\n\n        vColor *= uWorldColorAlpha;\n\n        {{end}}\n    }\n`\n);\nconst fragmentGlTemplate = (\n  /* glsl */\n  `\n   \n    in vec4 vColor;\n    in vec2 vUV;\n\n    out vec4 finalColor;\n\n    {{header}}\n\n    void main(void) {\n        \n        {{start}}\n\n        vec4 outColor;\n      \n        {{main}}\n        \n        finalColor = outColor * vColor;\n    }\n`\n);\n\nexport { fragmentGPUTemplate, fragmentGlTemplate, vertexGPUTemplate, vertexGlTemplate };\n//# sourceMappingURL=defaultProgramTemplate.mjs.map\n","\"use strict\";\nconst globalUniformsBit = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n        struct GlobalUniforms {\n            uProjectionMatrix:mat3x3<f32>,\n            uWorldTransformMatrix:mat3x3<f32>,\n            uWorldColorAlpha: vec4<f32>,\n            uResolution: vec2<f32>,\n        }\n\n        @group(0) @binding(0) var<uniform> globalUniforms : GlobalUniforms;\n        `\n    )\n  }\n};\nconst globalUniformsUBOBitGl = {\n  name: \"global-uniforms-ubo-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform globalUniforms {\n            mat3 uProjectionMatrix;\n            mat3 uWorldTransformMatrix;\n            vec4 uWorldColorAlpha;\n            vec2 uResolution;\n          };\n        `\n    )\n  }\n};\nconst globalUniformsBitGl = {\n  name: \"global-uniforms-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n          uniform mat3 uProjectionMatrix;\n          uniform mat3 uWorldTransformMatrix;\n          uniform vec4 uWorldColorAlpha;\n          uniform vec2 uResolution;\n        `\n    )\n  }\n};\n\nexport { globalUniformsBit, globalUniformsBitGl, globalUniformsUBOBitGl };\n//# sourceMappingURL=globalUniformsBit.mjs.map\n","import { GlProgram } from '../renderers/gl/shader/GlProgram.mjs';\nimport { GpuProgram } from '../renderers/gpu/shader/GpuProgram.mjs';\nimport { compileHighShader, compileHighShaderGl } from './compiler/compileHighShader.mjs';\nimport { fragmentGPUTemplate, vertexGPUTemplate, vertexGlTemplate, fragmentGlTemplate } from './defaultProgramTemplate.mjs';\nimport { globalUniformsBit, globalUniformsBitGl } from './shader-bits/globalUniformsBit.mjs';\n\n\"use strict\";\nfunction compileHighShaderGpuProgram({ bits, name }) {\n  const source = compileHighShader({\n    template: {\n      fragment: fragmentGPUTemplate,\n      vertex: vertexGPUTemplate\n    },\n    bits: [\n      globalUniformsBit,\n      ...bits\n    ]\n  });\n  return GpuProgram.from({\n    name,\n    vertex: {\n      source: source.vertex,\n      entryPoint: \"main\"\n    },\n    fragment: {\n      source: source.fragment,\n      entryPoint: \"main\"\n    }\n  });\n}\nfunction compileHighShaderGlProgram({ bits, name }) {\n  return new GlProgram({\n    name,\n    ...compileHighShaderGl({\n      template: {\n        vertex: vertexGlTemplate,\n        fragment: fragmentGlTemplate\n      },\n      bits: [\n        globalUniformsBitGl,\n        ...bits\n      ]\n    })\n  });\n}\n\nexport { compileHighShaderGlProgram, compileHighShaderGpuProgram };\n//# sourceMappingURL=compileHighShaderToProgram.mjs.map\n","\"use strict\";\nconst colorBit = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            @in aColor: vec4<f32>;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= vec4<f32>(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\nconst colorBitGl = {\n  name: \"color-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n            in vec4 aColor;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= vec4(aColor.rgb * aColor.a, aColor.a);\n        `\n    )\n  }\n};\n\nexport { colorBit, colorBitGl };\n//# sourceMappingURL=colorBit.mjs.map\n","import { getMaxTexturesPerBatch } from '../../batcher/gl/utils/maxRecommendedTextures.mjs';\n\n\"use strict\";\nconst textureBatchBitGpuCache = {};\nfunction generateBindingSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"@group(1) @binding(0) var textureSource1: texture_2d<f32>;\");\n    src.push(\"@group(1) @binding(1) var textureSampler1: sampler;\");\n  } else {\n    let bindingIndex = 0;\n    for (let i = 0; i < maxTextures; i++) {\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSource${i + 1}: texture_2d<f32>;`);\n      src.push(`@group(1) @binding(${bindingIndex++}) var textureSampler${i + 1}: sampler;`);\n    }\n  }\n  return src.join(\"\\n\");\n}\nfunction generateSampleSrc(maxTextures) {\n  const src = [];\n  if (maxTextures === 1) {\n    src.push(\"outColor = textureSampleGrad(textureSource1, textureSampler1, vUV, uvDx, uvDy);\");\n  } else {\n    src.push(\"switch vTextureId {\");\n    for (let i = 0; i < maxTextures; i++) {\n      if (i === maxTextures - 1) {\n        src.push(`  default:{`);\n      } else {\n        src.push(`  case ${i}:{`);\n      }\n      src.push(`      outColor = textureSampleGrad(textureSource${i + 1}, textureSampler${i + 1}, vUV, uvDx, uvDy);`);\n      src.push(`      break;}`);\n    }\n    src.push(`}`);\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBit(maxTextures) {\n  if (!textureBatchBitGpuCache[maxTextures]) {\n    textureBatchBitGpuCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                @in aTextureIdAndRound: vec2<u32>;\n                @out @interpolate(flat) vTextureId : u32;\n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1)\n                {\n                    vPosition = vec4<f32>(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                @in @interpolate(flat) vTextureId: u32;\n    \n                ${generateBindingSrc(getMaxTexturesPerBatch())}\n            `,\n        main: `\n                var uvDx = dpdx(vUV);\n                var uvDy = dpdy(vUV);\n    \n                ${generateSampleSrc(getMaxTexturesPerBatch())}\n            `\n      }\n    };\n  }\n  return textureBatchBitGpuCache[maxTextures];\n}\nconst textureBatchBitGlCache = {};\nfunction generateSampleGlSrc(maxTextures) {\n  const src = [];\n  for (let i = 0; i < maxTextures; i++) {\n    if (i > 0) {\n      src.push(\"else\");\n    }\n    if (i < maxTextures - 1) {\n      src.push(`if(vTextureId < ${i}.5)`);\n    }\n    src.push(\"{\");\n    src.push(`\toutColor = texture(uTextures[${i}], vUV);`);\n    src.push(\"}\");\n  }\n  return src.join(\"\\n\");\n}\nfunction generateTextureBatchBitGl(maxTextures) {\n  if (!textureBatchBitGlCache[maxTextures]) {\n    textureBatchBitGlCache[maxTextures] = {\n      name: \"texture-batch-bit\",\n      vertex: {\n        header: `\n                in vec2 aTextureIdAndRound;\n                out float vTextureId;\n              \n            `,\n        main: `\n                vTextureId = aTextureIdAndRound.y;\n            `,\n        end: `\n                if(aTextureIdAndRound.x == 1.)\n                {\n                    gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n                }\n            `\n      },\n      fragment: {\n        header: `\n                in float vTextureId;\n    \n                uniform sampler2D uTextures[${maxTextures}];\n              \n            `,\n        main: `\n    \n                ${generateSampleGlSrc(getMaxTexturesPerBatch())}\n            `\n      }\n    };\n  }\n  return textureBatchBitGlCache[maxTextures];\n}\n\nexport { generateTextureBatchBit, generateTextureBatchBitGl };\n//# sourceMappingURL=generateTextureBatchBit.mjs.map\n","\"use strict\";\nconst roundPixelsBit = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n            fn roundPixels(position: vec2<f32>, targetSize: vec2<f32>) -> vec2<f32> \n            {\n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\nconst roundPixelsBitGl = {\n  name: \"round-pixels-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `   \n            vec2 roundPixels(vec2 position, vec2 targetSize)\n            {       \n                return (floor(((position * 0.5 + 0.5) * targetSize) + 0.5) / targetSize) * 2.0 - 1.0;\n            }\n        `\n    )\n  }\n};\n\nexport { roundPixelsBit, roundPixelsBitGl };\n//# sourceMappingURL=roundPixelsBit.mjs.map\n","\"use strict\";\nconst localUniformBit = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* wgsl */\n      `\n\n            struct LocalUniforms {\n                uTransformMatrix:mat3x3<f32>,\n                uColor:vec4<f32>,\n                uRound:f32,\n            }\n\n            @group(1) @binding(0) var<uniform> localUniforms : LocalUniforms;\n        `\n    ),\n    main: (\n      /* wgsl */\n      `\n            vColor *= localUniforms.uColor;\n            modelMatrix *= localUniforms.uTransformMatrix;\n        `\n    ),\n    end: (\n      /* wgsl */\n      `\n            if(localUniforms.uRound == 1)\n            {\n                vPosition = vec4(roundPixels(vPosition.xy, globalUniforms.uResolution), vPosition.zw);\n            }\n        `\n    )\n  }\n};\nconst localUniformBitGroup2 = {\n  ...localUniformBit,\n  vertex: {\n    ...localUniformBit.vertex,\n    // replace the group!\n    header: localUniformBit.vertex.header.replace(\"group(1)\", \"group(2)\")\n  }\n};\nconst localUniformBitGl = {\n  name: \"local-uniform-bit\",\n  vertex: {\n    header: (\n      /* glsl */\n      `\n\n            uniform mat3 uTransformMatrix;\n            uniform vec4 uColor;\n            uniform float uRound;\n        `\n    ),\n    main: (\n      /* glsl */\n      `\n            vColor *= uColor;\n            modelMatrix = uTransformMatrix;\n        `\n    ),\n    end: (\n      /* glsl */\n      `\n            if(uRound == 1.)\n            {\n                gl_Position.xy = roundPixels(gl_Position.xy, uResolution);\n            }\n        `\n    )\n  }\n};\n\nexport { localUniformBit, localUniformBitGl, localUniformBitGroup2 };\n//# sourceMappingURL=localUniformBit.mjs.map\n","\"use strict\";\nclass BatchableSprite {\n  constructor() {\n    // batch specific..\n    this.vertexSize = 4;\n    this.indexSize = 6;\n    this.location = 0;\n    // location in the buffer\n    this.batcher = null;\n    this.batch = null;\n    this.roundPixels = 0;\n  }\n  get blendMode() {\n    return this.renderable.groupBlendMode;\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const sprite = this.renderable;\n    const texture = this.texture;\n    const wt = sprite.groupTransform;\n    const a = wt.a;\n    const b = wt.b;\n    const c = wt.c;\n    const d = wt.d;\n    const tx = wt.tx;\n    const ty = wt.ty;\n    const bounds = this.bounds;\n    const w0 = bounds.maxX;\n    const w1 = bounds.minX;\n    const h0 = bounds.maxY;\n    const h1 = bounds.minY;\n    const uvs = texture.uvs;\n    const argb = sprite.groupColorAlpha;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    float32View[index + 0] = a * w1 + c * h1 + tx;\n    float32View[index + 1] = d * h1 + b * w1 + ty;\n    float32View[index + 2] = uvs.x0;\n    float32View[index + 3] = uvs.y0;\n    uint32View[index + 4] = argb;\n    uint32View[index + 5] = textureIdAndRound;\n    float32View[index + 6] = a * w0 + c * h1 + tx;\n    float32View[index + 7] = d * h1 + b * w0 + ty;\n    float32View[index + 8] = uvs.x1;\n    float32View[index + 9] = uvs.y1;\n    uint32View[index + 10] = argb;\n    uint32View[index + 11] = textureIdAndRound;\n    float32View[index + 12] = a * w0 + c * h0 + tx;\n    float32View[index + 13] = d * h0 + b * w0 + ty;\n    float32View[index + 14] = uvs.x2;\n    float32View[index + 15] = uvs.y2;\n    uint32View[index + 16] = argb;\n    uint32View[index + 17] = textureIdAndRound;\n    float32View[index + 18] = a * w1 + c * h0 + tx;\n    float32View[index + 19] = d * h0 + b * w1 + ty;\n    float32View[index + 20] = uvs.x3;\n    float32View[index + 21] = uvs.y3;\n    uint32View[index + 22] = argb;\n    uint32View[index + 23] = textureIdAndRound;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    indexBuffer[index] = indicesOffset + 0;\n    indexBuffer[index + 1] = indicesOffset + 1;\n    indexBuffer[index + 2] = indicesOffset + 2;\n    indexBuffer[index + 3] = indicesOffset + 0;\n    indexBuffer[index + 4] = indicesOffset + 2;\n    indexBuffer[index + 5] = indicesOffset + 3;\n  }\n  reset() {\n    this.renderable = null;\n    this.texture = null;\n    this.batcher = null;\n    this.batch = null;\n    this.bounds = null;\n  }\n}\n\nexport { BatchableSprite };\n//# sourceMappingURL=BatchableSprite.mjs.map\n","\"use strict\";\nfunction colorToUniform(rgb, alpha, out, offset) {\n  out[offset++] = (rgb >> 16 & 255) / 255;\n  out[offset++] = (rgb >> 8 & 255) / 255;\n  out[offset++] = (rgb & 255) / 255;\n  out[offset++] = alpha;\n}\nfunction color32BitToUniform(abgr, out, offset) {\n  const alpha = (abgr >> 24 & 255) / 255;\n  out[offset++] = (abgr & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 8 & 255) / 255 * alpha;\n  out[offset++] = (abgr >> 16 & 255) / 255 * alpha;\n  out[offset++] = alpha;\n}\n\nexport { color32BitToUniform, colorToUniform };\n//# sourceMappingURL=colorToUniform.mjs.map\n"],"names":["idCounts","idHash","createIdFromString","value","groupId","id","context","getTestContext","DOMAdapter","maxFragmentPrecision","getMaxFragmentPrecision","gl","addProgramDefines","src","isES300","isFragment","ensurePrecision","options","maxSupportedPrecision","precision","insertVersion","fragmentNameCache","VertexNameCache","setProgramName","name","nameCache","stripVersion","processes","programCache","_GlProgram","preprocessorOptions","fragment","vertex","processKey","processOptions","key","GlProgram","attributeFormatData","getAttributeInfoFromFormat","format","WGSL_TO_VERTEX_TYPES","extractAttributesFromGpuProgram","source","entryPoint","results","mainVertStart","arrowFunctionStart","functionArgsSubstring","inputsRegex","match","extractStructAndGroups","wgsl","linePattern","groupPattern","bindingPattern","namePattern","typePattern","structPattern","structMemberPattern","structName","groups","_a","item","structs","_b","struct","members","acc","member","name2","type","group","ShaderStage","ShaderStage2","generateGpuLayoutGroups","layout","i","generateLayoutHash","removeStructAndGroupDuplicates","vertexStructsAndGroups","fragmentStructsAndGroups","structNameSet","dupeGroupKeySet","GpuProgram","gpuLayout","structsAndGroups","bigKey","UNIFORM_TYPES_VALUES","UNIFORM_TYPES_MAP","getDefaultUniformValue","size","_UniformGroup","uniformStructures","uid","uniforms","uniformData","UniformGroup","BindGroup","resources","index","resource","keyParts","currentResource","tick","RendererType","RendererType2","Shader","EventEmitter","gpuProgram","glProgram","compatibleRenderers","groupMap","nameHash","j","uniformName","groupData","data","bindTick","groupIndex","bindIndex","uniformsOut","destroyPrograms","bindGroup","gpu","rest","blendModeIds","BLEND","OFFSET","CULLING","DEPTH_TEST","WINDING","DEPTH_MASK","_State","state","State","BufferUsage","BufferUsage2","Buffer","usage","label","shrinkToFit","mappedAtCreation","syncGPU","oldData","sizeInBytes","ensureIsBuffer","buffer","getGeometryBounds","geometry","attributeId","bounds","attribute","minX","minY","maxX","maxY","byteSize","offset","stride","x","y","ensureIsAttribute","Geometry","attributes","indexBuffer","topology","Bounds","destroyBuffers","placeHolderBufferData","placeHolderIndexData","BatchGeometry","attributeBuffer","fragTemplate","generateIfTestSrc","maxIfs","checkMaxIfStatementsInShader","shader","fragmentSrc","maxTexturesPerBatchCache","getMaxTexturesPerBatch","ViewableBuffer","sizeOrBuffer","fastCopy","sourceBuffer","destinationBuffer","lengthDouble","sourceFloat64View","remainingBytes","sourceUint8View","BLEND_TO_NPM","STENCIL_MODES","STENCIL_MODES2","getAdjustedBlendModeBlend","blendMode","textureSource","BatchTextureArray","t","Batch","BATCH_TICK","_Batcher","vertexSize","indexSize","batchableObject","texture","textureId","instructionSet","elements","textureBatch","firstElement","f32","u32","iBuffer","start","action","batch","maxTextures","element","adjustedBlendMode","blendModeChange","indexStart","newSize","newArrayBuffer","newIndexBuffer","Batcher","count","TexturePoolClass","textureOptions","pixelWidth","pixelHeight","antialias","TextureSource","Texture","frameWidth","frameHeight","resolution","po2Width","po2Height","nextPow2","renderTexture","destroyTextures","textures","TexturePool","addBits","srcParts","parts","part","sanitisedPart","warn","findHooksRx","compileHooks","programSrc","hook","extractInputs","fragmentSource","out","regex","compileInputs","fragments","template","sort","mainInput","finalString","inValue","cleanedString","extractOutputs","extractVariableName","stripVariable","compileOutputs","mainStruct","mainStart","mainEnd","compiledCode","injectBits","templateSrc","fragmentParts","cacheMap","bitCacheMap","CACHE_UID","compileHighShader","bits","cacheId","generateCacheId","compileInputsAndOutputs","compileBits","compileHighShaderGl","vertexFragments","shaderBit","v","fragmentFragments","compiledVertex","compiledFragment","highFragment","a","b","vertexParts","vertexGPUTemplate","fragmentGPUTemplate","vertexGlTemplate","fragmentGlTemplate","globalUniformsBit","globalUniformsBitGl","compileHighShaderGpuProgram","compileHighShaderGlProgram","colorBit","colorBitGl","textureBatchBitGpuCache","generateBindingSrc","bindingIndex","generateSampleSrc","generateTextureBatchBit","textureBatchBitGlCache","generateSampleGlSrc","generateTextureBatchBitGl","roundPixelsBit","roundPixelsBitGl","localUniformBit","localUniformBitGroup2","localUniformBitGl","BatchableSprite","float32View","uint32View","sprite","wt","tx","ty","w0","w1","h0","h1","uvs","argb","textureIdAndRound","indicesOffset","color32BitToUniform","abgr","alpha"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53]}