{"version":3,"file":"select.sHPi9eo0.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/elements/misc.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/elements/bindings/shared.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/elements/bindings/select.js"],"sourcesContent":["import { hydrating } from '../hydration.js';\nimport { clear_text_content } from '../operations.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * @param {HTMLElement} dom\n * @param {boolean} value\n * @returns {void}\n */\nexport function autofocus(dom, value) {\n\tif (value) {\n\t\tconst body = document.body;\n\t\tdom.autofocus = true;\n\n\t\tqueue_micro_task(() => {\n\t\t\tif (document.activeElement === body) {\n\t\t\t\tdom.focus();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * The child of a textarea actually corresponds to the defaultValue property, so we need\n * to remove it upon hydration to avoid a bug when someone resets the form value.\n * @param {HTMLTextAreaElement} dom\n * @returns {void}\n */\nexport function remove_textarea_child(dom) {\n\tif (hydrating && dom.firstChild !== null) {\n\t\tclear_text_content(dom);\n\t}\n}\n\nlet listening_to_form_reset = false;\n\nexport function add_form_reset_listener() {\n\tif (!listening_to_form_reset) {\n\t\tlistening_to_form_reset = true;\n\t\tdocument.addEventListener(\n\t\t\t'reset',\n\t\t\t(evt) => {\n\t\t\t\t// Needs to happen one tick later or else the dom properties of the form\n\t\t\t\t// elements have not updated to their reset values yet\n\t\t\t\tPromise.resolve().then(() => {\n\t\t\t\t\tif (!evt.defaultPrevented) {\n\t\t\t\t\t\tfor (const e of /**@type {HTMLFormElement} */ (evt.target).elements) {\n\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\te.__on_r?.();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t},\n\t\t\t// In the capture phase to guarantee we get noticed of it (no possiblity of stopPropagation)\n\t\t\t{ capture: true }\n\t\t);\n\t}\n}\n","import { teardown } from '../../../reactivity/effects.js';\nimport { add_form_reset_listener } from '../misc.js';\n\n/**\n * Fires the handler once immediately (unless corresponding arg is set to `false`),\n * then listens to the given events until the render effect context is destroyed\n * @param {EventTarget} target\n * @param {Array<string>} events\n * @param {(event?: Event) => void} handler\n * @param {any} call_handler_immediately\n */\nexport function listen(target, events, handler, call_handler_immediately = true) {\n\tif (call_handler_immediately) {\n\t\thandler();\n\t}\n\n\tfor (var name of events) {\n\t\ttarget.addEventListener(name, handler);\n\t}\n\n\tteardown(() => {\n\t\tfor (var name of events) {\n\t\t\ttarget.removeEventListener(name, handler);\n\t\t}\n\t});\n}\n\n/**\n * Listen to the given event, and then instantiate a global form reset listener if not already done,\n * to notify all bindings when the form is reset\n * @param {HTMLElement} element\n * @param {string} event\n * @param {() => void} handler\n * @param {() => void} [on_reset]\n */\nexport function listen_to_event_and_reset_event(element, event, handler, on_reset = handler) {\n\telement.addEventListener(event, handler);\n\t// @ts-expect-error\n\tconst prev = element.__on_r;\n\tif (prev) {\n\t\t// special case for checkbox that can have multiple binds (group & checked)\n\t\t// @ts-expect-error\n\t\telement.__on_r = () => {\n\t\t\tprev();\n\t\t\ton_reset();\n\t\t};\n\t} else {\n\t\t// @ts-expect-error\n\t\telement.__on_r = on_reset;\n\t}\n\n\tadd_form_reset_listener();\n}\n","import { effect } from '../../../reactivity/effects.js';\nimport { listen_to_event_and_reset_event } from './shared.js';\nimport { untrack } from '../../../runtime.js';\nimport { is } from '../../../proxy.js';\n\n/**\n * Selects the correct option(s) (depending on whether this is a multiple select)\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n * @param {boolean} [mounting]\n */\nexport function select_option(select, value, mounting) {\n\tif (select.multiple) {\n\t\treturn select_options(select, value);\n\t}\n\n\tfor (var option of select.options) {\n\t\tvar option_value = get_option_value(option);\n\t\tif (is(option_value, value)) {\n\t\t\toption.selected = true;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (!mounting || value !== undefined) {\n\t\tselect.selectedIndex = -1; // no option should be selected\n\t}\n}\n\n/**\n * Selects the correct option(s) if `value` is given,\n * and then sets up a mutation observer to sync the\n * current selection to the dom when it changes. Such\n * changes could for example occur when options are\n * inside an `#each` block.\n * @template V\n * @param {HTMLSelectElement} select\n * @param {() => V} [get_value]\n */\nexport function init_select(select, get_value) {\n\teffect(() => {\n\t\tif (get_value) {\n\t\t\tselect_option(select, untrack(get_value));\n\t\t}\n\n\t\tvar observer = new MutationObserver(() => {\n\t\t\t// @ts-ignore\n\t\t\tvar value = select.__value;\n\t\t\tselect_option(select, value);\n\t\t\t// Deliberately don't update the potential binding value,\n\t\t\t// the model should be preserved unless explicitly changed\n\t\t});\n\n\t\tobserver.observe(select, {\n\t\t\t// Listen to option element changes\n\t\t\tchildList: true,\n\t\t\tsubtree: true, // because of <optgroup>\n\t\t\t// Listen to option element value attribute changes\n\t\t\t// (doesn't get notified of select value changes,\n\t\t\t// because that property is not reflected as an attribute)\n\t\t\tattributes: true,\n\t\t\tattributeFilter: ['value']\n\t\t});\n\n\t\treturn () => {\n\t\t\tobserver.disconnect();\n\t\t};\n\t});\n}\n\n/**\n * @param {HTMLSelectElement} select\n * @param {() => unknown} get_value\n * @param {(value: unknown) => void} update\n * @returns {void}\n */\nexport function bind_select_value(select, get_value, update) {\n\tvar mounting = true;\n\n\tlisten_to_event_and_reset_event(select, 'change', () => {\n\t\t/** @type {unknown} */\n\t\tvar value;\n\n\t\tif (select.multiple) {\n\t\t\tvalue = [].map.call(select.querySelectorAll(':checked'), get_option_value);\n\t\t} else {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option = select.querySelector(':checked');\n\t\t\tvalue = selected_option && get_option_value(selected_option);\n\t\t}\n\n\t\tupdate(value);\n\t});\n\n\t// Needs to be an effect, not a render_effect, so that in case of each loops the logic runs after the each block has updated\n\teffect(() => {\n\t\tvar value = get_value();\n\t\tselect_option(select, value, mounting);\n\n\t\t// Mounting and value undefined -> take selection from dom\n\t\tif (mounting && value === undefined) {\n\t\t\t/** @type {HTMLOptionElement | null} */\n\t\t\tvar selected_option = select.querySelector(':checked');\n\t\t\tif (selected_option !== null) {\n\t\t\t\tvalue = get_option_value(selected_option);\n\t\t\t\tupdate(value);\n\t\t\t}\n\t\t}\n\n\t\t// @ts-ignore\n\t\tselect.__value = value;\n\t\tmounting = false;\n\t});\n\n\t// don't pass get_value, we already initialize it in the effect above\n\tinit_select(select);\n}\n\n/**\n * @template V\n * @param {HTMLSelectElement} select\n * @param {V} value\n */\nfunction select_options(select, value) {\n\tfor (var option of select.options) {\n\t\t// @ts-ignore\n\t\toption.selected = ~value.indexOf(get_option_value(option));\n\t}\n}\n\n/** @param {HTMLOptionElement} option */\nfunction get_option_value(option) {\n\t// __value only exists if the <option> has a value attribute\n\tif ('__value' in option) {\n\t\treturn option.__value;\n\t} else {\n\t\treturn option.value;\n\t}\n}\n"],"names":["listening_to_form_reset","add_form_reset_listener","evt","e","_a","listen_to_event_and_reset_event","element","event","handler","on_reset","prev","select_option","select","value","mounting","select_options","option","option_value","get_option_value","is","init_select","get_value","effect","observer","bind_select_value","update","selected_option"],"mappings":"yDAkCA,IAAIA,EAA0B,GAEvB,SAASC,GAA0B,CACpCD,IACJA,EAA0B,GAC1B,SAAS,iBACR,QACCE,GAAQ,CAGR,QAAQ,UAAU,KAAK,IAAM,OAC5B,GAAI,CAACA,EAAI,iBACR,UAAWC,KAAoCD,EAAI,OAAQ,UAE1DE,EAAAD,EAAE,SAAF,MAAAC,EAAA,KAAAD,EAGP,CAAK,CACD,EAED,CAAE,QAAS,EAAM,CACpB,EAEA,CCtBO,SAASE,EAAgCC,EAASC,EAAOC,EAASC,EAAWD,EAAS,CAC5FF,EAAQ,iBAAiBC,EAAOC,CAAO,EAEvC,MAAME,EAAOJ,EAAQ,OACjBI,EAGHJ,EAAQ,OAAS,IAAM,CACtBI,IACAD,GACH,EAGEH,EAAQ,OAASG,EAGlBR,GACD,CCxCO,SAASU,EAAcC,EAAQC,EAAOC,EAAU,CACtD,GAAIF,EAAO,SACV,OAAOG,EAAeH,EAAQC,CAAK,EAGpC,QAASG,KAAUJ,EAAO,QAAS,CAClC,IAAIK,EAAeC,EAAiBF,CAAM,EAC1C,GAAIG,EAAGF,EAAcJ,CAAK,EAAG,CAC5BG,EAAO,SAAW,GAClB,MACA,CACD,EAEG,CAACF,GAAYD,IAAU,UAC1BD,EAAO,cAAgB,GAEzB,CAYO,SAASQ,EAAYR,EAAQS,EAAW,CAC9CC,EAAO,IAAM,CAKZ,IAAIC,EAAW,IAAI,iBAAiB,IAAM,CAEzC,IAAIV,EAAQD,EAAO,QACnBD,EAAcC,EAAQC,CAAK,CAG9B,CAAG,EAED,OAAAU,EAAS,QAAQX,EAAQ,CAExB,UAAW,GACX,QAAS,GAIT,WAAY,GACZ,gBAAiB,CAAC,OAAO,CAC5B,CAAG,EAEM,IAAM,CACZW,EAAS,WAAU,CACtB,CACA,CAAE,CACF,CAQO,SAASC,EAAkBZ,EAAQS,EAAWI,EAAQ,CAC5D,IAAIX,EAAW,GAEfT,EAAgCO,EAAQ,SAAU,IAAM,CAEvD,IAAIC,EAEJ,GAAID,EAAO,SACVC,EAAQ,CAAA,EAAG,IAAI,KAAKD,EAAO,iBAAiB,UAAU,EAAGM,CAAgB,MACnE,CAEN,IAAIQ,EAAkBd,EAAO,cAAc,UAAU,EACrDC,EAAQa,GAAmBR,EAAiBQ,CAAe,CAC3D,CAEDD,EAAOZ,CAAK,CACd,CAAE,EAGDS,EAAO,IAAM,CACZ,IAAIT,EAAQQ,IAIZ,GAHAV,EAAcC,EAAQC,EAAOC,CAAQ,EAGjCA,GAAYD,IAAU,OAAW,CAEpC,IAAIa,EAAkBd,EAAO,cAAc,UAAU,EACjDc,IAAoB,OACvBb,EAAQK,EAAiBQ,CAAe,EACxCD,EAAOZ,CAAK,EAEb,CAGDD,EAAO,QAAUC,EACjBC,EAAW,EACb,CAAE,EAGDM,EAAYR,CAAM,CACnB,CAOA,SAASG,EAAeH,EAAQC,EAAO,CACtC,QAASG,KAAUJ,EAAO,QAEzBI,EAAO,SAAW,CAACH,EAAM,QAAQK,EAAiBF,CAAM,CAAC,CAE3D,CAGA,SAASE,EAAiBF,EAAQ,CAEjC,MAAI,YAAaA,EACTA,EAAO,QAEPA,EAAO,KAEhB","x_google_ignoreList":[0,1,2]}