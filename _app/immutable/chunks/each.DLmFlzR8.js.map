{"version":3,"file":"each.DLmFlzR8.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/blocks/each.js"],"sourcesContent":["import {\n\tEACH_INDEX_REACTIVE,\n\tEACH_IS_ANIMATED,\n\tEACH_IS_CONTROLLED,\n\tEACH_IS_STRICT_EQUALS,\n\tEACH_ITEM_REACTIVE,\n\tEACH_KEYED,\n\tHYDRATION_END_ELSE,\n\tHYDRATION_START\n} from '../../../../constants.js';\nimport {\n\thydrate_anchor,\n\thydrate_nodes,\n\thydrate_start,\n\thydrating,\n\tset_hydrating\n} from '../hydration.js';\nimport { clear_text_content, empty } from '../operations.js';\nimport { remove } from '../reconciler.js';\nimport {\n\tblock,\n\tbranch,\n\tdestroy_effect,\n\trun_out_transitions,\n\tpause_children,\n\tpause_effect,\n\tresume_effect\n} from '../../reactivity/effects.js';\nimport { source, mutable_source, set } from '../../reactivity/sources.js';\nimport { is_array, is_frozen } from '../../utils.js';\nimport { INERT, STATE_SYMBOL } from '../../constants.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * The row of a keyed each block that is currently updating. We track this\n * so that `animate:` directives have something to attach themselves to\n * @type {import('#client').EachItem | null}\n */\nexport let current_each_item = null;\n\n/** @param {import('#client').EachItem | null} item */\nexport function set_current_each_item(item) {\n\tcurrent_each_item = item;\n}\n\n/**\n * @param {any} _\n * @param {number} i\n */\nexport function index(_, i) {\n\treturn i;\n}\n\n/**\n * Pause multiple effects simultaneously, and coordinate their\n * subsequent destruction. Used in each blocks\n * @param {import('#client').EachItem[]} items\n * @param {null | Node} controlled_anchor\n * @param {Map<any, import(\"#client\").EachItem>} items_map\n */\nfunction pause_effects(items, controlled_anchor, items_map) {\n\t/** @type {import('#client').TransitionManager[]} */\n\tvar transitions = [];\n\tvar length = items.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tpause_children(items[i].e, transitions, true);\n\t}\n\n\tvar is_controlled = length > 0 && transitions.length === 0 && controlled_anchor !== null;\n\t// If we have a controlled anchor, it means that the each block is inside a single\n\t// DOM element, so we can apply a fast-path for clearing the contents of the element.\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (\n\t\t\t/** @type {Element} */ (controlled_anchor).parentNode\n\t\t);\n\t\tclear_text_content(parent_node);\n\t\tparent_node.append(/** @type {Element} */ (controlled_anchor));\n\t\titems_map.clear();\n\t\tlink(items[0].prev, items[length - 1].next);\n\t}\n\n\trun_out_transitions(transitions, () => {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar item = items[i];\n\t\t\tif (!is_controlled) {\n\t\t\t\titems_map.delete(item.k);\n\t\t\t\tlink(item.prev, item.next);\n\t\t\t}\n\t\t\tdestroy_effect(item.e, !is_controlled);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Element | Comment} anchor The next sibling node, or the parent node if this is a 'controlled' block\n * @param {number} flags\n * @param {() => V[]} get_collection\n * @param {(value: V, index: number) => any} get_key\n * @param {(anchor: Node, item: import('#client').MaybeSource<V>, index: import('#client').MaybeSource<number>) => void} render_fn\n * @param {null | ((anchor: Node) => void)} fallback_fn\n * @returns {void}\n */\nexport function each(anchor, flags, get_collection, get_key, render_fn, fallback_fn = null) {\n\t/** @type {import('#client').EachState} */\n\tvar state = { flags, items: new Map(), next: null };\n\n\tvar is_controlled = (flags & EACH_IS_CONTROLLED) !== 0;\n\n\tif (is_controlled) {\n\t\tvar parent_node = /** @type {Element} */ (anchor);\n\n\t\tanchor = hydrating\n\t\t\t? /** @type {Comment | Text} */ (\n\t\t\t\t\thydrate_anchor(/** @type {Comment | Text} */ (parent_node.firstChild))\n\t\t\t\t)\n\t\t\t: parent_node.appendChild(empty());\n\t}\n\n\t/** @type {import('#client').Effect | null} */\n\tvar fallback = null;\n\n\tblock(() => {\n\t\tvar collection = get_collection();\n\n\t\tvar array = is_array(collection)\n\t\t\t? collection\n\t\t\t: collection == null\n\t\t\t\t? []\n\t\t\t\t: Array.from(collection);\n\n\t\tvar length = array.length;\n\n\t\t// If we are working with an array that isn't proxied or frozen, then remove strict equality and ensure the items\n\t\t// are treated as reactive, so they get wrapped in a signal.\n\t\tvar flags = state.flags;\n\t\tif ((flags & EACH_IS_STRICT_EQUALS) !== 0 && !is_frozen(array) && !(STATE_SYMBOL in array)) {\n\t\t\tflags ^= EACH_IS_STRICT_EQUALS;\n\n\t\t\t// Additionally if we're in an keyed each block, we'll need ensure the items are all wrapped in signals.\n\t\t\tif ((flags & EACH_KEYED) !== 0 && (flags & EACH_ITEM_REACTIVE) === 0) {\n\t\t\t\tflags ^= EACH_ITEM_REACTIVE;\n\t\t\t}\n\t\t}\n\n\t\t/** `true` if there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tvar is_else = /** @type {Comment} */ (anchor).data === HYDRATION_END_ELSE;\n\n\t\t\tif (is_else !== (length === 0) || hydrate_start === undefined) {\n\t\t\t\t// hydration mismatch â€” remove the server-rendered DOM and start over\n\t\t\t\tremove(hydrate_nodes);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\t// this is separate to the previous block because `hydrating` might change\n\t\tif (hydrating) {\n\t\t\t/** @type {Node} */\n\t\t\tvar child_anchor = hydrate_start;\n\n\t\t\t/** @type {import('#client').EachItem | import('#client').EachState} */\n\t\t\tvar prev = state;\n\n\t\t\t/** @type {import('#client').EachItem} */\n\t\t\tvar item;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tif (\n\t\t\t\t\tchild_anchor.nodeType !== 8 ||\n\t\t\t\t\t/** @type {Comment} */ (child_anchor).data !== HYDRATION_START\n\t\t\t\t) {\n\t\t\t\t\t// If `nodes` is null, then that means that the server rendered fewer items than what\n\t\t\t\t\t// expected, so break out and continue appending non-hydrated items\n\t\t\t\t\tmismatch = true;\n\t\t\t\t\tset_hydrating(false);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tchild_anchor = hydrate_anchor(child_anchor);\n\t\t\t\tvar value = array[i];\n\t\t\t\tvar key = get_key(value, i);\n\t\t\t\titem = create_item(child_anchor, prev, null, value, key, i, render_fn, flags);\n\t\t\t\tstate.items.set(key, item);\n\t\t\t\tchild_anchor = /** @type {Comment} */ (child_anchor.nextSibling);\n\n\t\t\t\tprev = item;\n\t\t\t}\n\n\t\t\t// remove excess nodes\n\t\t\tif (length > 0) {\n\t\t\t\twhile (child_anchor !== anchor) {\n\t\t\t\t\tvar next = /** @type {import('#client').TemplateNode} */ (child_anchor.nextSibling);\n\t\t\t\t\t/** @type {import('#client').TemplateNode} */ (child_anchor).remove();\n\t\t\t\t\tchild_anchor = next;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!hydrating) {\n\t\t\treconcile(array, state, anchor, render_fn, flags, get_key);\n\t\t}\n\n\t\tif (fallback_fn !== null) {\n\t\t\tif (length === 0) {\n\t\t\t\tif (fallback) {\n\t\t\t\t\tresume_effect(fallback);\n\t\t\t\t} else {\n\t\t\t\t\tfallback = branch(() => fallback_fn(anchor));\n\t\t\t\t}\n\t\t\t} else if (fallback !== null) {\n\t\t\t\tpause_effect(fallback, () => {\n\t\t\t\t\tfallback = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t});\n}\n\n/**\n * @template V\n * @param {Array<V>} array\n * @param {import('#client').EachState} state\n * @param {Element | Comment | Text} anchor\n * @param {(anchor: Node, item: import('#client').MaybeSource<V>, index: number | import('#client').Source<number>) => void} render_fn\n * @param {number} flags\n * @param {(value: V, index: number) => any} get_key\n * @returns {void}\n */\nfunction reconcile(array, state, anchor, render_fn, flags, get_key) {\n\tvar is_animated = (flags & EACH_IS_ANIMATED) !== 0;\n\tvar should_update = (flags & (EACH_ITEM_REACTIVE | EACH_INDEX_REACTIVE)) !== 0;\n\n\tvar length = array.length;\n\tvar items = state.items;\n\tvar first = state.next;\n\tvar current = first;\n\n\t/** @type {Set<import('#client').EachItem>} */\n\tvar seen = new Set();\n\n\t/** @type {import('#client').EachState | import('#client').EachItem} */\n\tvar prev = state;\n\n\t/** @type {Set<import('#client').EachItem>} */\n\tvar to_animate = new Set();\n\n\t/** @type {import('#client').EachItem[]} */\n\tvar matched = [];\n\n\t/** @type {import('#client').EachItem[]} */\n\tvar stashed = [];\n\n\t/** @type {V} */\n\tvar value;\n\n\t/** @type {any} */\n\tvar key;\n\n\t/** @type {import('#client').EachItem | undefined} */\n\tvar item;\n\n\t/** @type {number} */\n\tvar i;\n\n\tif (is_animated) {\n\t\tfor (i = 0; i < length; i += 1) {\n\t\t\tvalue = array[i];\n\t\t\tkey = get_key(value, i);\n\t\t\titem = items.get(key);\n\n\t\t\tif (item !== undefined) {\n\t\t\t\titem.a?.measure();\n\t\t\t\tto_animate.add(item);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (i = 0; i < length; i += 1) {\n\t\tvalue = array[i];\n\t\tkey = get_key(value, i);\n\t\titem = items.get(key);\n\n\t\tif (item === undefined) {\n\t\t\tvar child_anchor = current ? get_first_node(current.e) : anchor;\n\n\t\t\tprev = create_item(child_anchor, prev, prev.next, value, key, i, render_fn, flags);\n\n\t\t\titems.set(key, prev);\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\tcurrent = prev.next;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (should_update) {\n\t\t\tupdate_item(item, value, i, flags);\n\t\t}\n\n\t\tif ((item.e.f & INERT) !== 0) {\n\t\t\tresume_effect(item.e);\n\t\t\tif (is_animated) {\n\t\t\t\titem.a?.unfix();\n\t\t\t\tto_animate.delete(item);\n\t\t\t}\n\t\t}\n\n\t\tif (item !== current) {\n\t\t\tif (seen.has(item)) {\n\t\t\t\tif (matched.length < stashed.length) {\n\t\t\t\t\t// more efficient to move later items to the front\n\t\t\t\t\tvar start = stashed[0];\n\t\t\t\t\tvar j;\n\n\t\t\t\t\tprev = start.prev;\n\n\t\t\t\t\tvar a = matched[0];\n\t\t\t\t\tvar b = matched[matched.length - 1];\n\n\t\t\t\t\tfor (j = 0; j < matched.length; j += 1) {\n\t\t\t\t\t\tmove(matched[j], start, anchor);\n\t\t\t\t\t}\n\n\t\t\t\t\tfor (j = 0; j < stashed.length; j += 1) {\n\t\t\t\t\t\tseen.delete(stashed[j]);\n\t\t\t\t\t}\n\n\t\t\t\t\tlink(a.prev, b.next);\n\t\t\t\t\tlink(prev, a);\n\t\t\t\t\tlink(b, start);\n\n\t\t\t\t\tcurrent = start;\n\t\t\t\t\tprev = b;\n\t\t\t\t\ti -= 1;\n\n\t\t\t\t\tmatched = [];\n\t\t\t\t\tstashed = [];\n\t\t\t\t} else {\n\t\t\t\t\t// more efficient to move earlier items to the back\n\t\t\t\t\tseen.delete(item);\n\t\t\t\t\tmove(item, current, anchor);\n\n\t\t\t\t\tlink(item.prev, item.next);\n\t\t\t\t\tlink(item, prev.next);\n\t\t\t\t\tlink(prev, item);\n\n\t\t\t\t\tprev = item;\n\t\t\t\t}\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tmatched = [];\n\t\t\tstashed = [];\n\n\t\t\twhile (current !== null && current.k !== key) {\n\t\t\t\tseen.add(current);\n\t\t\t\tstashed.push(current);\n\t\t\t\tcurrent = current.next;\n\t\t\t}\n\n\t\t\tif (current === null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\titem = current;\n\t\t}\n\n\t\tmatched.push(item);\n\t\tprev = item;\n\t\tcurrent = item.next;\n\t}\n\n\tconst to_destroy = Array.from(seen);\n\n\twhile (current !== null) {\n\t\tto_destroy.push(current);\n\t\tcurrent = current.next;\n\t}\n\tvar destroy_length = to_destroy.length;\n\n\tif (destroy_length > 0) {\n\t\tvar controlled_anchor = (flags & EACH_IS_CONTROLLED) !== 0 && length === 0 ? anchor : null;\n\n\t\tif (is_animated) {\n\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\tto_destroy[i].a?.measure();\n\t\t\t}\n\n\t\t\tfor (i = 0; i < destroy_length; i += 1) {\n\t\t\t\tto_destroy[i].a?.fix();\n\t\t\t}\n\t\t}\n\n\t\tpause_effects(to_destroy, controlled_anchor, items);\n\t}\n\n\tif (is_animated) {\n\t\tqueue_micro_task(() => {\n\t\t\tfor (item of to_animate) {\n\t\t\t\titem.a?.apply();\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {import('#client').EachItem} item\n * @param {any} value\n * @param {number} index\n * @param {number} type\n * @returns {void}\n */\nfunction update_item(item, value, index, type) {\n\tif ((type & EACH_ITEM_REACTIVE) !== 0) {\n\t\tset(item.v, value);\n\t}\n\n\tif ((type & EACH_INDEX_REACTIVE) !== 0) {\n\t\tset(/** @type {import('#client').Value<number>} */ (item.i), index);\n\t} else {\n\t\titem.i = index;\n\t}\n}\n\n/**\n * @template V\n * @param {Node} anchor\n * @param {import('#client').EachItem | import('#client').EachState} prev\n * @param {import('#client').EachItem | null} next\n * @param {V} value\n * @param {unknown} key\n * @param {number} index\n * @param {(anchor: Node, item: V | import('#client').Source<V>, index: number | import('#client').Value<number>) => void} render_fn\n * @param {number} flags\n * @returns {import('#client').EachItem}\n */\nfunction create_item(anchor, prev, next, value, key, index, render_fn, flags) {\n\tvar previous_each_item = current_each_item;\n\n\ttry {\n\t\tvar reactive = (flags & EACH_ITEM_REACTIVE) !== 0;\n\t\tvar mutable = (flags & EACH_IS_STRICT_EQUALS) === 0;\n\n\t\tvar v = reactive ? (mutable ? mutable_source(value) : source(value)) : value;\n\t\tvar i = (flags & EACH_INDEX_REACTIVE) === 0 ? index : source(index);\n\n\t\t/** @type {import('#client').EachItem} */\n\t\tvar item = {\n\t\t\ti,\n\t\t\tv,\n\t\t\tk: key,\n\t\t\ta: null,\n\t\t\t// @ts-expect-error\n\t\t\te: null,\n\t\t\tprev,\n\t\t\tnext\n\t\t};\n\n\t\tprev.next = item;\n\t\tif (next !== null) next.prev = item;\n\n\t\tcurrent_each_item = item;\n\t\titem.e = branch(() => render_fn(anchor, v, i));\n\n\t\treturn item;\n\t} finally {\n\t\tcurrent_each_item = previous_each_item;\n\t}\n}\n\n/**\n * @param {import('#client').TemplateNode} dom\n * @param {import(\"#client\").Effect} effect\n * @returns {import('#client').TemplateNode}\n */\nfunction get_adjusted_first_node(dom, effect) {\n\tif ((dom.nodeType === 3 && /** @type {Text} */ (dom).data === '') || dom.nodeType === 8) {\n\t\tvar adjusted = effect.first;\n\t\tvar next;\n\t\twhile (adjusted !== null) {\n\t\t\tnext = adjusted.first;\n\t\t\tif (adjusted.dom !== null) {\n\t\t\t\tbreak;\n\t\t\t} else if (next === null) {\n\t\t\t\treturn /** @type {import('#client').TemplateNode} */ (dom.previousSibling);\n\t\t\t}\n\t\t\tadjusted = next;\n\t\t}\n\t\treturn get_first_node(/** @type {import(\"#client\").Effect} */ (adjusted));\n\t}\n\treturn dom;\n}\n\n/**\n *\n * @param {import('#client').Effect} effect\n * @returns {import('#client').TemplateNode}\n */\nfunction get_first_node(effect) {\n\tvar dom = effect.dom;\n\tif (is_array(dom)) {\n\t\treturn get_adjusted_first_node(dom[0], effect);\n\t}\n\treturn get_adjusted_first_node(/** @type {import('#client').TemplateNode} **/ (dom), effect);\n}\n\n/**\n * @param {import('#client').EachItem} item\n * @param {import('#client').EachItem | null} next\n * @param {Text | Element | Comment} anchor\n */\nfunction move(item, next, anchor) {\n\tvar end = item.next ? get_first_node(item.next.e) : anchor;\n\tvar dest = next ? get_first_node(next.e) : anchor;\n\n\tvar node = get_first_node(item.e);\n\n\twhile (node !== end) {\n\t\tvar next_node = /** @type {import('#client').TemplateNode} */ (node.nextSibling);\n\t\tdest.before(node);\n\t\tnode = next_node;\n\t}\n}\n\n/**\n *\n * @param {import('#client').EachItem | import('#client').EachState} prev\n * @param {import('#client').EachItem | null} next\n */\nfunction link(prev, next) {\n\tprev.next = next;\n\tif (next !== null) next.prev = prev;\n}\n"],"names":["current_each_item","index","_","i","pause_effects","items","controlled_anchor","items_map","transitions","length","pause_children","is_controlled","parent_node","clear_text_content","link","run_out_transitions","item","destroy_effect","each","anchor","flags","get_collection","get_key","render_fn","fallback_fn","state","EACH_IS_CONTROLLED","hydrating","hydrate_anchor","empty","fallback","block","collection","array","is_array","EACH_IS_STRICT_EQUALS","is_frozen","STATE_SYMBOL","EACH_KEYED","EACH_ITEM_REACTIVE","mismatch","is_else","HYDRATION_END_ELSE","hydrate_start","remove","hydrate_nodes","set_hydrating","child_anchor","prev","HYDRATION_START","value","key","create_item","next","reconcile","resume_effect","branch","pause_effect","is_animated","EACH_IS_ANIMATED","should_update","EACH_INDEX_REACTIVE","first","current","seen","to_animate","matched","stashed","_a","get_first_node","update_item","INERT","_b","start","j","a","b","move","to_destroy","destroy_length","_c","_d","queue_micro_task","type","set","previous_each_item","reactive","mutable","v","mutable_source","source","get_adjusted_first_node","dom","effect","adjusted","end","dest","node","next_node"],"mappings":"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","x_google_ignoreList":[0]}