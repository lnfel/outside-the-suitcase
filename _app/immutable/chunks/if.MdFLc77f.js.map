{"version":3,"file":"if.MdFLc77f.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/blocks/if.js"],"sourcesContent":["import { EFFECT_TRANSPARENT } from '../../constants.js';\nimport { hydrate_nodes, hydrating, set_hydrating } from '../hydration.js';\nimport { remove } from '../reconciler.js';\nimport { block, branch, pause_effect, resume_effect } from '../../reactivity/effects.js';\nimport { HYDRATION_END_ELSE } from '../../../../constants.js';\n\n/**\n * @param {Comment} anchor\n * @param {() => boolean} get_condition\n * @param {(anchor: Node) => import('#client').Dom} consequent_fn\n * @param {null | ((anchor: Node) => import('#client').Dom)} [alternate_fn]\n * @param {boolean} [elseif] True if this is an `{:else if ...}` block rather than an `{#if ...}`, as that affects which transitions are considered 'local'\n * @returns {void}\n */\nexport function if_block(\n\tanchor,\n\tget_condition,\n\tconsequent_fn,\n\talternate_fn = null,\n\telseif = false\n) {\n\t/** @type {import('#client').Effect | null} */\n\tvar consequent_effect = null;\n\n\t/** @type {import('#client').Effect | null} */\n\tvar alternate_effect = null;\n\n\t/** @type {boolean | null} */\n\tvar condition = null;\n\n\tvar flags = elseif ? EFFECT_TRANSPARENT : 0;\n\n\tblock(() => {\n\t\tif (condition === (condition = !!get_condition())) return;\n\n\t\t/** Whether or not there was a hydration mismatch. Needs to be a `let` or else it isn't treeshaken out */\n\t\tlet mismatch = false;\n\n\t\tif (hydrating) {\n\t\t\tconst is_else = anchor.data === HYDRATION_END_ELSE;\n\n\t\t\tif (condition === is_else) {\n\t\t\t\t// Hydration mismatch: remove everything inside the anchor and start fresh.\n\t\t\t\t// This could happen with `{#if browser}...{/if}`, for example\n\t\t\t\tremove(hydrate_nodes);\n\t\t\t\tset_hydrating(false);\n\t\t\t\tmismatch = true;\n\t\t\t}\n\t\t}\n\n\t\tif (condition) {\n\t\t\tif (consequent_effect) {\n\t\t\t\tresume_effect(consequent_effect);\n\t\t\t} else {\n\t\t\t\tconsequent_effect = branch(() => consequent_fn(anchor));\n\t\t\t}\n\n\t\t\tif (alternate_effect) {\n\t\t\t\tpause_effect(alternate_effect, () => {\n\t\t\t\t\talternate_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\tif (alternate_effect) {\n\t\t\t\tresume_effect(alternate_effect);\n\t\t\t} else if (alternate_fn) {\n\t\t\t\talternate_effect = branch(() => alternate_fn(anchor));\n\t\t\t}\n\n\t\t\tif (consequent_effect) {\n\t\t\t\tpause_effect(consequent_effect, () => {\n\t\t\t\t\tconsequent_effect = null;\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tif (mismatch) {\n\t\t\t// continue in hydration mode\n\t\t\tset_hydrating(true);\n\t\t}\n\t}, flags);\n}\n"],"names":["if_block","anchor","get_condition","consequent_fn","alternate_fn","elseif","consequent_effect","alternate_effect","condition","flags","EFFECT_TRANSPARENT","block","mismatch","hydrating","is_else","HYDRATION_END_ELSE","remove","hydrate_nodes","set_hydrating","resume_effect","branch","pause_effect"],"mappings":"6IAcO,SAASA,EACfC,EACAC,EACAC,EACAC,EAAe,KACfC,EAAS,GACR,CAED,IAAIC,EAAoB,KAGpBC,EAAmB,KAGnBC,EAAY,KAEZC,EAAQJ,EAASK,EAAqB,EAE1CC,EAAM,IAAM,CACX,GAAIH,KAAeA,EAAY,CAAC,CAACN,EAAa,GAAK,OAGnD,IAAIU,EAAW,GAEf,GAAIC,EAAW,CACd,MAAMC,EAAUb,EAAO,OAASc,EAE5BP,IAAcM,IAGjBE,EAAOC,CAAa,EACpBC,EAAc,EAAK,EACnBN,EAAW,GAEZ,CAEGJ,GACCF,EACHa,EAAcb,CAAiB,EAE/BA,EAAoBc,EAAO,IAAMjB,EAAcF,CAAM,CAAC,EAGnDM,GACHc,EAAad,EAAkB,IAAM,CACpCA,EAAmB,IACxB,CAAK,IAGEA,EACHY,EAAcZ,CAAgB,EACpBH,IACVG,EAAmBa,EAAO,IAAMhB,EAAaH,CAAM,CAAC,GAGjDK,GACHe,EAAaf,EAAmB,IAAM,CACrCA,EAAoB,IACzB,CAAK,GAICM,GAEHM,EAAc,EAAI,CAEnB,EAAET,CAAK,CACT","x_google_ignoreList":[0]}