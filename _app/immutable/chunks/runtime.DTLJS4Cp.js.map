{"version":3,"file":"runtime.DTLJS4Cp.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/utils.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/constants.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/reactivity/equality.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/constants.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/errors.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/reactivity/sources.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/reconciler.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/reactivity/effects.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/shared/utils.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/task.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/reactivity/deriveds.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/runtime.js"],"sourcesContent":["// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var object_assign = Object.assign;\nexport var is_frozen = Object.isFrozen;\nexport var object_freeze = Object.freeze;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\n\n/** @type {Map<any, any>} */\nvar map_prototype = Map.prototype;\nvar map_set_method = map_prototype.set;\nvar map_get_method = map_prototype.get;\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V>} map\n * @param {K} key\n * @param {V} value\n */\nexport function map_set(map, key, value) {\n\tmap_set_method.call(map, key, value);\n}\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V>} map\n * @param {K} key\n * @return {V}\n */\nexport function map_get(map, key) {\n\treturn map_get_method.call(map, key);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n","export const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const RENDER_EFFECT = 1 << 3;\nexport const BLOCK_EFFECT = 1 << 4;\nexport const BRANCH_EFFECT = 1 << 5;\nexport const ROOT_EFFECT = 1 << 6;\nexport const UNOWNED = 1 << 7;\nexport const DISCONNECTED = 1 << 8;\nexport const CLEAN = 1 << 9;\nexport const DIRTY = 1 << 10;\nexport const MAYBE_DIRTY = 1 << 11;\nexport const INERT = 1 << 12;\nexport const DESTROYED = 1 << 13;\nexport const EFFECT_RAN = 1 << 14;\n/** 'Transparent' effects do not create a transition boundary */\nexport const EFFECT_TRANSPARENT = 1 << 15;\n/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */\nexport const LEGACY_DERIVED_PROP = 1 << 16;\nexport const INSPECT_EFFECT = 1 << 17;\n\nexport const STATE_SYMBOL = Symbol('$state');\nexport const STATE_FROZEN_SYMBOL = Symbol('$state.frozen');\nexport const LOADING_ATTR_SYMBOL = Symbol('');\n","/** @type {import('#client').Equals} */\nexport function equals(value) {\n\treturn value === this.v;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\treturn a != a\n\t\t? b == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/** @type {import('#client').Equals} */\nexport function safe_equals(value) {\n\treturn !safe_not_equal(value, this.v);\n}\n","export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\nexport const EACH_KEYED = 1 << 2;\n\n/** See EachBlock interface metadata.is_controlled for an explanation what this is */\nexport const EACH_IS_CONTROLLED = 1 << 3;\nexport const EACH_IS_ANIMATED = 1 << 4;\nexport const EACH_IS_STRICT_EQUALS = 1 << 6;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 3;\n\nexport const TRANSITION_IN = 1;\nexport const TRANSITION_OUT = 1 << 1;\nexport const TRANSITION_GLOBAL = 1 << 2;\n\nexport const TEMPLATE_FRAGMENT = 1;\nexport const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\n\nexport const HYDRATION_START = '[';\nexport const HYDRATION_END = ']';\nexport const HYDRATION_ANCHOR = '';\nexport const HYDRATION_END_ELSE = `${HYDRATION_END}!`; // used to indicate that an `{:else}...` block was rendered\nexport const HYDRATION_ERROR = {};\n\nexport const ELEMENT_IS_NAMESPACED = 1;\nexport const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;\n\nexport const UNINITIALIZED = Symbol();\n\n/** List of elements that require raw contents and should not have SSR comments put in them */\nexport const RawTextElements = ['textarea', 'script', 'style', 'title'];\n\n/** List of Element events that will be delegated */\nexport const DelegatedEvents = [\n\t'beforeinput',\n\t'click',\n\t'change',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t'input',\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/** List of Element events that will be delegated and are passive */\nexport const PassiveDelegatedEvents = ['touchstart', 'touchmove', 'touchend'];\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nexport const AttributeAliases = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly'\n};\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nexport const DOMBooleanAttributes = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'indeterminate',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected',\n\t'webkitdirectory'\n];\n\nexport const namespace_svg = 'http://www.w3.org/2000/svg';\nexport const namespace_mathml = 'http://www.w3.org/1998/Math/MathML';\n\n// while `input` is also an interactive element, it is never moved by the browser, so we don't need to check for it\nexport const interactive_elements = new Set([\n\t'a',\n\t'button',\n\t'iframe',\n\t'embed',\n\t'select',\n\t'textarea'\n]);\n\nexport const disallowed_paragraph_contents = [\n\t'address',\n\t'article',\n\t'aside',\n\t'blockquote',\n\t'details',\n\t'div',\n\t'dl',\n\t'fieldset',\n\t'figcapture',\n\t'figure',\n\t'footer',\n\t'form',\n\t'h1',\n\t'h2',\n\t'h3',\n\t'h4',\n\t'h5',\n\t'h6',\n\t'header',\n\t'hr',\n\t'menu',\n\t'nav',\n\t'ol',\n\t'pre',\n\t'section',\n\t'table',\n\t'ul',\n\t'p'\n];\n\n// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nconst implied_end_tags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n/**\n * @param {string} tag\n * @param {string} parent_tag\n * @returns {boolean}\n */\nexport function is_tag_valid_with_parent(tag, parent_tag) {\n\t// First, let's check if we're in an unusual parsing mode...\n\tswitch (parent_tag) {\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n\t\tcase 'select':\n\t\t\treturn (\n\t\t\t\ttag === 'option' ||\n\t\t\t\ttag === 'optgroup' ||\n\t\t\t\ttag === '#text' ||\n\t\t\t\ttag === 'hr' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\tcase 'optgroup':\n\t\t\treturn tag === 'option' || tag === '#text';\n\t\t// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n\t\t// but\n\t\tcase 'option':\n\t\t\treturn tag === '#text';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n\t\t// No special behavior since these rules fall back to \"in body\" mode for\n\t\t// all except special table nodes which cause bad parsing behavior anyway.\n\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n\t\tcase 'tr':\n\t\t\treturn (\n\t\t\t\ttag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n\t\tcase 'tbody':\n\t\tcase 'thead':\n\t\tcase 'tfoot':\n\t\t\treturn tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n\t\tcase 'colgroup':\n\t\t\treturn tag === 'col' || tag === 'template';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n\t\tcase 'table':\n\t\t\treturn (\n\t\t\t\ttag === 'caption' ||\n\t\t\t\ttag === 'colgroup' ||\n\t\t\t\ttag === 'tbody' ||\n\t\t\t\ttag === 'tfoot' ||\n\t\t\t\ttag === 'thead' ||\n\t\t\t\ttag === 'style' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n\t\tcase 'head':\n\t\t\treturn (\n\t\t\t\ttag === 'base' ||\n\t\t\t\ttag === 'basefont' ||\n\t\t\t\ttag === 'bgsound' ||\n\t\t\t\ttag === 'link' ||\n\t\t\t\ttag === 'meta' ||\n\t\t\t\ttag === 'title' ||\n\t\t\t\ttag === 'noscript' ||\n\t\t\t\ttag === 'noframes' ||\n\t\t\t\ttag === 'style' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n\t\tcase 'html':\n\t\t\treturn tag === 'head' || tag === 'body' || tag === 'frameset';\n\t\tcase 'frameset':\n\t\t\treturn tag === 'frame';\n\t\tcase '#document':\n\t\t\treturn tag === 'html';\n\t}\n\n\t// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n\t// where the parsing rules cause implicit opens or closes to be added.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n\tswitch (tag) {\n\t\tcase 'h1':\n\t\tcase 'h2':\n\t\tcase 'h3':\n\t\tcase 'h4':\n\t\tcase 'h5':\n\t\tcase 'h6':\n\t\t\treturn (\n\t\t\t\tparent_tag !== 'h1' &&\n\t\t\t\tparent_tag !== 'h2' &&\n\t\t\t\tparent_tag !== 'h3' &&\n\t\t\t\tparent_tag !== 'h4' &&\n\t\t\t\tparent_tag !== 'h5' &&\n\t\t\t\tparent_tag !== 'h6'\n\t\t\t);\n\n\t\tcase 'rp':\n\t\tcase 'rt':\n\t\t\treturn implied_end_tags.indexOf(parent_tag) === -1;\n\n\t\tcase 'body':\n\t\tcase 'caption':\n\t\tcase 'col':\n\t\tcase 'colgroup':\n\t\tcase 'frameset':\n\t\tcase 'frame':\n\t\tcase 'head':\n\t\tcase 'html':\n\t\tcase 'tbody':\n\t\tcase 'td':\n\t\tcase 'tfoot':\n\t\tcase 'th':\n\t\tcase 'thead':\n\t\tcase 'tr':\n\t\t\t// These tags are only valid with a few parents that have special child\n\t\t\t// parsing rules -- if we're down here, then none of those matched and\n\t\t\t// so we allow it only if we don't know what the parent is, as all other\n\t\t\t// cases are invalid.\n\t\t\treturn parent_tag == null;\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {string} name\n * @param {\"include-on\" | \"exclude-on\"} [mode] - wether if name starts with `on` or `on` is excluded at this point\n */\nexport function is_capture_event(name, mode = 'exclude-on') {\n\tif (!name.endsWith('capture')) {\n\t\treturn false;\n\t}\n\treturn mode == 'exclude-on'\n\t\t? name !== 'gotpointercapture' && name !== 'lostpointercapture'\n\t\t: name !== 'ongotpointercapture' && name !== 'onlostpointercapture';\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead\n * @returns {never}\n */\nexport function bind_invalid_checkbox_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_checkbox_value\\nUsing \\`bind:value\\` together with a checkbox input is not allowed. Use \\`bind:checked\\` instead`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_checkbox_value\");\n\t}\n}\n\n/**\n * Component %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `<%name% bind:this={component} />`) and then access the property on the bound component instance (e.g. `component.%key%`)\n * @param {string} component\n * @param {string} key\n * @param {string} name\n * @returns {never}\n */\nexport function bind_invalid_export(component, key, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_export\\nComponent ${component} has an export named \\`${key}\\` that a consumer component is trying to access using \\`bind:${key}\\`, which is disallowed. Instead, use \\`bind:this\\` (e.g. \\`<${name} bind:this={component} />\\`) and then access the property on the bound component instance (e.g. \\`component.${key}\\`)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_export\");\n\t}\n}\n\n/**\n * A component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `<%name% bind:%key%={...}>`). To mark a property as bindable: `let { %key% = $bindable() } = $props()`\n * @param {string} key\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function bind_not_bindable(key, component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_not_bindable\\nA component is attempting to bind to a non-bindable property \\`${key}\\` belonging to ${component} (i.e. \\`<${name} bind:${key}={...}>\\`). To mark a property as bindable: \\`let { ${key} = $bindable() } = $props()\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_not_bindable\");\n\t}\n}\n\n/**\n * %parent% called `%method%` on an instance of %component%, which is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information\n * @param {string} parent\n * @param {string} method\n * @param {string} component\n * @returns {never}\n */\nexport function component_api_changed(parent, method, component) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_changed\\n${parent} called \\`${method}\\` on an instance of ${component}, which is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_changed\");\n\t}\n}\n\n/**\n * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `legacy.componentApi` compiler option to keep it working. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function component_api_invalid_new(component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_invalid_new\\nAttempted to instantiate ${component} with \\`new ${name}\\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \\`legacy.componentApi\\` compiler option to keep it working. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_invalid_new\");\n\t}\n}\n\n/**\n * Keyed each block has duplicate key `%value%` at indexes %a% and %b%\n * @param {string} a\n * @param {string} b\n * @param {string | undefined | null} [value]\n * @returns {never}\n */\nexport function each_key_duplicate(a, b, value) {\n\tif (DEV) {\n\t\tconst error = new Error(`each_key_duplicate\\n${value ? `Keyed each block has duplicate key \\`${value}\\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"each_key_duplicate\");\n\t}\n}\n\n/**\n * `%rune%` cannot be used inside an effect cleanup function\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_in_teardown(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_teardown\\n\\`${rune}\\` cannot be used inside an effect cleanup function`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_teardown\");\n\t}\n}\n\n/**\n * Effect cannot be created inside a `$derived` value that was not itself created inside an effect\n * @returns {never}\n */\nexport function effect_in_unowned_derived() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_unowned_derived\\nEffect cannot be created inside a \\`$derived\\` value that was not itself created inside an effect`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_unowned_derived\");\n\t}\n}\n\n/**\n * `%rune%` can only be used inside an effect (e.g. during component initialisation)\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_orphan(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_orphan\\n\\`${rune}\\` can only be used inside an effect (e.g. during component initialisation)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_orphan\");\n\t}\n}\n\n/**\n * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\n * @returns {never}\n */\nexport function effect_update_depth_exceeded() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_update_depth_exceeded\\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_update_depth_exceeded\");\n\t}\n}\n\n/**\n * Failed to hydrate the application\n * @returns {never}\n */\nexport function hydration_failed() {\n\tif (DEV) {\n\t\tconst error = new Error(`hydration_failed\\nFailed to hydrate the application`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"hydration_failed\");\n\t}\n}\n\n/**\n * `%name%(...)` cannot be used in runes mode\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_legacy_only(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_legacy_only\\n\\`${name}(...)\\` cannot be used in runes mode`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"lifecycle_legacy_only\");\n\t}\n}\n\n/**\n * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value\n * @param {string} key\n * @returns {never}\n */\nexport function props_invalid_value(key) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_invalid_value\\nCannot do \\`bind:${key}={undefined}\\` when \\`${key}\\` has a fallback value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_invalid_value\");\n\t}\n}\n\n/**\n * Rest element properties of `$props()` such as `%property%` are readonly\n * @param {string} property\n * @returns {never}\n */\nexport function props_rest_readonly(property) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_rest_readonly\\nRest element properties of \\`$props()\\` such as \\`${property}\\` are readonly`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_rest_readonly\");\n\t}\n}\n\n/**\n * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files\n * @param {string} rune\n * @returns {never}\n */\nexport function rune_outside_svelte(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`rune_outside_svelte\\nThe \\`${rune}\\` rune is only available inside \\`.svelte\\` and \\`.svelte.js/ts\\` files`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"rune_outside_svelte\");\n\t}\n}\n\n/**\n * Cannot set prototype of `$state` object\n * @returns {never}\n */\nexport function state_prototype_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_prototype_fixed\\nCannot set prototype of \\`$state\\` object`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_prototype_fixed\");\n\t}\n}\n\n/**\n * Updating state inside a derived is forbidden. If the value should not be reactive, declare it without `$state`\n * @returns {never}\n */\nexport function state_unsafe_mutation() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_mutation\\nUpdating state inside a derived is forbidden. If the value should not be reactive, declare it without \\`$state\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_unsafe_mutation\");\n\t}\n}\n\n/**\n * The `this={...}` property of a `<svelte:component>` must be a Svelte component, if defined\n * @returns {never}\n */\nexport function svelte_component_invalid_this_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`svelte_component_invalid_this_value\\nThe \\`this={...}\\` property of a \\`<svelte:component>\\` must be a Svelte component, if defined`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"svelte_component_invalid_this_value\");\n\t}\n}","import { DEV } from 'esm-env';\nimport {\n\tcurrent_component_context,\n\tcurrent_reaction,\n\tcurrent_dependencies,\n\tcurrent_effect,\n\tcurrent_untracked_writes,\n\tget,\n\tis_runes,\n\tmark_reactions,\n\tschedule_effect,\n\tset_current_untracked_writes,\n\tset_signal_status,\n\tuntrack,\n\tincrement_version,\n\texecute_effect,\n\tinspect_effects\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport { CLEAN, DERIVED, DIRTY, BRANCH_EFFECT } from '../constants.js';\nimport { UNINITIALIZED } from '../../../constants.js';\nimport * as e from '../errors.js';\n\n/**\n * @template V\n * @param {V} v\n * @returns {import('#client').Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function source(v) {\n\treturn {\n\t\tf: 0, // TODO ideally we could skip this altogether, but it causes type errors\n\t\tv,\n\t\treactions: null,\n\t\tequals,\n\t\tversion: 0\n\t};\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @returns {import('#client').Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mutable_source(initial_value) {\n\tconst s = source(initial_value);\n\ts.equals = safe_equals;\n\n\t// bind the signal to the component context, in case we need to\n\t// track updates to trigger beforeUpdate/afterUpdate callbacks\n\tif (current_component_context !== null && current_component_context.l !== null) {\n\t\t(current_component_context.l.s ??= []).push(s);\n\t}\n\n\treturn s;\n}\n\n/**\n * @template V\n * @param {import('#client').Value<V>} source\n * @param {V} value\n */\nexport function mutate(source, value) {\n\tset(\n\t\tsource,\n\t\tuntrack(() => get(source))\n\t);\n\treturn value;\n}\n\n/**\n * @template V\n * @param {import('#client').Source<V>} source\n * @param {V} value\n * @returns {V}\n */\nexport function set(source, value) {\n\tvar initialized = source.v !== UNINITIALIZED;\n\n\tif (\n\t\tinitialized &&\n\t\tcurrent_reaction !== null &&\n\t\tis_runes() &&\n\t\t(current_reaction.f & DERIVED) !== 0\n\t) {\n\t\te.state_unsafe_mutation();\n\t}\n\n\tif (!source.equals(value)) {\n\t\tsource.v = value;\n\t\tsource.version = increment_version();\n\n\t\tmark_reactions(source, DIRTY, true);\n\n\t\t// If the current signal is running for the first time, it won't have any\n\t\t// reactions as we only allocate and assign the reactions after the signal\n\t\t// has fully executed. So in the case of ensuring it registers the reaction\n\t\t// properly for itself, we need to ensure the current effect actually gets\n\t\t// scheduled. i.e:\n\t\t//\n\t\t// $effect(() => x++)\n\t\t//\n\t\t// We additionally want to skip this logic when initialising store sources\n\t\tif (\n\t\t\tis_runes() &&\n\t\t\tinitialized &&\n\t\t\tcurrent_effect !== null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\t(current_effect.f & BRANCH_EFFECT) === 0\n\t\t) {\n\t\t\tif (current_dependencies !== null && current_dependencies.includes(source)) {\n\t\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\t\tschedule_effect(current_effect);\n\t\t\t} else {\n\t\t\t\tif (current_untracked_writes === null) {\n\t\t\t\t\tset_current_untracked_writes([source]);\n\t\t\t\t} else {\n\t\t\t\t\tcurrent_untracked_writes.push(source);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (DEV) {\n\t\t\tfor (const effect of inspect_effects) {\n\t\t\t\texecute_effect(effect);\n\t\t\t}\n\n\t\t\tinspect_effects.clear();\n\t\t}\n\t}\n\n\treturn value;\n}\n","import { is_array } from '../utils.js';\n\n/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n\n/**\n * @param {import('#client').Dom} current\n */\nexport function remove(current) {\n\tif (is_array(current)) {\n\t\tfor (var i = 0; i < current.length; i++) {\n\t\t\tvar node = current[i];\n\t\t\tif (node.isConnected) {\n\t\t\t\tnode.remove();\n\t\t\t}\n\t\t}\n\t} else if (current.isConnected) {\n\t\tcurrent.remove();\n\t}\n}\n","import {\n\tcheck_dirtiness,\n\tcurrent_component_context,\n\tcurrent_effect,\n\tcurrent_reaction,\n\tdestroy_effect_children,\n\tdev_current_component_function,\n\texecute_effect,\n\tget,\n\tis_destroying_effect,\n\tis_flushing_effect,\n\tremove_reactions,\n\tschedule_effect,\n\tset_current_reaction,\n\tset_is_destroying_effect,\n\tset_is_flushing_effect,\n\tset_signal_status,\n\tuntrack\n} from '../runtime.js';\nimport {\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tRENDER_EFFECT,\n\tEFFECT,\n\tDESTROYED,\n\tINERT,\n\tEFFECT_RAN,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tEFFECT_TRANSPARENT,\n\tDERIVED,\n\tUNOWNED,\n\tCLEAN,\n\tINSPECT_EFFECT\n} from '../constants.js';\nimport { set } from './sources.js';\nimport { remove } from '../dom/reconciler.js';\nimport * as e from '../errors.js';\nimport { DEV } from 'esm-env';\nimport { define_property } from '../utils.js';\n\n/**\n * @param {'$effect' | '$effect.pre' | '$inspect'} rune\n */\nexport function validate_effect(rune) {\n\tif (current_effect === null && current_reaction === null) {\n\t\te.effect_orphan(rune);\n\t}\n\n\tif (current_reaction !== null && (current_reaction.f & UNOWNED) !== 0) {\n\t\te.effect_in_unowned_derived();\n\t}\n\n\tif (is_destroying_effect) {\n\t\te.effect_in_teardown(rune);\n\t}\n}\n\n/**\n * @param {import(\"#client\").Effect} effect\n * @param {import(\"#client\").Reaction} parent_effect\n */\nexport function push_effect(effect, parent_effect) {\n\tvar parent_last = parent_effect.last;\n\tif (parent_last === null) {\n\t\tparent_effect.last = parent_effect.first = effect;\n\t} else {\n\t\tparent_last.next = effect;\n\t\teffect.prev = parent_last;\n\t\tparent_effect.last = effect;\n\t}\n}\n\n/**\n * @param {number} type\n * @param {null | (() => void | (() => void))} fn\n * @param {boolean} sync\n * @returns {import('#client').Effect}\n */\nfunction create_effect(type, fn, sync) {\n\tvar is_root = (type & ROOT_EFFECT) !== 0;\n\n\t/** @type {import('#client').Effect} */\n\tvar effect = {\n\t\tctx: current_component_context,\n\t\tdeps: null,\n\t\tdom: null,\n\t\tf: type | DIRTY,\n\t\tfirst: null,\n\t\tfn,\n\t\tlast: null,\n\t\tnext: null,\n\t\tparent: is_root ? null : current_effect,\n\t\tprev: null,\n\t\tteardown: null,\n\t\ttransitions: null\n\t};\n\n\tif (DEV) {\n\t\teffect.component_function = dev_current_component_function;\n\t}\n\n\tif (sync) {\n\t\tvar previously_flushing_effect = is_flushing_effect;\n\n\t\ttry {\n\t\t\tset_is_flushing_effect(true);\n\t\t\texecute_effect(effect);\n\t\t\teffect.f |= EFFECT_RAN;\n\t\t} finally {\n\t\t\tset_is_flushing_effect(previously_flushing_effect);\n\t\t}\n\t} else if (fn !== null) {\n\t\tschedule_effect(effect);\n\t}\n\n\t// if an effect has no dependencies, no DOM and no teardown function,\n\t// don't bother adding it to the effect tree\n\tvar inert =\n\t\tsync &&\n\t\teffect.deps === null &&\n\t\teffect.first === null &&\n\t\teffect.dom === null &&\n\t\teffect.teardown === null;\n\n\tif (!inert && !is_root) {\n\t\tif (current_effect !== null) {\n\t\t\tpush_effect(effect, current_effect);\n\t\t}\n\n\t\t// if we're in a derived, add the effect there too\n\t\tif (current_reaction !== null && (current_reaction.f & DERIVED) !== 0) {\n\t\t\tpush_effect(effect, current_reaction);\n\t\t}\n\t}\n\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect.tracking()`\n * @returns {boolean}\n */\nexport function effect_tracking() {\n\tif (current_reaction === null) {\n\t\treturn false;\n\t}\n\n\treturn (current_reaction.f & UNOWNED) === 0;\n}\n\n/**\n * @param {() => void} fn\n */\nexport function teardown(fn) {\n\tconst effect = create_effect(RENDER_EFFECT, null, false);\n\tset_signal_status(effect, CLEAN);\n\teffect.teardown = fn;\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect(...)`\n * @param {() => void | (() => void)} fn\n */\nexport function user_effect(fn) {\n\tvalidate_effect('$effect');\n\n\t// Non-nested `$effect(...)` in a component should be deferred\n\t// until the component is mounted\n\tvar defer =\n\t\tcurrent_effect !== null &&\n\t\t(current_effect.f & RENDER_EFFECT) !== 0 &&\n\t\t// TODO do we actually need this? removing them changes nothing\n\t\tcurrent_component_context !== null &&\n\t\t!current_component_context.m;\n\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect'\n\t\t});\n\t}\n\n\tif (defer) {\n\t\tvar context = /** @type {import('#client').ComponentContext} */ (current_component_context);\n\t\t(context.e ??= []).push(fn);\n\t} else {\n\t\tvar signal = effect(fn);\n\t\treturn signal;\n\t}\n}\n\n/**\n * Internal representation of `$effect.pre(...)`\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function user_pre_effect(fn) {\n\tvalidate_effect('$effect.pre');\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect.pre'\n\t\t});\n\t}\n\treturn render_effect(fn);\n}\n\n/** @param {() => void | (() => void)} fn */\nexport function inspect_effect(fn) {\n\treturn create_effect(INSPECT_EFFECT, fn, true);\n}\n\n/**\n * Internal representation of `$effect.root(...)`\n * @param {() => void | (() => void)} fn\n * @returns {() => void}\n */\nexport function effect_root(fn) {\n\tconst effect = create_effect(ROOT_EFFECT, fn, true);\n\treturn () => {\n\t\tdestroy_effect(effect);\n\t};\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function effect(fn) {\n\treturn create_effect(EFFECT, fn, false);\n}\n\n/**\n * Internal representation of `$: ..`\n * @param {() => any} deps\n * @param {() => void | (() => void)} fn\n */\nexport function legacy_pre_effect(deps, fn) {\n\tvar context = /** @type {import('#client').ComponentContextLegacy} */ (current_component_context);\n\n\t/** @type {{ effect: null | import('#client').Effect, ran: boolean }} */\n\tvar token = { effect: null, ran: false };\n\tcontext.l.r1.push(token);\n\n\ttoken.effect = render_effect(() => {\n\t\tdeps();\n\n\t\t// If this legacy pre effect has already run before the end of the reset, then\n\t\t// bail-out to emulate the same behavior.\n\t\tif (token.ran) return;\n\n\t\ttoken.ran = true;\n\t\tset(context.l.r2, true);\n\t\tuntrack(fn);\n\t});\n}\n\nexport function legacy_pre_effect_reset() {\n\tvar context = /** @type {import('#client').ComponentContextLegacy} */ (current_component_context);\n\n\trender_effect(() => {\n\t\tif (!get(context.l.r2)) return;\n\n\t\t// Run dirty `$:` statements\n\t\tfor (var token of context.l.r1) {\n\t\t\tvar effect = token.effect;\n\n\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\texecute_effect(effect);\n\t\t\t}\n\n\t\t\ttoken.ran = false;\n\t\t}\n\n\t\tcontext.l.r2.v = false; // set directly to avoid rerunning this effect\n\t});\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function render_effect(fn) {\n\treturn create_effect(RENDER_EFFECT, fn, true);\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function template_effect(fn) {\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '{expression}'\n\t\t});\n\t}\n\treturn render_effect(fn);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {number} flags\n */\nexport function block(fn, flags = 0) {\n\treturn create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);\n}\n\n/** @param {(() => void)} fn */\nexport function branch(fn) {\n\treturn create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true);\n}\n\n/**\n * @param {import(\"#client\").Effect} effect\n */\nexport function execute_effect_teardown(effect) {\n\tvar teardown = effect.teardown;\n\tif (teardown !== null) {\n\t\tconst previously_destroying_effect = is_destroying_effect;\n\t\tconst previous_reaction = current_reaction;\n\t\tset_is_destroying_effect(true);\n\t\tset_current_reaction(null);\n\t\ttry {\n\t\t\tteardown.call(null);\n\t\t} finally {\n\t\t\tset_is_destroying_effect(previously_destroying_effect);\n\t\t\tset_current_reaction(previous_reaction);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @param {boolean} [remove_dom]\n * @returns {void}\n */\nexport function destroy_effect(effect, remove_dom = true) {\n\tvar dom = effect.dom;\n\n\tif (dom !== null && remove_dom) {\n\t\tremove(dom);\n\t}\n\n\tdestroy_effect_children(effect, remove_dom);\n\tremove_reactions(effect, 0);\n\tset_signal_status(effect, DESTROYED);\n\n\tif (effect.transitions) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\ttransition.stop();\n\t\t}\n\t}\n\n\texecute_effect_teardown(effect);\n\n\tvar parent = effect.parent;\n\n\t// If the parent doesn't have any children, then skip this work altogether\n\tif (parent !== null && (effect.f & BRANCH_EFFECT) !== 0 && parent.first !== null) {\n\t\tunlink_effect(effect);\n\t}\n\n\t// `first` and `child` are nulled out in destroy_effect_children\n\teffect.next =\n\t\teffect.prev =\n\t\teffect.teardown =\n\t\teffect.ctx =\n\t\teffect.dom =\n\t\teffect.deps =\n\t\teffect.parent =\n\t\teffect.fn =\n\t\t\tnull;\n}\n\n/**\n * Detach an effect from the effect tree, freeing up memory and\n * reducing the amount of work that happens on subsequent traversals\n * @param {import('#client').Effect} effect\n */\nexport function unlink_effect(effect) {\n\tvar parent = effect.parent;\n\tvar prev = effect.prev;\n\tvar next = effect.next;\n\n\tif (prev !== null) prev.next = next;\n\tif (next !== null) next.prev = prev;\n\n\tif (parent !== null) {\n\t\tif (parent.first === effect) parent.first = next;\n\t\tif (parent.last === effect) parent.last = prev;\n\t}\n}\n\n/**\n * When a block effect is removed, we don't immediately destroy it or yank it\n * out of the DOM, because it might have transitions. Instead, we 'pause' it.\n * It stays around (in memory, and in the DOM) until outro transitions have\n * completed, and if the state change is reversed then we _resume_ it.\n * A paused effect does not update, and the DOM subtree becomes inert.\n * @param {import('#client').Effect} effect\n * @param {() => void} [callback]\n */\nexport function pause_effect(effect, callback) {\n\t/** @type {import('#client').TransitionManager[]} */\n\tvar transitions = [];\n\n\tpause_children(effect, transitions, true);\n\n\trun_out_transitions(transitions, () => {\n\t\tdestroy_effect(effect);\n\t\tif (callback) callback();\n\t});\n}\n\n/**\n * @param {import('#client').TransitionManager[]} transitions\n * @param {() => void} fn\n */\nexport function run_out_transitions(transitions, fn) {\n\tvar remaining = transitions.length;\n\tif (remaining > 0) {\n\t\tvar check = () => --remaining || fn();\n\t\tfor (var transition of transitions) {\n\t\t\ttransition.out(check);\n\t\t}\n\t} else {\n\t\tfn();\n\t}\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @param {import('#client').TransitionManager[]} transitions\n * @param {boolean} local\n */\nexport function pause_children(effect, transitions, local) {\n\tif ((effect.f & INERT) !== 0) return;\n\teffect.f ^= INERT;\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransitions.push(transition);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call pause_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tpause_children(child, transitions, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n}\n\n/**\n * The opposite of `pause_effect`. We call this if (for example)\n * `x` becomes falsy then truthy: `{#if x}...{/if}`\n * @param {import('#client').Effect} effect\n */\nexport function resume_effect(effect) {\n\tresume_children(effect, true);\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @param {boolean} local\n */\nfunction resume_children(effect, local) {\n\tif ((effect.f & INERT) === 0) return;\n\teffect.f ^= INERT;\n\n\t// If a dependency of this effect changed while it was paused,\n\t// apply the change now\n\tif (check_dirtiness(effect)) {\n\t\texecute_effect(effect);\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call resume_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tresume_children(child, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransition.in();\n\t\t\t}\n\t\t}\n\t}\n}\n","export const noop = () => {};\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n\n/**\n * @template [T=any]\n * @param {any} value\n * @returns {value is PromiseLike<T>}\n */\nexport function is_promise(value) {\n\treturn typeof value?.then === 'function';\n}\n\n/** @param {Function} fn */\nexport function run(fn) {\n\treturn fn();\n}\n\n/** @param {Array<() => void>} arr */\nexport function run_all(arr) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tarr[i]();\n\t}\n}\n","import { run_all } from '../../shared/utils.js';\n\n// Fallback for when requestIdleCallback is not available\nconst request_idle_callback =\n\ttypeof requestIdleCallback === 'undefined'\n\t\t? (/** @type {() => void} */ cb) => setTimeout(cb, 1)\n\t\t: requestIdleCallback;\n\nlet is_micro_task_queued = false;\nlet is_idle_task_queued = false;\n\n/** @type {Array<() => void>} */\nlet current_queued_micro_tasks = [];\n/** @type {Array<() => void>} */\nlet current_queued_idle_tasks = [];\n\nfunction process_micro_tasks() {\n\tis_micro_task_queued = false;\n\tconst tasks = current_queued_micro_tasks.slice();\n\tcurrent_queued_micro_tasks = [];\n\trun_all(tasks);\n}\n\nfunction process_idle_tasks() {\n\tis_idle_task_queued = false;\n\tconst tasks = current_queued_idle_tasks.slice();\n\tcurrent_queued_idle_tasks = [];\n\trun_all(tasks);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_micro_task(fn) {\n\tif (!is_micro_task_queued) {\n\t\tis_micro_task_queued = true;\n\t\tqueueMicrotask(process_micro_tasks);\n\t}\n\tcurrent_queued_micro_tasks.push(fn);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_idle_task(fn) {\n\tif (!is_idle_task_queued) {\n\t\tis_idle_task_queued = true;\n\t\trequest_idle_callback(process_idle_tasks);\n\t}\n\tcurrent_queued_idle_tasks.push(fn);\n}\n\n/**\n * Synchronously run any queued tasks.\n */\nexport function flush_tasks() {\n\tif (is_micro_task_queued) {\n\t\tprocess_micro_tasks();\n\t}\n\tif (is_idle_task_queued) {\n\t\tprocess_idle_tasks();\n\t}\n}\n","import { CLEAN, DERIVED, DESTROYED, DIRTY, MAYBE_DIRTY, UNOWNED } from '../constants.js';\nimport {\n\tcurrent_reaction,\n\tcurrent_effect,\n\tremove_reactions,\n\tset_signal_status,\n\tmark_reactions,\n\tcurrent_skip_reaction,\n\texecute_reaction_fn,\n\tdestroy_effect_children,\n\tincrement_version\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\n\nexport let updating_derived = false;\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {import('#client').Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(fn) {\n\tlet flags = DERIVED | DIRTY;\n\tif (current_effect === null) flags |= UNOWNED;\n\n\t/** @type {import('#client').Derived<V>} */\n\tconst signal = {\n\t\tdeps: null,\n\t\tderiveds: null,\n\t\tequals,\n\t\tf: flags,\n\t\tfirst: null,\n\t\tfn,\n\t\tlast: null,\n\t\treactions: null,\n\t\tv: /** @type {V} */ (null),\n\t\tversion: 0\n\t};\n\n\tif (current_reaction !== null && (current_reaction.f & DERIVED) !== 0) {\n\t\tvar current_derived = /** @type {import('#client').Derived<V>} */ (current_reaction);\n\t\tif (current_derived.deriveds === null) {\n\t\t\tcurrent_derived.deriveds = [signal];\n\t\t} else {\n\t\t\tcurrent_derived.deriveds.push(signal);\n\t\t}\n\t}\n\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {import('#client').Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived_safe_equal(fn) {\n\tconst signal = derived(fn);\n\tsignal.equals = safe_equals;\n\treturn signal;\n}\n\n/**\n * @param {import('#client').Derived} signal\n * @returns {void}\n */\nfunction destroy_derived_children(signal) {\n\tdestroy_effect_children(signal);\n\tvar deriveds = signal.deriveds;\n\n\tif (deriveds !== null) {\n\t\tsignal.deriveds = null;\n\t\tfor (var i = 0; i < deriveds.length; i += 1) {\n\t\t\tdestroy_derived(deriveds[i]);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Derived} derived\n * @returns {void}\n */\nexport function update_derived(derived) {\n\tvar previous_updating_derived = updating_derived;\n\tupdating_derived = true;\n\tdestroy_derived_children(derived);\n\tvar value = execute_reaction_fn(derived);\n\tupdating_derived = previous_updating_derived;\n\n\tvar status =\n\t\t(current_skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null\n\t\t\t? MAYBE_DIRTY\n\t\t\t: CLEAN;\n\n\tset_signal_status(derived, status);\n\n\tif (!derived.equals(value)) {\n\t\tderived.v = value;\n\t\tderived.version = increment_version();\n\t\tmark_reactions(derived, DIRTY, false);\n\t}\n}\n\n/**\n * @param {import('#client').Derived} signal\n * @returns {void}\n */\nexport function destroy_derived(signal) {\n\tdestroy_derived_children(signal);\n\tremove_reactions(signal, 0);\n\tset_signal_status(signal, DESTROYED);\n\n\t// TODO we need to ensure we remove the derived from any parent derives\n\n\tsignal.first =\n\t\tsignal.last =\n\t\tsignal.deps =\n\t\tsignal.reactions =\n\t\t// @ts-expect-error `signal.fn` cannot be `null` while the signal is alive\n\t\tsignal.fn =\n\t\t\tnull;\n}\n","import { DEV } from 'esm-env';\nimport {\n\tdefine_property,\n\tget_descriptors,\n\tget_prototype_of,\n\tis_frozen,\n\tobject_freeze\n} from './utils.js';\nimport { snapshot } from './proxy.js';\nimport {\n\tdestroy_effect,\n\teffect,\n\texecute_effect_teardown,\n\tunlink_effect\n} from './reactivity/effects.js';\nimport {\n\tEFFECT,\n\tRENDER_EFFECT,\n\tDIRTY,\n\tMAYBE_DIRTY,\n\tCLEAN,\n\tDERIVED,\n\tUNOWNED,\n\tDESTROYED,\n\tINERT,\n\tBRANCH_EFFECT,\n\tSTATE_SYMBOL,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tLEGACY_DERIVED_PROP,\n\tDISCONNECTED,\n\tSTATE_FROZEN_SYMBOL,\n\tINSPECT_EFFECT\n} from './constants.js';\nimport { flush_tasks } from './dom/task.js';\nimport { add_owner } from './dev/ownership.js';\nimport { mutate, set, source } from './reactivity/sources.js';\nimport { update_derived } from './reactivity/deriveds.js';\nimport * as e from './errors.js';\nimport { lifecycle_outside_component } from '../shared/errors.js';\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n\n// Used for DEV time error handling\n/** @param {WeakSet<Error>} value */\nconst handled_errors = new WeakSet();\n// Used for controlling the flush of effects.\nlet current_scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\nlet is_micro_task_queued = false;\n\nexport let is_flushing_effect = false;\nexport let is_destroying_effect = false;\n\n/** @param {boolean} value */\nexport function set_is_flushing_effect(value) {\n\tis_flushing_effect = value;\n}\n\n/** @param {boolean} value */\nexport function set_is_destroying_effect(value) {\n\tis_destroying_effect = value;\n}\n\nexport let inspect_effects = new Set();\n\n// Handle effect queues\n\n/** @type {import('#client').Effect[]} */\nlet current_queued_root_effects = [];\n\nlet flush_count = 0;\n// Handle signal reactivity tree dependencies and reactions\n\n/** @type {null | import('#client').Reaction} */\nexport let current_reaction = null;\n\n/** @param {null | import('#client').Reaction} reaction */\nexport function set_current_reaction(reaction) {\n\tcurrent_reaction = reaction;\n}\n\n/** @type {null | import('#client').Effect} */\nexport let current_effect = null;\n\n/** @param {null | import('#client').Effect} effect */\nexport function set_current_effect(effect) {\n\tcurrent_effect = effect;\n}\n\n/** @type {null | import('#client').Value[]} */\nexport let current_dependencies = null;\nlet current_dependencies_index = 0;\n/**\n * Tracks writes that the effect it's executed in doesn't listen to yet,\n * so that the dependency can be added to the effect later on if it then reads it\n * @type {null | import('#client').Source[]}\n */\nexport let current_untracked_writes = null;\n\n/** @param {null | import('#client').Source[]} value */\nexport function set_current_untracked_writes(value) {\n\tcurrent_untracked_writes = value;\n}\n\n/** @type {number} Used by sources and deriveds for handling updates to unowned deriveds */\nlet current_version = 0;\n\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the reaction.\nexport let current_skip_reaction = false;\n// Handle collecting all signals which are read during a specific time frame\nexport let is_signals_recorded = false;\nlet captured_signals = new Set();\n\n// Handling runtime component context\n/** @type {import('#client').ComponentContext | null} */\nexport let current_component_context = null;\n\n/** @param {import('#client').ComponentContext | null} context */\nexport function set_current_component_context(context) {\n\tcurrent_component_context = context;\n}\n\n/**\n * The current component function. Different from current component context:\n * ```html\n * <!-- App.svelte -->\n * <Foo>\n *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->\n * </Foo>\n * ```\n * @type {import('#client').ComponentContext['function']}\n */\nexport let dev_current_component_function = null;\n\n/** @param {import('#client').ComponentContext['function']} fn */\nexport function set_dev_current_component_function(fn) {\n\tdev_current_component_function = fn;\n}\n\nexport function increment_version() {\n\treturn current_version++;\n}\n\n/** @returns {boolean} */\nexport function is_runes() {\n\treturn current_component_context !== null && current_component_context.l === null;\n}\n\n/**\n * Determines whether a derived or effect is dirty.\n * If it is MAYBE_DIRTY, will set the status to CLEAN\n * @param {import('#client').Reaction} reaction\n * @returns {boolean}\n */\nexport function check_dirtiness(reaction) {\n\tvar flags = reaction.f;\n\tvar is_dirty = (flags & DIRTY) !== 0;\n\n\tif (is_dirty) {\n\t\treturn true;\n\t}\n\n\tvar is_unowned = (flags & UNOWNED) !== 0;\n\tvar is_disconnected = (flags & DISCONNECTED) !== 0;\n\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tvar dependencies = reaction.deps;\n\n\t\tif (dependencies !== null) {\n\t\t\tvar length = dependencies.length;\n\t\t\tvar reactions;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tvar dependency = dependencies[i];\n\n\t\t\t\tif (!is_dirty && check_dirtiness(/** @type {import('#client').Derived} */ (dependency))) {\n\t\t\t\t\tupdate_derived(/** @type {import('#client').Derived} **/ (dependency));\n\t\t\t\t}\n\n\t\t\t\tvar version = dependency.version;\n\n\t\t\t\tif (is_unowned) {\n\t\t\t\t\t// If we're working with an unowned derived signal, then we need to check\n\t\t\t\t\t// if our dependency write version is higher. If it is then we can assume\n\t\t\t\t\t// that state has changed to a newer version and thus this unowned signal\n\t\t\t\t\t// is also dirty.\n\t\t\t\t\tif (version > /** @type {import('#client').Derived} */ (reaction).version) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!current_skip_reaction && !dependency?.reactions?.includes(reaction)) {\n\t\t\t\t\t\t// If we are working with an unowned signal as part of an effect (due to !current_skip_reaction)\n\t\t\t\t\t\t// and the version hasn't changed, we still need to check that this reaction\n\t\t\t\t\t\t// if linked to the dependency source – otherwise future updates will not be caught.\n\t\t\t\t\t\t(dependency.reactions ??= []).push(reaction);\n\t\t\t\t\t}\n\t\t\t\t} else if ((reaction.f & DIRTY) !== 0) {\n\t\t\t\t\t// `signal` might now be dirty, as a result of calling `check_dirtiness` and/or `update_derived`\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (is_disconnected) {\n\t\t\t\t\t// It might be that the derived was was dereferenced from its dependencies but has now come alive again.\n\t\t\t\t\t// In thise case, we need to re-attach it to the graph and mark it dirty if any of its dependencies have\n\t\t\t\t\t// changed since.\n\t\t\t\t\tif (version > /** @type {import('#client').Derived} */ (reaction).version) {\n\t\t\t\t\t\tis_dirty = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treactions = dependency.reactions;\n\t\t\t\t\tif (reactions === null) {\n\t\t\t\t\t\tdependency.reactions = [reaction];\n\t\t\t\t\t} else if (!reactions.includes(reaction)) {\n\t\t\t\t\t\treactions.push(reaction);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Unowned signals are always maybe dirty, as we instead check their dependency versions.\n\t\tif (!is_unowned) {\n\t\t\tset_signal_status(reaction, CLEAN);\n\t\t}\n\t\tif (is_disconnected) {\n\t\t\treaction.f ^= DISCONNECTED;\n\t\t}\n\t}\n\n\treturn is_dirty;\n}\n\n/**\n * @param {Error} error\n * @param {import(\"#client\").Effect} effect\n * @param {import(\"#client\").ComponentContext | null} component_context\n */\nfunction handle_error(error, effect, component_context) {\n\t// Given we don't yet have error boundaries, we will just always throw.\n\tif (!DEV || handled_errors.has(error) || component_context === null) {\n\t\tthrow error;\n\t}\n\n\tconst component_stack = [];\n\n\tconst effect_name = effect.fn?.name;\n\n\tif (effect_name) {\n\t\tcomponent_stack.push(effect_name);\n\t}\n\n\t/** @type {import(\"#client\").ComponentContext | null} */\n\tlet current_context = component_context;\n\n\twhile (current_context !== null) {\n\t\tvar filename = current_context.function?.filename;\n\n\t\tif (filename) {\n\t\t\tconst file = filename.split('/').at(-1);\n\t\t\tcomponent_stack.push(file);\n\t\t}\n\n\t\tcurrent_context = current_context.p;\n\t}\n\n\tconst indent = /Firefox/.test(navigator.userAgent) ? '  ' : '\\t';\n\tdefine_property(error, 'message', {\n\t\tvalue: error.message + `\\n${component_stack.map((name) => `\\n${indent}in ${name}`).join('')}\\n`\n\t});\n\n\tconst stack = error.stack;\n\n\t// Filter out internal files from callstack\n\tif (stack) {\n\t\tconst lines = stack.split('\\n');\n\t\tconst new_lines = [];\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tif (line.includes('svelte/src/internal')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnew_lines.push(line);\n\t\t}\n\t\tdefine_property(error, 'stack', {\n\t\t\tvalue: error.stack + new_lines.join('\\n')\n\t\t});\n\t}\n\n\thandled_errors.add(error);\n\tthrow error;\n}\n\n/**\n * @template V\n * @param {import('#client').Reaction} signal\n * @returns {V}\n */\nexport function execute_reaction_fn(signal) {\n\tconst previous_dependencies = current_dependencies;\n\tconst previous_dependencies_index = current_dependencies_index;\n\tconst previous_untracked_writes = current_untracked_writes;\n\tconst previous_reaction = current_reaction;\n\tconst previous_skip_reaction = current_skip_reaction;\n\n\tcurrent_dependencies = /** @type {null | import('#client').Value[]} */ (null);\n\tcurrent_dependencies_index = 0;\n\tcurrent_untracked_writes = null;\n\tcurrent_reaction = (signal.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? signal : null;\n\tcurrent_skip_reaction = !is_flushing_effect && (signal.f & UNOWNED) !== 0;\n\n\ttry {\n\t\tlet res = /** @type {Function} */ (0, signal.fn)();\n\t\tlet dependencies = /** @type {import('#client').Value<unknown>[]} **/ (signal.deps);\n\t\tif (current_dependencies !== null) {\n\t\t\tlet i;\n\t\t\tif (dependencies !== null) {\n\t\t\t\tconst deps_length = dependencies.length;\n\t\t\t\t// Include any dependencies up until the current_dependencies_index.\n\t\t\t\tconst full_current_dependencies =\n\t\t\t\t\tcurrent_dependencies_index === 0\n\t\t\t\t\t\t? current_dependencies\n\t\t\t\t\t\t: dependencies.slice(0, current_dependencies_index).concat(current_dependencies);\n\t\t\t\tconst current_dep_length = full_current_dependencies.length;\n\t\t\t\t// If we have more than 16 elements in the array then use a Set for faster performance\n\t\t\t\t// TODO: evaluate if we should always just use a Set or not here?\n\t\t\t\tconst full_current_dependencies_set =\n\t\t\t\t\tcurrent_dep_length > 16 && deps_length - current_dependencies_index > 1\n\t\t\t\t\t\t? new Set(full_current_dependencies)\n\t\t\t\t\t\t: null;\n\t\t\t\tfor (i = current_dependencies_index; i < deps_length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\t\tif (\n\t\t\t\t\t\tfull_current_dependencies_set !== null\n\t\t\t\t\t\t\t? !full_current_dependencies_set.has(dependency)\n\t\t\t\t\t\t\t: !full_current_dependencies.includes(dependency)\n\t\t\t\t\t) {\n\t\t\t\t\t\tremove_reaction(signal, dependency);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dependencies !== null && current_dependencies_index > 0) {\n\t\t\t\tdependencies.length = current_dependencies_index + current_dependencies.length;\n\t\t\t\tfor (i = 0; i < current_dependencies.length; i++) {\n\t\t\t\t\tdependencies[current_dependencies_index + i] = current_dependencies[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsignal.deps = /** @type {import('#client').Value<V>[]} **/ (\n\t\t\t\t\tdependencies = current_dependencies\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!current_skip_reaction) {\n\t\t\t\tfor (i = current_dependencies_index; i < dependencies.length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\t\tconst reactions = dependency.reactions;\n\n\t\t\t\t\tif (reactions === null) {\n\t\t\t\t\t\tdependency.reactions = [signal];\n\t\t\t\t\t} else if (reactions[reactions.length - 1] !== signal && !reactions.includes(signal)) {\n\t\t\t\t\t\treactions.push(signal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (dependencies !== null && current_dependencies_index < dependencies.length) {\n\t\t\tremove_reactions(signal, current_dependencies_index);\n\t\t\tdependencies.length = current_dependencies_index;\n\t\t}\n\t\treturn res;\n\t} finally {\n\t\tcurrent_dependencies = previous_dependencies;\n\t\tcurrent_dependencies_index = previous_dependencies_index;\n\t\tcurrent_untracked_writes = previous_untracked_writes;\n\t\tcurrent_reaction = previous_reaction;\n\t\tcurrent_skip_reaction = previous_skip_reaction;\n\t}\n}\n\n/**\n * @template V\n * @param {import('#client').Reaction} signal\n * @param {import('#client').Value<V>} dependency\n * @returns {void}\n */\nfunction remove_reaction(signal, dependency) {\n\tconst reactions = dependency.reactions;\n\tlet reactions_length = 0;\n\tif (reactions !== null) {\n\t\treactions_length = reactions.length - 1;\n\t\tconst index = reactions.indexOf(signal);\n\t\tif (index !== -1) {\n\t\t\tif (reactions_length === 0) {\n\t\t\t\tdependency.reactions = null;\n\t\t\t} else {\n\t\t\t\t// Swap with last element and then remove.\n\t\t\t\treactions[index] = reactions[reactions_length];\n\t\t\t\treactions.pop();\n\t\t\t}\n\t\t}\n\t}\n\t// If the derived has no reactions, then we can disconnect it from the graph,\n\t// allowing it to either reconnect in the future, or be GC'd by the VM.\n\tif (reactions_length === 0 && (dependency.f & DERIVED) !== 0) {\n\t\tset_signal_status(dependency, MAYBE_DIRTY);\n\t\t// If we are working with a derived that is owned by an effect, then mark it as being\n\t\t// disconnected.\n\t\tif ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {\n\t\t\tdependency.f ^= DISCONNECTED;\n\t\t}\n\t\tremove_reactions(/** @type {import('#client').Derived} **/ (dependency), 0);\n\t}\n}\n\n/**\n * @param {import('#client').Reaction} signal\n * @param {number} start_index\n * @returns {void}\n */\nexport function remove_reactions(signal, start_index) {\n\tconst dependencies = signal.deps;\n\tif (dependencies !== null) {\n\t\tconst active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);\n\t\tlet i;\n\t\tfor (i = start_index; i < dependencies.length; i++) {\n\t\t\tconst dependency = dependencies[i];\n\t\t\t// Avoid removing a reaction if we know that it is active (start_index will not be 0)\n\t\t\tif (active_dependencies === null || !active_dependencies.includes(dependency)) {\n\t\t\t\tremove_reaction(signal, dependency);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Reaction} signal\n * @param {boolean} [remove_dom]\n * @returns {void}\n */\nexport function destroy_effect_children(signal, remove_dom = true) {\n\tlet effect = signal.first;\n\tsignal.first = null;\n\tsignal.last = null;\n\tvar sibling;\n\twhile (effect !== null) {\n\t\tsibling = effect.next;\n\t\tdestroy_effect(effect, remove_dom);\n\t\teffect = sibling;\n\t}\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @returns {void}\n */\nexport function execute_effect(effect) {\n\tvar flags = effect.f;\n\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\n\tset_signal_status(effect, CLEAN);\n\n\tvar component_context = effect.ctx;\n\n\tvar previous_effect = current_effect;\n\tvar previous_component_context = current_component_context;\n\n\tcurrent_effect = effect;\n\tcurrent_component_context = component_context;\n\n\tif (DEV) {\n\t\tvar previous_component_fn = dev_current_component_function;\n\t\tdev_current_component_function = effect.component_function;\n\t}\n\n\ttry {\n\t\tif ((flags & BLOCK_EFFECT) === 0) {\n\t\t\tdestroy_effect_children(effect);\n\t\t}\n\n\t\texecute_effect_teardown(effect);\n\t\tvar teardown = execute_reaction_fn(effect);\n\t\teffect.teardown = typeof teardown === 'function' ? teardown : null;\n\t} catch (error) {\n\t\thandle_error(/** @type {Error} */ (error), effect, current_component_context);\n\t} finally {\n\t\tcurrent_effect = previous_effect;\n\t\tcurrent_component_context = previous_component_context;\n\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = previous_component_fn;\n\t\t}\n\t}\n}\n\nfunction infinite_loop_guard() {\n\tif (flush_count > 1000) {\n\t\tflush_count = 0;\n\t\te.effect_update_depth_exceeded();\n\t}\n\tflush_count++;\n}\n\n/**\n * @param {Array<import('#client').Effect>} root_effects\n * @returns {void}\n */\nfunction flush_queued_root_effects(root_effects) {\n\tvar length = root_effects.length;\n\tif (length === 0) {\n\t\treturn;\n\t}\n\tinfinite_loop_guard();\n\n\tvar previously_flushing_effect = is_flushing_effect;\n\tis_flushing_effect = true;\n\n\ttry {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar effect = root_effects[i];\n\n\t\t\t// When working with custom elements, the root effects might not have a root\n\t\t\tif (effect.first === null && (effect.f & BRANCH_EFFECT) === 0) {\n\t\t\t\tflush_queued_effects([effect]);\n\t\t\t} else {\n\t\t\t\t/** @type {import('#client').Effect[]} */\n\t\t\t\tvar collected_effects = [];\n\n\t\t\t\tprocess_effects(effect, collected_effects);\n\t\t\t\tflush_queued_effects(collected_effects);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tis_flushing_effect = previously_flushing_effect;\n\t}\n}\n\n/**\n * @param {Array<import('#client').Effect>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tvar length = effects.length;\n\tif (length === 0) return;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar effect = effects[i];\n\n\t\tif ((effect.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect)) {\n\t\t\texecute_effect(effect);\n\n\t\t\t// Effects with no dependencies or teardown do not get added to the effect tree.\n\t\t\t// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we\n\t\t\t// don't know if we need to keep them until they are executed. Doing the check\n\t\t\t// here (rather than in `execute_effect`) allows us to skip the work for\n\t\t\t// immediate effects.\n\t\t\tif (effect.deps === null && effect.first === null && effect.dom === null) {\n\t\t\t\tif (effect.teardown === null) {\n\t\t\t\t\t// remove this effect from the graph\n\t\t\t\t\tunlink_effect(effect);\n\t\t\t\t} else {\n\t\t\t\t\t// keep the effect in the graph, but free up some memory\n\t\t\t\t\teffect.fn = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction process_deferred() {\n\tis_micro_task_queued = false;\n\tif (flush_count > 1001) {\n\t\treturn;\n\t}\n\tconst previous_queued_root_effects = current_queued_root_effects;\n\tcurrent_queued_root_effects = [];\n\tflush_queued_root_effects(previous_queued_root_effects);\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t}\n}\n\n/**\n * @param {import('#client').Effect} signal\n * @returns {void}\n */\nexport function schedule_effect(signal) {\n\tif (current_scheduler_mode === FLUSH_MICROTASK) {\n\t\tif (!is_micro_task_queued) {\n\t\t\tis_micro_task_queued = true;\n\t\t\tqueueMicrotask(process_deferred);\n\t\t}\n\t}\n\n\tvar effect = signal;\n\n\twhile (effect.parent !== null) {\n\t\teffect = effect.parent;\n\t\tvar flags = effect.f;\n\n\t\tif ((flags & BRANCH_EFFECT) !== 0) {\n\t\t\tif ((flags & CLEAN) === 0) return;\n\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t}\n\t}\n\n\tcurrent_queued_root_effects.push(effect);\n}\n\n/**\n *\n * This function both runs render effects and collects user effects in topological order\n * from the starting effect passed in. Effects will be collected when they match the filtered\n * bitwise flag passed in only. The collected effects array will be populated with all the user\n * effects to be flushed.\n *\n * @param {import('#client').Effect} effect\n * @param {import('#client').Effect[]} collected_effects\n * @returns {void}\n */\nfunction process_effects(effect, collected_effects) {\n\tvar current_effect = effect.first;\n\tvar effects = [];\n\n\tmain_loop: while (current_effect !== null) {\n\t\tvar flags = current_effect.f;\n\t\t// TODO: we probably don't need to check for destroyed as it shouldn't be encountered?\n\t\tvar is_active = (flags & (DESTROYED | INERT)) === 0;\n\t\tvar is_branch = flags & BRANCH_EFFECT;\n\t\tvar is_clean = (flags & CLEAN) !== 0;\n\t\tvar child = current_effect.first;\n\n\t\t// Skip this branch if it's clean\n\t\tif (is_active && (!is_branch || !is_clean)) {\n\t\t\tif (is_branch) {\n\t\t\t\tset_signal_status(current_effect, CLEAN);\n\t\t\t}\n\n\t\t\tif ((flags & RENDER_EFFECT) !== 0) {\n\t\t\t\tif (!is_branch && check_dirtiness(current_effect)) {\n\t\t\t\t\texecute_effect(current_effect);\n\t\t\t\t\t// Child might have been mutated since running the effect\n\t\t\t\t\tchild = current_effect.first;\n\t\t\t\t}\n\n\t\t\t\tif (child !== null) {\n\t\t\t\t\tcurrent_effect = child;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if ((flags & EFFECT) !== 0) {\n\t\t\t\tif (is_branch || is_clean) {\n\t\t\t\t\tif (child !== null) {\n\t\t\t\t\t\tcurrent_effect = child;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teffects.push(current_effect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar sibling = current_effect.next;\n\n\t\tif (sibling === null) {\n\t\t\tlet parent = current_effect.parent;\n\n\t\t\twhile (parent !== null) {\n\t\t\t\tif (effect === parent) {\n\t\t\t\t\tbreak main_loop;\n\t\t\t\t}\n\t\t\t\tvar parent_sibling = parent.next;\n\t\t\t\tif (parent_sibling !== null) {\n\t\t\t\t\tcurrent_effect = parent_sibling;\n\t\t\t\t\tcontinue main_loop;\n\t\t\t\t}\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t}\n\n\t\tcurrent_effect = sibling;\n\t}\n\n\t// We might be dealing with many effects here, far more than can be spread into\n\t// an array push call (callstack overflow). So let's deal with each effect in a loop.\n\tfor (var i = 0; i < effects.length; i++) {\n\t\tchild = effects[i];\n\t\tcollected_effects.push(child);\n\t\tprocess_effects(child, collected_effects);\n\t}\n}\n\n/**\n * Internal version of `flushSync` with the option to not flush previous effects.\n * Returns the result of the passed function, if given.\n * @param {() => any} [fn]\n * @param {boolean} [flush_previous]\n * @returns {any}\n */\nexport function flush_sync(fn, flush_previous = true) {\n\tvar previous_scheduler_mode = current_scheduler_mode;\n\tvar previous_queued_root_effects = current_queued_root_effects;\n\n\ttry {\n\t\tinfinite_loop_guard();\n\n\t\t/** @type {import('#client').Effect[]} */\n\t\tconst root_effects = [];\n\n\t\tcurrent_scheduler_mode = FLUSH_SYNC;\n\t\tcurrent_queued_root_effects = root_effects;\n\t\tis_micro_task_queued = false;\n\n\t\tif (flush_previous) {\n\t\t\tflush_queued_root_effects(previous_queued_root_effects);\n\t\t}\n\n\t\tvar result = fn?.();\n\n\t\tflush_tasks();\n\t\tif (current_queued_root_effects.length > 0 || root_effects.length > 0) {\n\t\t\tflush_sync();\n\t\t}\n\n\t\tflush_count = 0;\n\n\t\treturn result;\n\t} finally {\n\t\tcurrent_scheduler_mode = previous_scheduler_mode;\n\t\tcurrent_queued_root_effects = previous_queued_root_effects;\n\t}\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flush_sync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflush_sync();\n}\n\n/**\n * @template V\n * @param {import('#client').Value<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\tconst flags = signal.f;\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn signal.v;\n\t}\n\n\tif (is_signals_recorded) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current reaction signal.\n\tif (current_reaction !== null) {\n\t\tconst unowned = (current_reaction.f & UNOWNED) !== 0;\n\t\tconst dependencies = current_reaction.deps;\n\t\tif (\n\t\t\tcurrent_dependencies === null &&\n\t\t\tdependencies !== null &&\n\t\t\tdependencies[current_dependencies_index] === signal &&\n\t\t\t!(unowned && current_effect !== null)\n\t\t) {\n\t\t\tcurrent_dependencies_index++;\n\t\t} else if (\n\t\t\tdependencies === null ||\n\t\t\tcurrent_dependencies_index === 0 ||\n\t\t\tdependencies[current_dependencies_index - 1] !== signal\n\t\t) {\n\t\t\tif (current_dependencies === null) {\n\t\t\t\tcurrent_dependencies = [signal];\n\t\t\t} else if (current_dependencies[current_dependencies.length - 1] !== signal) {\n\t\t\t\tcurrent_dependencies.push(signal);\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tcurrent_untracked_writes !== null &&\n\t\t\tcurrent_effect !== null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\t(current_effect.f & BRANCH_EFFECT) === 0 &&\n\t\t\tcurrent_untracked_writes.includes(signal)\n\t\t) {\n\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\tschedule_effect(current_effect);\n\t\t}\n\t}\n\n\tif (\n\t\t(flags & DERIVED) !== 0 &&\n\t\tcheck_dirtiness(/** @type {import('#client').Derived} */ (signal))\n\t) {\n\t\tupdate_derived(/** @type {import('#client').Derived} **/ (signal));\n\t}\n\n\treturn signal.v;\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n */\nexport function invalidate_inner_signals(fn) {\n\tvar previous_is_signals_recorded = is_signals_recorded;\n\tvar previous_captured_signals = captured_signals;\n\tis_signals_recorded = true;\n\tcaptured_signals = new Set();\n\tvar captured = captured_signals;\n\tvar signal;\n\ttry {\n\t\tuntrack(fn);\n\t} finally {\n\t\tis_signals_recorded = previous_is_signals_recorded;\n\t\tif (is_signals_recorded) {\n\t\t\tfor (signal of captured_signals) {\n\t\t\t\tprevious_captured_signals.add(signal);\n\t\t\t}\n\t\t}\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\tfor (signal of captured) {\n\t\t// Go one level up because derived signals created as part of props in legacy mode\n\t\tif ((signal.f & LEGACY_DERIVED_PROP) !== 0) {\n\t\t\tfor (const dep of /** @type {import('#client').Derived} */ (signal).deps || []) {\n\t\t\t\tif ((dep.f & DERIVED) === 0) {\n\t\t\t\t\tmutate(dep, null /* doesnt matter */);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmutate(signal, null /* doesnt matter */);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Value} signal\n * @param {number} to_status should be DIRTY or MAYBE_DIRTY\n * @param {boolean} force_schedule\n * @returns {void}\n */\nexport function mark_reactions(signal, to_status, force_schedule) {\n\tvar reactions = signal.reactions;\n\tif (reactions === null) return;\n\n\tvar runes = is_runes();\n\tvar length = reactions.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar reaction = reactions[i];\n\t\tvar flags = reaction.f;\n\n\t\tif (DEV && (flags & INSPECT_EFFECT) !== 0) {\n\t\t\tinspect_effects.add(reaction);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// We skip any effects that are already dirty. Additionally, we also\n\t\t// skip if the reaction is the same as the current effect (except if we're not in runes or we\n\t\t// are in force schedule mode).\n\t\tif ((flags & DIRTY) !== 0 || ((!force_schedule || !runes) && reaction === current_effect)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_signal_status(reaction, to_status);\n\n\t\t// If the signal is not clean, then skip over it – with the exception of unowned signals that\n\t\t// are already maybe dirty. Unowned signals might be dirty because they are not captured as part of an\n\t\t// effect.\n\t\tvar maybe_dirty = (flags & MAYBE_DIRTY) !== 0;\n\t\tvar unowned = (flags & UNOWNED) !== 0;\n\n\t\tif ((flags & CLEAN) !== 0 || (maybe_dirty && unowned)) {\n\t\t\tif ((reaction.f & DERIVED) !== 0) {\n\t\t\t\tmark_reactions(\n\t\t\t\t\t/** @type {import('#client').Derived} */ (reaction),\n\t\t\t\t\tMAYBE_DIRTY,\n\t\t\t\t\tforce_schedule\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tschedule_effect(/** @type {import('#client').Effect} */ (reaction));\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Use `untrack` to prevent something from being treated as an `$effect`/`$derived` dependency.\n *\n * https://svelte-5-preview.vercel.app/docs/functions#untrack\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tconst previous_reaction = current_reaction;\n\ttry {\n\t\tcurrent_reaction = null;\n\t\treturn fn();\n\t} finally {\n\t\tcurrent_reaction = previous_reaction;\n\t}\n}\n\nconst STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n\n/**\n * @param {import('#client').Signal} signal\n * @param {number} status\n * @returns {void}\n */\nexport function set_signal_status(signal, status) {\n\tsignal.f = (signal.f & STATUS_MASK) | status;\n}\n\n/**\n * @template V\n * @param {V | import('#client').Value<V>} val\n * @returns {val is import('#client').Value<V>}\n */\nexport function is_signal(val) {\n\treturn (\n\t\ttypeof val === 'object' &&\n\t\tval !== null &&\n\t\ttypeof (/** @type {import('#client').Value<V>} */ (val).f) === 'number'\n\t);\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map('getContext');\n\tconst result = /** @type {T} */ (context_map.get(key));\n\n\tif (DEV) {\n\t\tconst fn = /** @type {import('#client').ComponentContext} */ (current_component_context)\n\t\t\t.function;\n\t\tif (fn) {\n\t\t\tadd_owner(result, fn, true);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tconst context_map = get_or_init_context_map('setContext');\n\tcontext_map.set(key, context);\n\treturn context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\tconst context_map = get_or_init_context_map('hasContext');\n\treturn context_map.has(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\tconst context_map = get_or_init_context_map('getAllContexts');\n\n\tif (DEV) {\n\t\tconst fn = current_component_context?.function;\n\t\tif (fn) {\n\t\t\tfor (const value of context_map.values()) {\n\t\t\t\tadd_owner(value, fn, true);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn /** @type {T} */ (context_map);\n}\n\n/**\n * @param {string} name\n * @returns {Map<unknown, unknown>}\n */\nfunction get_or_init_context_map(name) {\n\tif (current_component_context === null) {\n\t\tlifecycle_outside_component(name);\n\t}\n\n\treturn (current_component_context.c ??= new Map(\n\t\tget_parent_context(current_component_context) || undefined\n\t));\n}\n\n/**\n * @param {import('#client').ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\treturn null;\n}\n\n/**\n * @param {import('#client').Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update(signal, d = 1) {\n\tvar value = +get(signal);\n\tset(signal, value + d);\n\treturn value;\n}\n\n/**\n * @param {import('#client').Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre(signal, d = 1) {\n\treturn set(signal, +get(signal) + d);\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\tobj = { ...obj };\n\tlet key;\n\tfor (key of keys) {\n\t\tdelete obj[key];\n\t}\n\treturn obj;\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {() => V} fallback lazy because could contain side effects\n * @returns {V}\n */\nexport function value_or_fallback(value, fallback) {\n\treturn value === undefined ? fallback() : value;\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {() => Promise<V>} fallback lazy because could contain side effects\n * @returns {Promise<V>}\n */\nexport async function value_or_fallback_async(value, fallback) {\n\treturn value === undefined ? fallback() : value;\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {any} runes\n * @param {Function} [fn]\n * @returns {void}\n */\nexport function push(props, runes = false, fn) {\n\tcurrent_component_context = {\n\t\tp: current_component_context,\n\t\tc: null,\n\t\te: null,\n\t\tm: false,\n\t\ts: props,\n\t\tx: null,\n\t\tl: null\n\t};\n\n\tif (!runes) {\n\t\tcurrent_component_context.l = {\n\t\t\ts: null,\n\t\t\tu: null,\n\t\t\tr1: [],\n\t\t\tr2: source(false)\n\t\t};\n\t}\n\n\tif (DEV) {\n\t\t// component function\n\t\tcurrent_component_context.function = fn;\n\t\tdev_current_component_function = fn;\n\t}\n}\n\n/**\n * @template {Record<string, any>} T\n * @param {T} [component]\n * @returns {T}\n */\nexport function pop(component) {\n\tconst context_stack_item = current_component_context;\n\tif (context_stack_item !== null) {\n\t\tif (component !== undefined) {\n\t\t\tcontext_stack_item.x = component;\n\t\t}\n\t\tconst effects = context_stack_item.e;\n\t\tif (effects !== null) {\n\t\t\tcontext_stack_item.e = null;\n\t\t\tfor (var i = 0; i < effects.length; i++) {\n\t\t\t\teffect(effects[i]);\n\t\t\t}\n\t\t}\n\t\tcurrent_component_context = context_stack_item.p;\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = context_stack_item.p?.function ?? null;\n\t\t}\n\t\tcontext_stack_item.m = true;\n\t}\n\t// Micro-optimization: Don't set .a above to the empty object\n\t// so it can be garbage-collected when the return here is unused\n\treturn component || /** @type {T} */ ({});\n}\n\n/**\n * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.\n * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).\n * @param {any} value\n * @returns {void}\n */\nexport function deep_read_state(value) {\n\tif (typeof value !== 'object' || !value || value instanceof EventTarget) {\n\t\treturn;\n\t}\n\n\tif (STATE_SYMBOL in value) {\n\t\tdeep_read(value);\n\t} else if (!Array.isArray(value)) {\n\t\tfor (let key in value) {\n\t\t\tconst prop = value[key];\n\t\t\tif (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {\n\t\t\t\tdeep_read(prop);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Deeply traverse an object and read all its properties\n * so that they're all reactive in case this is `$state`\n * @param {any} value\n * @param {Set<any>} visited\n * @returns {void}\n */\nexport function deep_read(value, visited = new Set()) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t// We don't want to traverse DOM elements\n\t\t!(value instanceof EventTarget) &&\n\t\t!visited.has(value)\n\t) {\n\t\tvisited.add(value);\n\t\t// When working with a possible ReactiveDate, this\n\t\t// will ensure we capture changes to it.\n\t\tif (value instanceof Date) {\n\t\t\tvalue.getTime();\n\t\t}\n\t\tfor (let key in value) {\n\t\t\ttry {\n\t\t\t\tdeep_read(value[key], visited);\n\t\t\t} catch (e) {\n\t\t\t\t// continue\n\t\t\t}\n\t\t}\n\t\tconst proto = get_prototype_of(value);\n\t\tif (\n\t\t\tproto !== Object.prototype &&\n\t\t\tproto !== Array.prototype &&\n\t\t\tproto !== Map.prototype &&\n\t\t\tproto !== Set.prototype &&\n\t\t\tproto !== Date.prototype\n\t\t) {\n\t\t\tconst descriptors = get_descriptors(proto);\n\t\t\tfor (let key in descriptors) {\n\t\t\t\tconst get = descriptors[key].get;\n\t\t\t\tif (get) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tget.call(value);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {V | import('#client').Value<V>} value\n * @returns {V}\n */\nexport function unwrap(value) {\n\tif (is_signal(value)) {\n\t\t// @ts-ignore\n\t\treturn get(value);\n\t}\n\t// @ts-ignore\n\treturn value;\n}\n\nif (DEV) {\n\t/**\n\t * @param {string} rune\n\t */\n\tfunction throw_rune_error(rune) {\n\t\tif (!(rune in globalThis)) {\n\t\t\t// TODO if people start adjusting the \"this can contain runes\" config through v-p-s more, adjust this message\n\t\t\t/** @type {any} */\n\t\t\tlet value; // let's hope noone modifies this global, but belts and braces\n\t\t\tObject.defineProperty(globalThis, rune, {\n\t\t\t\tconfigurable: true,\n\t\t\t\t// eslint-disable-next-line getter-return\n\t\t\t\tget: () => {\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\n\t\t\t\t\te.rune_outside_svelte(rune);\n\t\t\t\t},\n\t\t\t\tset: (v) => {\n\t\t\t\t\tvalue = v;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tthrow_rune_error('$state');\n\tthrow_rune_error('$effect');\n\tthrow_rune_error('$derived');\n\tthrow_rune_error('$inspect');\n\tthrow_rune_error('$props');\n\tthrow_rune_error('$bindable');\n}\n\n/**\n * Expects a value that was wrapped with `freeze` and makes it frozen in DEV.\n * @template T\n * @param {T} value\n * @returns {Readonly<T>}\n */\nexport function freeze(value) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue != null &&\n\t\t!is_frozen(value) &&\n\t\t!(STATE_FROZEN_SYMBOL in value)\n\t) {\n\t\t// If the object is already proxified, then snapshot the value\n\t\tif (STATE_SYMBOL in value) {\n\t\t\tvalue = snapshot(value);\n\t\t}\n\t\tdefine_property(value, STATE_FROZEN_SYMBOL, {\n\t\t\tvalue: true,\n\t\t\twritable: true,\n\t\t\tenumerable: false\n\t\t});\n\t\t// Freeze the object in DEV\n\t\tif (DEV) {\n\t\t\tobject_freeze(value);\n\t\t}\n\t}\n\treturn value;\n}\n"],"names":["is_array","array_from","is_frozen","define_property","get_descriptor","object_prototype","array_prototype","get_prototype_of","DERIVED","EFFECT","RENDER_EFFECT","BLOCK_EFFECT","BRANCH_EFFECT","ROOT_EFFECT","UNOWNED","DISCONNECTED","CLEAN","DIRTY","MAYBE_DIRTY","INERT","DESTROYED","EFFECT_RAN","EFFECT_TRANSPARENT","LEGACY_DERIVED_PROP","STATE_SYMBOL","STATE_FROZEN_SYMBOL","LOADING_ATTR_SYMBOL","equals","value","safe_not_equal","a","b","safe_equals","EACH_ITEM_REACTIVE","EACH_INDEX_REACTIVE","EACH_KEYED","EACH_IS_CONTROLLED","EACH_IS_ANIMATED","EACH_IS_STRICT_EQUALS","PROPS_IS_IMMUTABLE","PROPS_IS_RUNES","PROPS_IS_UPDATED","PROPS_IS_LAZY_INITIAL","TEMPLATE_FRAGMENT","TEMPLATE_USE_IMPORT_NODE","HYDRATION_START","HYDRATION_END","HYDRATION_ANCHOR","HYDRATION_END_ELSE","HYDRATION_ERROR","UNINITIALIZED","PassiveDelegatedEvents","effect_in_teardown","rune","effect_in_unowned_derived","effect_orphan","effect_update_depth_exceeded","hydration_failed","props_invalid_value","key","state_unsafe_mutation","source","v","mutable_source","initial_value","_a","s","current_component_context","set","initialized","current_reaction","is_runes","e.state_unsafe_mutation","increment_version","mark_reactions","current_effect","current_dependencies","set_signal_status","schedule_effect","current_untracked_writes","set_current_untracked_writes","create_fragment_from_html","html","elem","remove","current","i","node","validate_effect","e.effect_orphan","e.effect_in_unowned_derived","is_destroying_effect","e.effect_in_teardown","push_effect","effect","parent_effect","parent_last","create_effect","type","fn","sync","is_root","previously_flushing_effect","is_flushing_effect","set_is_flushing_effect","execute_effect","inert","user_effect","defer","context","signal","user_pre_effect","render_effect","effect_root","destroy_effect","template_effect","block","flags","branch","execute_effect_teardown","teardown","previously_destroying_effect","previous_reaction","set_is_destroying_effect","set_current_reaction","remove_dom","dom","destroy_effect_children","remove_reactions","transition","parent","unlink_effect","prev","next","pause_effect","callback","transitions","pause_children","run_out_transitions","remaining","check","local","child","sibling","transparent","resume_effect","resume_children","check_dirtiness","noop","is_promise","run_all","arr","is_micro_task_queued","current_queued_micro_tasks","process_micro_tasks","tasks","queue_micro_task","flush_tasks","derived","current_derived","derived_safe_equal","destroy_derived_children","deriveds","destroy_derived","update_derived","execute_reaction_fn","status","current_skip_reaction","FLUSH_MICROTASK","FLUSH_SYNC","current_scheduler_mode","current_queued_root_effects","flush_count","reaction","set_current_effect","current_dependencies_index","current_version","set_current_component_context","is_dirty","is_unowned","is_disconnected","dependencies","length","reactions","dependency","version","handle_error","error","component_context","previous_dependencies","previous_dependencies_index","previous_untracked_writes","previous_skip_reaction","res","deps_length","full_current_dependencies","full_current_dependencies_set","remove_reaction","reactions_length","index","start_index","active_dependencies","previous_effect","previous_component_context","infinite_loop_guard","e.effect_update_depth_exceeded","flush_queued_root_effects","root_effects","flush_queued_effects","collected_effects","process_effects","effects","process_deferred","previous_queued_root_effects","main_loop","is_active","is_branch","is_clean","parent_sibling","flush_sync","flush_previous","previous_scheduler_mode","result","tick","get","unowned","to_status","force_schedule","runes","maybe_dirty","untrack","STATUS_MASK","is_signal","val","value_or_fallback","fallback","push","props","pop","component","context_stack_item","unwrap"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11]}