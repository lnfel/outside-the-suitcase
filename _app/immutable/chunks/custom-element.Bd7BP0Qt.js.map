{"version":3,"file":"custom-element.Bd7BP0Qt.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/utils.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/constants.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/reactivity/equality.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/constants.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/errors.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/reactivity/sources.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/reconciler.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/reactivity/effects.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/warnings.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/proxy.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/shared/utils.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/task.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/reactivity/deriveds.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/runtime.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/hydration.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/operations.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/elements/events.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/blocks/svelte-head.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/render.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/template.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/legacy/legacy-client.js","../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/elements/custom-element.js"],"sourcesContent":["// Store the references to globals in case someone tries to monkey patch these, causing the below\n// to de-opt (this occurs often when using popular extensions).\nexport var is_array = Array.isArray;\nexport var array_from = Array.from;\nexport var object_keys = Object.keys;\nexport var object_assign = Object.assign;\nexport var is_frozen = Object.isFrozen;\nexport var object_freeze = Object.freeze;\nexport var define_property = Object.defineProperty;\nexport var get_descriptor = Object.getOwnPropertyDescriptor;\nexport var get_descriptors = Object.getOwnPropertyDescriptors;\nexport var object_prototype = Object.prototype;\nexport var array_prototype = Array.prototype;\nexport var get_prototype_of = Object.getPrototypeOf;\n\n/** @type {Map<any, any>} */\nvar map_prototype = Map.prototype;\nvar map_set_method = map_prototype.set;\nvar map_get_method = map_prototype.get;\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V>} map\n * @param {K} key\n * @param {V} value\n */\nexport function map_set(map, key, value) {\n\tmap_set_method.call(map, key, value);\n}\n\n/**\n * @template K\n * @template V\n * @param {Map<K, V>} map\n * @param {K} key\n * @return {V}\n */\nexport function map_get(map, key) {\n\treturn map_get_method.call(map, key);\n}\n\n/**\n * @param {any} thing\n * @returns {thing is Function}\n */\nexport function is_function(thing) {\n\treturn typeof thing === 'function';\n}\n","export const DERIVED = 1 << 1;\nexport const EFFECT = 1 << 2;\nexport const RENDER_EFFECT = 1 << 3;\nexport const BLOCK_EFFECT = 1 << 4;\nexport const BRANCH_EFFECT = 1 << 5;\nexport const ROOT_EFFECT = 1 << 6;\nexport const UNOWNED = 1 << 7;\nexport const DISCONNECTED = 1 << 8;\nexport const CLEAN = 1 << 9;\nexport const DIRTY = 1 << 10;\nexport const MAYBE_DIRTY = 1 << 11;\nexport const INERT = 1 << 12;\nexport const DESTROYED = 1 << 13;\nexport const EFFECT_RAN = 1 << 14;\n/** 'Transparent' effects do not create a transition boundary */\nexport const EFFECT_TRANSPARENT = 1 << 15;\n/** Svelte 4 legacy mode props need to be handled with deriveds and be recognized elsewhere, hence the dedicated flag */\nexport const LEGACY_DERIVED_PROP = 1 << 16;\nexport const INSPECT_EFFECT = 1 << 17;\n\nexport const STATE_SYMBOL = Symbol('$state');\nexport const STATE_FROZEN_SYMBOL = Symbol('$state.frozen');\nexport const LOADING_ATTR_SYMBOL = Symbol('');\n","/** @type {import('#client').Equals} */\nexport function equals(value) {\n\treturn value === this.v;\n}\n\n/**\n * @param {unknown} a\n * @param {unknown} b\n * @returns {boolean}\n */\nexport function safe_not_equal(a, b) {\n\treturn a != a\n\t\t? b == b\n\t\t: a !== b || (a !== null && typeof a === 'object') || typeof a === 'function';\n}\n\n/** @type {import('#client').Equals} */\nexport function safe_equals(value) {\n\treturn !safe_not_equal(value, this.v);\n}\n","export const EACH_ITEM_REACTIVE = 1;\nexport const EACH_INDEX_REACTIVE = 1 << 1;\nexport const EACH_KEYED = 1 << 2;\n\n/** See EachBlock interface metadata.is_controlled for an explanation what this is */\nexport const EACH_IS_CONTROLLED = 1 << 3;\nexport const EACH_IS_ANIMATED = 1 << 4;\nexport const EACH_IS_STRICT_EQUALS = 1 << 6;\n\nexport const PROPS_IS_IMMUTABLE = 1;\nexport const PROPS_IS_RUNES = 1 << 1;\nexport const PROPS_IS_UPDATED = 1 << 2;\nexport const PROPS_IS_LAZY_INITIAL = 1 << 3;\n\nexport const TRANSITION_IN = 1;\nexport const TRANSITION_OUT = 1 << 1;\nexport const TRANSITION_GLOBAL = 1 << 2;\n\nexport const TEMPLATE_FRAGMENT = 1;\nexport const TEMPLATE_USE_IMPORT_NODE = 1 << 1;\n\nexport const HYDRATION_START = '[';\nexport const HYDRATION_END = ']';\nexport const HYDRATION_ANCHOR = '';\nexport const HYDRATION_END_ELSE = `${HYDRATION_END}!`; // used to indicate that an `{:else}...` block was rendered\nexport const HYDRATION_ERROR = {};\n\nexport const ELEMENT_IS_NAMESPACED = 1;\nexport const ELEMENT_PRESERVE_ATTRIBUTE_CASE = 1 << 1;\n\nexport const UNINITIALIZED = Symbol();\n\n/** List of elements that require raw contents and should not have SSR comments put in them */\nexport const RawTextElements = ['textarea', 'script', 'style', 'title'];\n\n/** List of Element events that will be delegated */\nexport const DelegatedEvents = [\n\t'beforeinput',\n\t'click',\n\t'change',\n\t'dblclick',\n\t'contextmenu',\n\t'focusin',\n\t'focusout',\n\t'input',\n\t'keydown',\n\t'keyup',\n\t'mousedown',\n\t'mousemove',\n\t'mouseout',\n\t'mouseover',\n\t'mouseup',\n\t'pointerdown',\n\t'pointermove',\n\t'pointerout',\n\t'pointerover',\n\t'pointerup',\n\t'touchend',\n\t'touchmove',\n\t'touchstart'\n];\n\n/** List of Element events that will be delegated and are passive */\nexport const PassiveDelegatedEvents = ['touchstart', 'touchmove', 'touchend'];\n\n/**\n * @type {Record<string, string>}\n * List of attribute names that should be aliased to their property names\n * because they behave differently between setting them as an attribute and\n * setting them as a property.\n */\nexport const AttributeAliases = {\n\t// no `class: 'className'` because we handle that separately\n\tformnovalidate: 'formNoValidate',\n\tismap: 'isMap',\n\tnomodule: 'noModule',\n\tplaysinline: 'playsInline',\n\treadonly: 'readOnly'\n};\n\n/**\n * Attributes that are boolean, i.e. they are present or not present.\n */\nexport const DOMBooleanAttributes = [\n\t'allowfullscreen',\n\t'async',\n\t'autofocus',\n\t'autoplay',\n\t'checked',\n\t'controls',\n\t'default',\n\t'disabled',\n\t'formnovalidate',\n\t'hidden',\n\t'indeterminate',\n\t'ismap',\n\t'loop',\n\t'multiple',\n\t'muted',\n\t'nomodule',\n\t'novalidate',\n\t'open',\n\t'playsinline',\n\t'readonly',\n\t'required',\n\t'reversed',\n\t'seamless',\n\t'selected',\n\t'webkitdirectory'\n];\n\nexport const namespace_svg = 'http://www.w3.org/2000/svg';\nexport const namespace_mathml = 'http://www.w3.org/1998/Math/MathML';\n\n// while `input` is also an interactive element, it is never moved by the browser, so we don't need to check for it\nexport const interactive_elements = new Set([\n\t'a',\n\t'button',\n\t'iframe',\n\t'embed',\n\t'select',\n\t'textarea'\n]);\n\nexport const disallowed_paragraph_contents = [\n\t'address',\n\t'article',\n\t'aside',\n\t'blockquote',\n\t'details',\n\t'div',\n\t'dl',\n\t'fieldset',\n\t'figcapture',\n\t'figure',\n\t'footer',\n\t'form',\n\t'h1',\n\t'h2',\n\t'h3',\n\t'h4',\n\t'h5',\n\t'h6',\n\t'header',\n\t'hr',\n\t'menu',\n\t'nav',\n\t'ol',\n\t'pre',\n\t'section',\n\t'table',\n\t'ul',\n\t'p'\n];\n\n// https://html.spec.whatwg.org/multipage/syntax.html#generate-implied-end-tags\nconst implied_end_tags = ['dd', 'dt', 'li', 'option', 'optgroup', 'p', 'rp', 'rt'];\n\n/**\n * @param {string} tag\n * @param {string} parent_tag\n * @returns {boolean}\n */\nexport function is_tag_valid_with_parent(tag, parent_tag) {\n\t// First, let's check if we're in an unusual parsing mode...\n\tswitch (parent_tag) {\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect\n\t\tcase 'select':\n\t\t\treturn (\n\t\t\t\ttag === 'option' ||\n\t\t\t\ttag === 'optgroup' ||\n\t\t\t\ttag === '#text' ||\n\t\t\t\ttag === 'hr' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\tcase 'optgroup':\n\t\t\treturn tag === 'option' || tag === '#text';\n\t\t// Strictly speaking, seeing an <option> doesn't mean we're in a <select>\n\t\t// but\n\t\tcase 'option':\n\t\t\treturn tag === '#text';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption\n\t\t// No special behavior since these rules fall back to \"in body\" mode for\n\t\t// all except special table nodes which cause bad parsing behavior anyway.\n\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr\n\t\tcase 'tr':\n\t\t\treturn (\n\t\t\t\ttag === 'th' || tag === 'td' || tag === 'style' || tag === 'script' || tag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody\n\t\tcase 'tbody':\n\t\tcase 'thead':\n\t\tcase 'tfoot':\n\t\t\treturn tag === 'tr' || tag === 'style' || tag === 'script' || tag === 'template';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup\n\t\tcase 'colgroup':\n\t\t\treturn tag === 'col' || tag === 'template';\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable\n\t\tcase 'table':\n\t\t\treturn (\n\t\t\t\ttag === 'caption' ||\n\t\t\t\ttag === 'colgroup' ||\n\t\t\t\ttag === 'tbody' ||\n\t\t\t\ttag === 'tfoot' ||\n\t\t\t\ttag === 'thead' ||\n\t\t\t\ttag === 'style' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead\n\t\tcase 'head':\n\t\t\treturn (\n\t\t\t\ttag === 'base' ||\n\t\t\t\ttag === 'basefont' ||\n\t\t\t\ttag === 'bgsound' ||\n\t\t\t\ttag === 'link' ||\n\t\t\t\ttag === 'meta' ||\n\t\t\t\ttag === 'title' ||\n\t\t\t\ttag === 'noscript' ||\n\t\t\t\ttag === 'noframes' ||\n\t\t\t\ttag === 'style' ||\n\t\t\t\ttag === 'script' ||\n\t\t\t\ttag === 'template'\n\t\t\t);\n\t\t// https://html.spec.whatwg.org/multipage/semantics.html#the-html-element\n\t\tcase 'html':\n\t\t\treturn tag === 'head' || tag === 'body' || tag === 'frameset';\n\t\tcase 'frameset':\n\t\t\treturn tag === 'frame';\n\t\tcase '#document':\n\t\t\treturn tag === 'html';\n\t}\n\n\t// Probably in the \"in body\" parsing mode, so we outlaw only tag combos\n\t// where the parsing rules cause implicit opens or closes to be added.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inbody\n\tswitch (tag) {\n\t\tcase 'h1':\n\t\tcase 'h2':\n\t\tcase 'h3':\n\t\tcase 'h4':\n\t\tcase 'h5':\n\t\tcase 'h6':\n\t\t\treturn (\n\t\t\t\tparent_tag !== 'h1' &&\n\t\t\t\tparent_tag !== 'h2' &&\n\t\t\t\tparent_tag !== 'h3' &&\n\t\t\t\tparent_tag !== 'h4' &&\n\t\t\t\tparent_tag !== 'h5' &&\n\t\t\t\tparent_tag !== 'h6'\n\t\t\t);\n\n\t\tcase 'rp':\n\t\tcase 'rt':\n\t\t\treturn implied_end_tags.indexOf(parent_tag) === -1;\n\n\t\tcase 'body':\n\t\tcase 'caption':\n\t\tcase 'col':\n\t\tcase 'colgroup':\n\t\tcase 'frameset':\n\t\tcase 'frame':\n\t\tcase 'head':\n\t\tcase 'html':\n\t\tcase 'tbody':\n\t\tcase 'td':\n\t\tcase 'tfoot':\n\t\tcase 'th':\n\t\tcase 'thead':\n\t\tcase 'tr':\n\t\t\t// These tags are only valid with a few parents that have special child\n\t\t\t// parsing rules -- if we're down here, then none of those matched and\n\t\t\t// so we allow it only if we don't know what the parent is, as all other\n\t\t\t// cases are invalid.\n\t\t\treturn parent_tag == null;\n\t}\n\n\treturn true;\n}\n\n/**\n * @param {string} name\n * @param {\"include-on\" | \"exclude-on\"} [mode] - wether if name starts with `on` or `on` is excluded at this point\n */\nexport function is_capture_event(name, mode = 'exclude-on') {\n\tif (!name.endsWith('capture')) {\n\t\treturn false;\n\t}\n\treturn mode == 'exclude-on'\n\t\t? name !== 'gotpointercapture' && name !== 'lostpointercapture'\n\t\t: name !== 'ongotpointercapture' && name !== 'onlostpointercapture';\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\n/**\n * Using `bind:value` together with a checkbox input is not allowed. Use `bind:checked` instead\n * @returns {never}\n */\nexport function bind_invalid_checkbox_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_checkbox_value\\nUsing \\`bind:value\\` together with a checkbox input is not allowed. Use \\`bind:checked\\` instead`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_checkbox_value\");\n\t}\n}\n\n/**\n * Component %component% has an export named `%key%` that a consumer component is trying to access using `bind:%key%`, which is disallowed. Instead, use `bind:this` (e.g. `<%name% bind:this={component} />`) and then access the property on the bound component instance (e.g. `component.%key%`)\n * @param {string} component\n * @param {string} key\n * @param {string} name\n * @returns {never}\n */\nexport function bind_invalid_export(component, key, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_invalid_export\\nComponent ${component} has an export named \\`${key}\\` that a consumer component is trying to access using \\`bind:${key}\\`, which is disallowed. Instead, use \\`bind:this\\` (e.g. \\`<${name} bind:this={component} />\\`) and then access the property on the bound component instance (e.g. \\`component.${key}\\`)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_invalid_export\");\n\t}\n}\n\n/**\n * A component is attempting to bind to a non-bindable property `%key%` belonging to %component% (i.e. `<%name% bind:%key%={...}>`). To mark a property as bindable: `let { %key% = $bindable() } = $props()`\n * @param {string} key\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function bind_not_bindable(key, component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`bind_not_bindable\\nA component is attempting to bind to a non-bindable property \\`${key}\\` belonging to ${component} (i.e. \\`<${name} bind:${key}={...}>\\`). To mark a property as bindable: \\`let { ${key} = $bindable() } = $props()\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"bind_not_bindable\");\n\t}\n}\n\n/**\n * %parent% called `%method%` on an instance of %component%, which is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information\n * @param {string} parent\n * @param {string} method\n * @param {string} component\n * @returns {never}\n */\nexport function component_api_changed(parent, method, component) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_changed\\n${parent} called \\`${method}\\` on an instance of ${component}, which is no longer valid in Svelte 5. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_changed\");\n\t}\n}\n\n/**\n * Attempted to instantiate %component% with `new %name%`, which is no longer valid in Svelte 5. If this component is not under your control, set the `legacy.componentApi` compiler option to keep it working. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information\n * @param {string} component\n * @param {string} name\n * @returns {never}\n */\nexport function component_api_invalid_new(component, name) {\n\tif (DEV) {\n\t\tconst error = new Error(`component_api_invalid_new\\nAttempted to instantiate ${component} with \\`new ${name}\\`, which is no longer valid in Svelte 5. If this component is not under your control, set the \\`legacy.componentApi\\` compiler option to keep it working. See https://svelte-5-preview.vercel.app/docs/breaking-changes#components-are-no-longer-classes for more information`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"component_api_invalid_new\");\n\t}\n}\n\n/**\n * Keyed each block has duplicate key `%value%` at indexes %a% and %b%\n * @param {string} a\n * @param {string} b\n * @param {string | undefined | null} [value]\n * @returns {never}\n */\nexport function each_key_duplicate(a, b, value) {\n\tif (DEV) {\n\t\tconst error = new Error(`each_key_duplicate\\n${value ? `Keyed each block has duplicate key \\`${value}\\` at indexes ${a} and ${b}` : `Keyed each block has duplicate key at indexes ${a} and ${b}`}`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"each_key_duplicate\");\n\t}\n}\n\n/**\n * `%rune%` cannot be used inside an effect cleanup function\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_in_teardown(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_teardown\\n\\`${rune}\\` cannot be used inside an effect cleanup function`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_teardown\");\n\t}\n}\n\n/**\n * Effect cannot be created inside a `$derived` value that was not itself created inside an effect\n * @returns {never}\n */\nexport function effect_in_unowned_derived() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_in_unowned_derived\\nEffect cannot be created inside a \\`$derived\\` value that was not itself created inside an effect`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_in_unowned_derived\");\n\t}\n}\n\n/**\n * `%rune%` can only be used inside an effect (e.g. during component initialisation)\n * @param {string} rune\n * @returns {never}\n */\nexport function effect_orphan(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_orphan\\n\\`${rune}\\` can only be used inside an effect (e.g. during component initialisation)`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_orphan\");\n\t}\n}\n\n/**\n * Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops\n * @returns {never}\n */\nexport function effect_update_depth_exceeded() {\n\tif (DEV) {\n\t\tconst error = new Error(`effect_update_depth_exceeded\\nMaximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"effect_update_depth_exceeded\");\n\t}\n}\n\n/**\n * Failed to hydrate the application\n * @returns {never}\n */\nexport function hydration_failed() {\n\tif (DEV) {\n\t\tconst error = new Error(`hydration_failed\\nFailed to hydrate the application`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"hydration_failed\");\n\t}\n}\n\n/**\n * `%name%(...)` cannot be used in runes mode\n * @param {string} name\n * @returns {never}\n */\nexport function lifecycle_legacy_only(name) {\n\tif (DEV) {\n\t\tconst error = new Error(`lifecycle_legacy_only\\n\\`${name}(...)\\` cannot be used in runes mode`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"lifecycle_legacy_only\");\n\t}\n}\n\n/**\n * Cannot do `bind:%key%={undefined}` when `%key%` has a fallback value\n * @param {string} key\n * @returns {never}\n */\nexport function props_invalid_value(key) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_invalid_value\\nCannot do \\`bind:${key}={undefined}\\` when \\`${key}\\` has a fallback value`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_invalid_value\");\n\t}\n}\n\n/**\n * Rest element properties of `$props()` such as `%property%` are readonly\n * @param {string} property\n * @returns {never}\n */\nexport function props_rest_readonly(property) {\n\tif (DEV) {\n\t\tconst error = new Error(`props_rest_readonly\\nRest element properties of \\`$props()\\` such as \\`${property}\\` are readonly`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"props_rest_readonly\");\n\t}\n}\n\n/**\n * The `%rune%` rune is only available inside `.svelte` and `.svelte.js/ts` files\n * @param {string} rune\n * @returns {never}\n */\nexport function rune_outside_svelte(rune) {\n\tif (DEV) {\n\t\tconst error = new Error(`rune_outside_svelte\\nThe \\`${rune}\\` rune is only available inside \\`.svelte\\` and \\`.svelte.js/ts\\` files`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"rune_outside_svelte\");\n\t}\n}\n\n/**\n * Cannot set prototype of `$state` object\n * @returns {never}\n */\nexport function state_prototype_fixed() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_prototype_fixed\\nCannot set prototype of \\`$state\\` object`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_prototype_fixed\");\n\t}\n}\n\n/**\n * Updating state inside a derived is forbidden. If the value should not be reactive, declare it without `$state`\n * @returns {never}\n */\nexport function state_unsafe_mutation() {\n\tif (DEV) {\n\t\tconst error = new Error(`state_unsafe_mutation\\nUpdating state inside a derived is forbidden. If the value should not be reactive, declare it without \\`$state\\``);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"state_unsafe_mutation\");\n\t}\n}\n\n/**\n * The `this={...}` property of a `<svelte:component>` must be a Svelte component, if defined\n * @returns {never}\n */\nexport function svelte_component_invalid_this_value() {\n\tif (DEV) {\n\t\tconst error = new Error(`svelte_component_invalid_this_value\\nThe \\`this={...}\\` property of a \\`<svelte:component>\\` must be a Svelte component, if defined`);\n\n\t\terror.name = 'Svelte error';\n\t\tthrow error;\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tthrow new Error(\"svelte_component_invalid_this_value\");\n\t}\n}","import { DEV } from 'esm-env';\nimport {\n\tcurrent_component_context,\n\tcurrent_reaction,\n\tcurrent_dependencies,\n\tcurrent_effect,\n\tcurrent_untracked_writes,\n\tget,\n\tis_runes,\n\tmark_reactions,\n\tschedule_effect,\n\tset_current_untracked_writes,\n\tset_signal_status,\n\tuntrack,\n\tincrement_version,\n\texecute_effect,\n\tinspect_effects\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\nimport { CLEAN, DERIVED, DIRTY, BRANCH_EFFECT } from '../constants.js';\nimport { UNINITIALIZED } from '../../../constants.js';\nimport * as e from '../errors.js';\n\n/**\n * @template V\n * @param {V} v\n * @returns {import('#client').Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function source(v) {\n\treturn {\n\t\tf: 0, // TODO ideally we could skip this altogether, but it causes type errors\n\t\tv,\n\t\treactions: null,\n\t\tequals,\n\t\tversion: 0\n\t};\n}\n\n/**\n * @template V\n * @param {V} initial_value\n * @returns {import('#client').Source<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mutable_source(initial_value) {\n\tconst s = source(initial_value);\n\ts.equals = safe_equals;\n\n\t// bind the signal to the component context, in case we need to\n\t// track updates to trigger beforeUpdate/afterUpdate callbacks\n\tif (current_component_context !== null && current_component_context.l !== null) {\n\t\t(current_component_context.l.s ??= []).push(s);\n\t}\n\n\treturn s;\n}\n\n/**\n * @template V\n * @param {import('#client').Value<V>} source\n * @param {V} value\n */\nexport function mutate(source, value) {\n\tset(\n\t\tsource,\n\t\tuntrack(() => get(source))\n\t);\n\treturn value;\n}\n\n/**\n * @template V\n * @param {import('#client').Source<V>} source\n * @param {V} value\n * @returns {V}\n */\nexport function set(source, value) {\n\tvar initialized = source.v !== UNINITIALIZED;\n\n\tif (\n\t\tinitialized &&\n\t\tcurrent_reaction !== null &&\n\t\tis_runes() &&\n\t\t(current_reaction.f & DERIVED) !== 0\n\t) {\n\t\te.state_unsafe_mutation();\n\t}\n\n\tif (!source.equals(value)) {\n\t\tsource.v = value;\n\t\tsource.version = increment_version();\n\n\t\tmark_reactions(source, DIRTY, true);\n\n\t\t// If the current signal is running for the first time, it won't have any\n\t\t// reactions as we only allocate and assign the reactions after the signal\n\t\t// has fully executed. So in the case of ensuring it registers the reaction\n\t\t// properly for itself, we need to ensure the current effect actually gets\n\t\t// scheduled. i.e:\n\t\t//\n\t\t// $effect(() => x++)\n\t\t//\n\t\t// We additionally want to skip this logic when initialising store sources\n\t\tif (\n\t\t\tis_runes() &&\n\t\t\tinitialized &&\n\t\t\tcurrent_effect !== null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\t(current_effect.f & BRANCH_EFFECT) === 0\n\t\t) {\n\t\t\tif (current_dependencies !== null && current_dependencies.includes(source)) {\n\t\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\t\tschedule_effect(current_effect);\n\t\t\t} else {\n\t\t\t\tif (current_untracked_writes === null) {\n\t\t\t\t\tset_current_untracked_writes([source]);\n\t\t\t\t} else {\n\t\t\t\t\tcurrent_untracked_writes.push(source);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (DEV) {\n\t\t\tfor (const effect of inspect_effects) {\n\t\t\t\texecute_effect(effect);\n\t\t\t}\n\n\t\t\tinspect_effects.clear();\n\t\t}\n\t}\n\n\treturn value;\n}\n","import { is_array } from '../utils.js';\n\n/** @param {string} html */\nexport function create_fragment_from_html(html) {\n\tvar elem = document.createElement('template');\n\telem.innerHTML = html;\n\treturn elem.content;\n}\n\n/**\n * @param {import('#client').Dom} current\n */\nexport function remove(current) {\n\tif (is_array(current)) {\n\t\tfor (var i = 0; i < current.length; i++) {\n\t\t\tvar node = current[i];\n\t\t\tif (node.isConnected) {\n\t\t\t\tnode.remove();\n\t\t\t}\n\t\t}\n\t} else if (current.isConnected) {\n\t\tcurrent.remove();\n\t}\n}\n","import {\n\tcheck_dirtiness,\n\tcurrent_component_context,\n\tcurrent_effect,\n\tcurrent_reaction,\n\tdestroy_effect_children,\n\tdev_current_component_function,\n\texecute_effect,\n\tget,\n\tis_destroying_effect,\n\tis_flushing_effect,\n\tremove_reactions,\n\tschedule_effect,\n\tset_current_reaction,\n\tset_is_destroying_effect,\n\tset_is_flushing_effect,\n\tset_signal_status,\n\tuntrack\n} from '../runtime.js';\nimport {\n\tDIRTY,\n\tBRANCH_EFFECT,\n\tRENDER_EFFECT,\n\tEFFECT,\n\tDESTROYED,\n\tINERT,\n\tEFFECT_RAN,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tEFFECT_TRANSPARENT,\n\tDERIVED,\n\tUNOWNED,\n\tCLEAN,\n\tINSPECT_EFFECT\n} from '../constants.js';\nimport { set } from './sources.js';\nimport { remove } from '../dom/reconciler.js';\nimport * as e from '../errors.js';\nimport { DEV } from 'esm-env';\nimport { define_property } from '../utils.js';\n\n/**\n * @param {'$effect' | '$effect.pre' | '$inspect'} rune\n */\nexport function validate_effect(rune) {\n\tif (current_effect === null && current_reaction === null) {\n\t\te.effect_orphan(rune);\n\t}\n\n\tif (current_reaction !== null && (current_reaction.f & UNOWNED) !== 0) {\n\t\te.effect_in_unowned_derived();\n\t}\n\n\tif (is_destroying_effect) {\n\t\te.effect_in_teardown(rune);\n\t}\n}\n\n/**\n * @param {import(\"#client\").Effect} effect\n * @param {import(\"#client\").Reaction} parent_effect\n */\nexport function push_effect(effect, parent_effect) {\n\tvar parent_last = parent_effect.last;\n\tif (parent_last === null) {\n\t\tparent_effect.last = parent_effect.first = effect;\n\t} else {\n\t\tparent_last.next = effect;\n\t\teffect.prev = parent_last;\n\t\tparent_effect.last = effect;\n\t}\n}\n\n/**\n * @param {number} type\n * @param {null | (() => void | (() => void))} fn\n * @param {boolean} sync\n * @returns {import('#client').Effect}\n */\nfunction create_effect(type, fn, sync) {\n\tvar is_root = (type & ROOT_EFFECT) !== 0;\n\n\t/** @type {import('#client').Effect} */\n\tvar effect = {\n\t\tctx: current_component_context,\n\t\tdeps: null,\n\t\tdom: null,\n\t\tf: type | DIRTY,\n\t\tfirst: null,\n\t\tfn,\n\t\tlast: null,\n\t\tnext: null,\n\t\tparent: is_root ? null : current_effect,\n\t\tprev: null,\n\t\tteardown: null,\n\t\ttransitions: null\n\t};\n\n\tif (DEV) {\n\t\teffect.component_function = dev_current_component_function;\n\t}\n\n\tif (sync) {\n\t\tvar previously_flushing_effect = is_flushing_effect;\n\n\t\ttry {\n\t\t\tset_is_flushing_effect(true);\n\t\t\texecute_effect(effect);\n\t\t\teffect.f |= EFFECT_RAN;\n\t\t} finally {\n\t\t\tset_is_flushing_effect(previously_flushing_effect);\n\t\t}\n\t} else if (fn !== null) {\n\t\tschedule_effect(effect);\n\t}\n\n\t// if an effect has no dependencies, no DOM and no teardown function,\n\t// don't bother adding it to the effect tree\n\tvar inert =\n\t\tsync &&\n\t\teffect.deps === null &&\n\t\teffect.first === null &&\n\t\teffect.dom === null &&\n\t\teffect.teardown === null;\n\n\tif (!inert && !is_root) {\n\t\tif (current_effect !== null) {\n\t\t\tpush_effect(effect, current_effect);\n\t\t}\n\n\t\t// if we're in a derived, add the effect there too\n\t\tif (current_reaction !== null && (current_reaction.f & DERIVED) !== 0) {\n\t\t\tpush_effect(effect, current_reaction);\n\t\t}\n\t}\n\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect.tracking()`\n * @returns {boolean}\n */\nexport function effect_tracking() {\n\tif (current_reaction === null) {\n\t\treturn false;\n\t}\n\n\treturn (current_reaction.f & UNOWNED) === 0;\n}\n\n/**\n * @param {() => void} fn\n */\nexport function teardown(fn) {\n\tconst effect = create_effect(RENDER_EFFECT, null, false);\n\tset_signal_status(effect, CLEAN);\n\teffect.teardown = fn;\n\treturn effect;\n}\n\n/**\n * Internal representation of `$effect(...)`\n * @param {() => void | (() => void)} fn\n */\nexport function user_effect(fn) {\n\tvalidate_effect('$effect');\n\n\t// Non-nested `$effect(...)` in a component should be deferred\n\t// until the component is mounted\n\tvar defer =\n\t\tcurrent_effect !== null &&\n\t\t(current_effect.f & RENDER_EFFECT) !== 0 &&\n\t\t// TODO do we actually need this? removing them changes nothing\n\t\tcurrent_component_context !== null &&\n\t\t!current_component_context.m;\n\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect'\n\t\t});\n\t}\n\n\tif (defer) {\n\t\tvar context = /** @type {import('#client').ComponentContext} */ (current_component_context);\n\t\t(context.e ??= []).push(fn);\n\t} else {\n\t\tvar signal = effect(fn);\n\t\treturn signal;\n\t}\n}\n\n/**\n * Internal representation of `$effect.pre(...)`\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function user_pre_effect(fn) {\n\tvalidate_effect('$effect.pre');\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '$effect.pre'\n\t\t});\n\t}\n\treturn render_effect(fn);\n}\n\n/** @param {() => void | (() => void)} fn */\nexport function inspect_effect(fn) {\n\treturn create_effect(INSPECT_EFFECT, fn, true);\n}\n\n/**\n * Internal representation of `$effect.root(...)`\n * @param {() => void | (() => void)} fn\n * @returns {() => void}\n */\nexport function effect_root(fn) {\n\tconst effect = create_effect(ROOT_EFFECT, fn, true);\n\treturn () => {\n\t\tdestroy_effect(effect);\n\t};\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function effect(fn) {\n\treturn create_effect(EFFECT, fn, false);\n}\n\n/**\n * Internal representation of `$: ..`\n * @param {() => any} deps\n * @param {() => void | (() => void)} fn\n */\nexport function legacy_pre_effect(deps, fn) {\n\tvar context = /** @type {import('#client').ComponentContextLegacy} */ (current_component_context);\n\n\t/** @type {{ effect: null | import('#client').Effect, ran: boolean }} */\n\tvar token = { effect: null, ran: false };\n\tcontext.l.r1.push(token);\n\n\ttoken.effect = render_effect(() => {\n\t\tdeps();\n\n\t\t// If this legacy pre effect has already run before the end of the reset, then\n\t\t// bail-out to emulate the same behavior.\n\t\tif (token.ran) return;\n\n\t\ttoken.ran = true;\n\t\tset(context.l.r2, true);\n\t\tuntrack(fn);\n\t});\n}\n\nexport function legacy_pre_effect_reset() {\n\tvar context = /** @type {import('#client').ComponentContextLegacy} */ (current_component_context);\n\n\trender_effect(() => {\n\t\tif (!get(context.l.r2)) return;\n\n\t\t// Run dirty `$:` statements\n\t\tfor (var token of context.l.r1) {\n\t\t\tvar effect = token.effect;\n\n\t\t\tif (check_dirtiness(effect)) {\n\t\t\t\texecute_effect(effect);\n\t\t\t}\n\n\t\t\ttoken.ran = false;\n\t\t}\n\n\t\tcontext.l.r2.v = false; // set directly to avoid rerunning this effect\n\t});\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function render_effect(fn) {\n\treturn create_effect(RENDER_EFFECT, fn, true);\n}\n\n/**\n * @param {() => void | (() => void)} fn\n * @returns {import('#client').Effect}\n */\nexport function template_effect(fn) {\n\tif (DEV) {\n\t\tdefine_property(fn, 'name', {\n\t\t\tvalue: '{expression}'\n\t\t});\n\t}\n\treturn render_effect(fn);\n}\n\n/**\n * @param {(() => void)} fn\n * @param {number} flags\n */\nexport function block(fn, flags = 0) {\n\treturn create_effect(RENDER_EFFECT | BLOCK_EFFECT | flags, fn, true);\n}\n\n/** @param {(() => void)} fn */\nexport function branch(fn) {\n\treturn create_effect(RENDER_EFFECT | BRANCH_EFFECT, fn, true);\n}\n\n/**\n * @param {import(\"#client\").Effect} effect\n */\nexport function execute_effect_teardown(effect) {\n\tvar teardown = effect.teardown;\n\tif (teardown !== null) {\n\t\tconst previously_destroying_effect = is_destroying_effect;\n\t\tconst previous_reaction = current_reaction;\n\t\tset_is_destroying_effect(true);\n\t\tset_current_reaction(null);\n\t\ttry {\n\t\t\tteardown.call(null);\n\t\t} finally {\n\t\t\tset_is_destroying_effect(previously_destroying_effect);\n\t\t\tset_current_reaction(previous_reaction);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @param {boolean} [remove_dom]\n * @returns {void}\n */\nexport function destroy_effect(effect, remove_dom = true) {\n\tvar dom = effect.dom;\n\n\tif (dom !== null && remove_dom) {\n\t\tremove(dom);\n\t}\n\n\tdestroy_effect_children(effect, remove_dom);\n\tremove_reactions(effect, 0);\n\tset_signal_status(effect, DESTROYED);\n\n\tif (effect.transitions) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\ttransition.stop();\n\t\t}\n\t}\n\n\texecute_effect_teardown(effect);\n\n\tvar parent = effect.parent;\n\n\t// If the parent doesn't have any children, then skip this work altogether\n\tif (parent !== null && (effect.f & BRANCH_EFFECT) !== 0 && parent.first !== null) {\n\t\tunlink_effect(effect);\n\t}\n\n\t// `first` and `child` are nulled out in destroy_effect_children\n\teffect.next =\n\t\teffect.prev =\n\t\teffect.teardown =\n\t\teffect.ctx =\n\t\teffect.dom =\n\t\teffect.deps =\n\t\teffect.parent =\n\t\teffect.fn =\n\t\t\tnull;\n}\n\n/**\n * Detach an effect from the effect tree, freeing up memory and\n * reducing the amount of work that happens on subsequent traversals\n * @param {import('#client').Effect} effect\n */\nexport function unlink_effect(effect) {\n\tvar parent = effect.parent;\n\tvar prev = effect.prev;\n\tvar next = effect.next;\n\n\tif (prev !== null) prev.next = next;\n\tif (next !== null) next.prev = prev;\n\n\tif (parent !== null) {\n\t\tif (parent.first === effect) parent.first = next;\n\t\tif (parent.last === effect) parent.last = prev;\n\t}\n}\n\n/**\n * When a block effect is removed, we don't immediately destroy it or yank it\n * out of the DOM, because it might have transitions. Instead, we 'pause' it.\n * It stays around (in memory, and in the DOM) until outro transitions have\n * completed, and if the state change is reversed then we _resume_ it.\n * A paused effect does not update, and the DOM subtree becomes inert.\n * @param {import('#client').Effect} effect\n * @param {() => void} [callback]\n */\nexport function pause_effect(effect, callback) {\n\t/** @type {import('#client').TransitionManager[]} */\n\tvar transitions = [];\n\n\tpause_children(effect, transitions, true);\n\n\trun_out_transitions(transitions, () => {\n\t\tdestroy_effect(effect);\n\t\tif (callback) callback();\n\t});\n}\n\n/**\n * @param {import('#client').TransitionManager[]} transitions\n * @param {() => void} fn\n */\nexport function run_out_transitions(transitions, fn) {\n\tvar remaining = transitions.length;\n\tif (remaining > 0) {\n\t\tvar check = () => --remaining || fn();\n\t\tfor (var transition of transitions) {\n\t\t\ttransition.out(check);\n\t\t}\n\t} else {\n\t\tfn();\n\t}\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @param {import('#client').TransitionManager[]} transitions\n * @param {boolean} local\n */\nexport function pause_children(effect, transitions, local) {\n\tif ((effect.f & INERT) !== 0) return;\n\teffect.f ^= INERT;\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransitions.push(transition);\n\t\t\t}\n\t\t}\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call pause_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tpause_children(child, transitions, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n}\n\n/**\n * The opposite of `pause_effect`. We call this if (for example)\n * `x` becomes falsy then truthy: `{#if x}...{/if}`\n * @param {import('#client').Effect} effect\n */\nexport function resume_effect(effect) {\n\tresume_children(effect, true);\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @param {boolean} local\n */\nfunction resume_children(effect, local) {\n\tif ((effect.f & INERT) === 0) return;\n\teffect.f ^= INERT;\n\n\t// If a dependency of this effect changed while it was paused,\n\t// apply the change now\n\tif (check_dirtiness(effect)) {\n\t\texecute_effect(effect);\n\t}\n\n\tvar child = effect.first;\n\n\twhile (child !== null) {\n\t\tvar sibling = child.next;\n\t\tvar transparent = (child.f & EFFECT_TRANSPARENT) !== 0 || (child.f & BRANCH_EFFECT) !== 0;\n\t\t// TODO we don't need to call resume_children recursively with a linked list in place\n\t\t// it's slightly more involved though as we have to account for `transparent` changing\n\t\t// through the tree.\n\t\tresume_children(child, transparent ? local : false);\n\t\tchild = sibling;\n\t}\n\n\tif (effect.transitions !== null) {\n\t\tfor (const transition of effect.transitions) {\n\t\t\tif (transition.is_global || local) {\n\t\t\t\ttransition.in();\n\t\t\t}\n\t\t}\n\t}\n}\n","/* This file is generated by scripts/process-messages/index.js. Do not edit! */\n\nimport { DEV } from 'esm-env';\n\nvar bold = 'font-weight: bold';\nvar normal = 'font-weight: normal';\n\n/**\n * The `%attribute%` attribute on `%html%` changed its value between server and client renders. The client value, `%value%`, will be ignored in favour of the server value\n * @param {string} attribute\n * @param {string} html\n * @param {string} value\n */\nexport function hydration_attribute_changed(attribute, html, value) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] hydration_attribute_changed\\n%cThe \\`${attribute}\\` attribute on \\`${html}\\` changed its value between server and client renders. The client value, \\`${value}\\`, will be ignored in favour of the server value`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"hydration_attribute_changed\");\n\t}\n}\n\n/**\n * Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near %location%\n * @param {string | undefined | null} [location]\n */\nexport function hydration_mismatch(location) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] hydration_mismatch\\n%c${location ? `Hydration failed because the initial UI does not match what was rendered on the server. The error occurred near ${location}` : \"Hydration failed because the initial UI does not match what was rendered on the server\"}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"hydration_mismatch\");\n\t}\n}\n\n/**\n * Tried to unmount a component that was not mounted\n */\nexport function lifecycle_double_unmount() {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] lifecycle_double_unmount\\n%cTried to unmount a component that was not mounted`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"lifecycle_double_unmount\");\n\t}\n}\n\n/**\n * %parent% passed a value to %child% with `bind:`, but the value is owned by %owner%. Consider creating a binding between %owner% and %parent%\n * @param {string} parent\n * @param {string} child\n * @param {string} owner\n */\nexport function ownership_invalid_binding(parent, child, owner) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] ownership_invalid_binding\\n%c${parent} passed a value to ${child} with \\`bind:\\`, but the value is owned by ${owner}. Consider creating a binding between ${owner} and ${parent}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"ownership_invalid_binding\");\n\t}\n}\n\n/**\n * %component% mutated a value owned by %owner%. This is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead\n * @param {string | undefined | null} [component]\n * @param {string | undefined | null} [owner]\n */\nexport function ownership_invalid_mutation(component, owner) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] ownership_invalid_mutation\\n%c${component ? `${component} mutated a value owned by ${owner}. This is strongly discouraged. Consider passing values to child components with \\`bind:\\`, or use a callback instead` : \"Mutating a value outside the component that created it is strongly discouraged. Consider passing values to child components with `bind:`, or use a callback instead\"}`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"ownership_invalid_mutation\");\n\t}\n}\n\n/**\n * Reactive `$state(...)` proxies and the values they proxy have different identities. Because of this, comparisons with `%operator%` will produce unexpected results. Consider using `$state.is(a, b)` instead\n * @param {string} operator\n */\nexport function state_proxy_equality_mismatch(operator) {\n\tif (DEV) {\n\t\tconsole.warn(`%c[svelte] state_proxy_equality_mismatch\\n%cReactive \\`$state(...)\\` proxies and the values they proxy have different identities. Because of this, comparisons with \\`${operator}\\` will produce unexpected results. Consider using \\`$state.is(a, b)\\` instead`, bold, normal);\n\t} else {\n\t\t// TODO print a link to the documentation\n\t\tconsole.warn(\"state_proxy_equality_mismatch\");\n\t}\n}","import { DEV } from 'esm-env';\nimport { get, current_component_context, untrack, current_effect } from './runtime.js';\nimport {\n\tarray_prototype,\n\tdefine_property,\n\tget_descriptor,\n\tget_descriptors,\n\tget_prototype_of,\n\tis_array,\n\tis_frozen,\n\tobject_prototype\n} from './utils.js';\nimport { check_ownership, widen_ownership } from './dev/ownership.js';\nimport { mutable_source, source, set } from './reactivity/sources.js';\nimport { STATE_FROZEN_SYMBOL, STATE_SYMBOL } from './constants.js';\nimport { UNINITIALIZED } from '../../constants.js';\nimport * as e from './errors.js';\n\n/**\n * @template T\n * @param {T} value\n * @param {boolean} [immutable]\n * @param {import('#client').ProxyMetadata | null} [parent]\n * @param {import('#client').Source<T>} [prev] dev mode only\n * @returns {import('#client').ProxyStateObject<T> | T}\n */\nexport function proxy(value, immutable = true, parent = null, prev) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue != null &&\n\t\t!is_frozen(value) &&\n\t\t!(STATE_FROZEN_SYMBOL in value)\n\t) {\n\t\t// If we have an existing proxy, return it...\n\t\tif (STATE_SYMBOL in value) {\n\t\t\tconst metadata = /** @type {import('#client').ProxyMetadata<T>} */ (value[STATE_SYMBOL]);\n\n\t\t\t// ...unless the proxy belonged to a different object, because\n\t\t\t// someone copied the state symbol using `Reflect.ownKeys(...)`\n\t\t\tif (metadata.t === value || metadata.p === value) {\n\t\t\t\tif (DEV) {\n\t\t\t\t\t// Since original parent relationship gets lost, we need to copy over ancestor owners\n\t\t\t\t\t// into current metadata. The object might still exist on both, so we need to widen it.\n\t\t\t\t\twiden_ownership(metadata, metadata);\n\t\t\t\t\tmetadata.parent = parent;\n\t\t\t\t}\n\n\t\t\t\treturn metadata.p;\n\t\t\t}\n\t\t}\n\n\t\tconst prototype = get_prototype_of(value);\n\n\t\tif (prototype === object_prototype || prototype === array_prototype) {\n\t\t\tconst proxy = new Proxy(value, state_proxy_handler);\n\n\t\t\tdefine_property(value, STATE_SYMBOL, {\n\t\t\t\tvalue: /** @type {import('#client').ProxyMetadata} */ ({\n\t\t\t\t\ts: new Map(),\n\t\t\t\t\tv: source(0),\n\t\t\t\t\ta: is_array(value),\n\t\t\t\t\ti: immutable,\n\t\t\t\t\tp: proxy,\n\t\t\t\t\tt: value\n\t\t\t\t}),\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: false\n\t\t\t});\n\n\t\t\tif (DEV) {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvalue[STATE_SYMBOL].parent = parent;\n\n\t\t\t\tif (prev) {\n\t\t\t\t\t// Reuse owners from previous state; necessary because reassignment is not guaranteed to have correct component context.\n\t\t\t\t\t// If no previous proxy exists we play it safe and assume ownerless state\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tconst prev_owners = prev?.v?.[STATE_SYMBOL]?.owners;\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tvalue[STATE_SYMBOL].owners = prev_owners ? new Set(prev_owners) : null;\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tvalue[STATE_SYMBOL].owners =\n\t\t\t\t\t\tparent === null\n\t\t\t\t\t\t\t? current_component_context !== null\n\t\t\t\t\t\t\t\t? new Set([current_component_context.function])\n\t\t\t\t\t\t\t\t: null\n\t\t\t\t\t\t\t: new Set();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn proxy;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template {import('#client').ProxyStateObject} T\n * @param {T} value\n * @param {Map<T, Record<string | symbol, any>>} already_unwrapped\n * @returns {Record<string | symbol, any>}\n */\nfunction unwrap(value, already_unwrapped) {\n\tif (typeof value === 'object' && value != null && STATE_SYMBOL in value) {\n\t\tconst unwrapped = already_unwrapped.get(value);\n\t\tif (unwrapped !== undefined) {\n\t\t\treturn unwrapped;\n\t\t}\n\n\t\tif (is_array(value)) {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst array = [];\n\t\t\talready_unwrapped.set(value, array);\n\t\t\tfor (const element of value) {\n\t\t\t\tarray.push(unwrap(element, already_unwrapped));\n\t\t\t}\n\t\t\treturn array;\n\t\t} else {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst obj = {};\n\t\t\tconst keys = Reflect.ownKeys(value);\n\t\t\tconst descriptors = get_descriptors(value);\n\t\t\talready_unwrapped.set(value, obj);\n\n\t\t\tfor (const key of keys) {\n\t\t\t\tif (key === STATE_SYMBOL) continue;\n\t\t\t\tif (descriptors[key].get) {\n\t\t\t\t\tdefine_property(obj, key, descriptors[key]);\n\t\t\t\t} else {\n\t\t\t\t\t/** @type {T} */\n\t\t\t\t\tconst property = value[key];\n\t\t\t\t\tobj[key] = unwrap(property, already_unwrapped);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template T\n * @param {T} value\n * @returns {T}\n */\nexport function snapshot(value) {\n\treturn /** @type {T} */ (\n\t\tunwrap(/** @type {import('#client').ProxyStateObject} */ (value), new Map())\n\t);\n}\n\n/**\n * @param {import('#client').Source<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tset(signal, signal.v + d);\n}\n\n/** @type {ProxyHandler<import('#client').ProxyStateObject<any>>} */\nconst state_proxy_handler = {\n\tdefineProperty(target, prop, descriptor) {\n\t\tif (descriptor.value) {\n\t\t\t/** @type {import('#client').ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\t\tconst s = metadata.s.get(prop);\n\t\t\tif (s !== undefined) set(s, proxy(descriptor.value, metadata.i, metadata));\n\t\t}\n\n\t\treturn Reflect.defineProperty(target, prop, descriptor);\n\t},\n\n\tdeleteProperty(target, prop) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst s = metadata.s.get(prop);\n\t\tconst is_array = metadata.a;\n\t\tconst boolean = delete target[prop];\n\n\t\t// If we have mutated an array directly, and the deletion\n\t\t// was successful we will also need to update the length\n\t\t// before updating the field or the version. This is to\n\t\t// ensure any effects observing length can execute before\n\t\t// effects that listen to the fields  otherwise they will\n\t\t// operate an an index that no longer exists.\n\t\tif (is_array && boolean) {\n\t\t\tconst ls = metadata.s.get('length');\n\t\t\tconst length = target.length - 1;\n\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\tset(ls, length);\n\t\t\t}\n\t\t}\n\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\n\t\tif (boolean) {\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn boolean;\n\t},\n\n\tget(target, prop, receiver) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn Reflect.get(target, STATE_SYMBOL);\n\t\t}\n\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\n\t\t// create a source, but only if it's an own property and not a prototype property\n\t\tif (s === undefined && (!(prop in target) || get_descriptor(target, prop)?.writable)) {\n\t\t\ts = (metadata.i ? source : mutable_source)(proxy(target[prop], metadata.i, metadata));\n\t\t\tmetadata.s.set(prop, s);\n\t\t}\n\n\t\tif (s !== undefined) {\n\t\t\tconst value = get(s);\n\t\t\treturn value === UNINITIALIZED ? undefined : value;\n\t\t}\n\n\t\treturn Reflect.get(target, prop, receiver);\n\t},\n\n\tgetOwnPropertyDescriptor(target, prop) {\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t/** @type {import('#client').ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\t\t\tconst s = metadata.s.get(prop);\n\n\t\t\tif (s) {\n\t\t\t\tdescriptor.value = get(s);\n\t\t\t}\n\t\t}\n\n\t\treturn descriptor;\n\t},\n\n\thas(target, prop) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn true;\n\t\t}\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst has = Reflect.has(target, prop);\n\n\t\tlet s = metadata.s.get(prop);\n\t\tif (\n\t\t\ts !== undefined ||\n\t\t\t(current_effect !== null && (!has || get_descriptor(target, prop)?.writable))\n\t\t) {\n\t\t\tif (s === undefined) {\n\t\t\t\ts = (metadata.i ? source : mutable_source)(\n\t\t\t\t\thas ? proxy(target[prop], metadata.i, metadata) : UNINITIALIZED\n\t\t\t\t);\n\t\t\t\tmetadata.s.set(prop, s);\n\t\t\t}\n\t\t\tconst value = get(s);\n\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn has;\n\t},\n\n\tset(target, prop, value, receiver) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t// object property before writing to that property.\n\t\tif (s === undefined) {\n\t\t\t// the read creates a signal\n\t\t\tuntrack(() => receiver[prop]);\n\t\t\ts = metadata.s.get(prop);\n\t\t}\n\t\tif (s !== undefined) {\n\t\t\tset(s, proxy(value, metadata.i, metadata));\n\t\t}\n\t\tconst is_array = metadata.a;\n\t\tconst not_has = !(prop in target);\n\n\t\tif (DEV) {\n\t\t\t/** @type {import('#client').ProxyMetadata | undefined} */\n\t\t\tconst prop_metadata = value?.[STATE_SYMBOL];\n\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t}\n\t\t\tcheck_ownership(metadata);\n\t\t}\n\n\t\t// variable.length = value -> clear all signals with index >= value\n\t\tif (is_array && prop === 'length') {\n\t\t\tfor (let i = value; i < target.length; i += 1) {\n\t\t\t\tconst s = metadata.s.get(i + '');\n\t\t\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\t\t\t}\n\t\t}\n\n\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\t// @ts-ignore\n\t\ttarget[prop] = value;\n\n\t\tif (not_has) {\n\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t// will not cause the length to be out of sync.\n\t\t\tif (is_array) {\n\t\t\t\tconst ls = metadata.s.get('length');\n\t\t\t\tconst length = target.length;\n\t\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\t\tset(ls, length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn true;\n\t},\n\n\townKeys(target) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\tget(metadata.v);\n\t\treturn Reflect.ownKeys(target);\n\t}\n};\n\nif (DEV) {\n\tstate_proxy_handler.setPrototypeOf = () => {\n\t\te.state_prototype_fixed();\n\t};\n}\n\n/**\n * @param {any} value\n */\nexport function get_proxied_value(value) {\n\tif (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {\n\t\tvar metadata = value[STATE_SYMBOL];\n\t\tif (metadata) {\n\t\t\treturn metadata.p;\n\t\t}\n\t}\n\treturn value;\n}\n\n/**\n * @param {any} a\n * @param {any} b\n */\nexport function is(a, b) {\n\treturn Object.is(get_proxied_value(a), get_proxied_value(b));\n}\n","export const noop = () => {};\n\n// Adapted from https://github.com/then/is-promise/blob/master/index.js\n// Distributed under MIT License https://github.com/then/is-promise/blob/master/LICENSE\n\n/**\n * @template [T=any]\n * @param {any} value\n * @returns {value is PromiseLike<T>}\n */\nexport function is_promise(value) {\n\treturn typeof value?.then === 'function';\n}\n\n/** @param {Function} fn */\nexport function run(fn) {\n\treturn fn();\n}\n\n/** @param {Array<() => void>} arr */\nexport function run_all(arr) {\n\tfor (var i = 0; i < arr.length; i++) {\n\t\tarr[i]();\n\t}\n}\n","import { run_all } from '../../shared/utils.js';\n\n// Fallback for when requestIdleCallback is not available\nconst request_idle_callback =\n\ttypeof requestIdleCallback === 'undefined'\n\t\t? (/** @type {() => void} */ cb) => setTimeout(cb, 1)\n\t\t: requestIdleCallback;\n\nlet is_micro_task_queued = false;\nlet is_idle_task_queued = false;\n\n/** @type {Array<() => void>} */\nlet current_queued_micro_tasks = [];\n/** @type {Array<() => void>} */\nlet current_queued_idle_tasks = [];\n\nfunction process_micro_tasks() {\n\tis_micro_task_queued = false;\n\tconst tasks = current_queued_micro_tasks.slice();\n\tcurrent_queued_micro_tasks = [];\n\trun_all(tasks);\n}\n\nfunction process_idle_tasks() {\n\tis_idle_task_queued = false;\n\tconst tasks = current_queued_idle_tasks.slice();\n\tcurrent_queued_idle_tasks = [];\n\trun_all(tasks);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_micro_task(fn) {\n\tif (!is_micro_task_queued) {\n\t\tis_micro_task_queued = true;\n\t\tqueueMicrotask(process_micro_tasks);\n\t}\n\tcurrent_queued_micro_tasks.push(fn);\n}\n\n/**\n * @param {() => void} fn\n */\nexport function queue_idle_task(fn) {\n\tif (!is_idle_task_queued) {\n\t\tis_idle_task_queued = true;\n\t\trequest_idle_callback(process_idle_tasks);\n\t}\n\tcurrent_queued_idle_tasks.push(fn);\n}\n\n/**\n * Synchronously run any queued tasks.\n */\nexport function flush_tasks() {\n\tif (is_micro_task_queued) {\n\t\tprocess_micro_tasks();\n\t}\n\tif (is_idle_task_queued) {\n\t\tprocess_idle_tasks();\n\t}\n}\n","import { CLEAN, DERIVED, DESTROYED, DIRTY, MAYBE_DIRTY, UNOWNED } from '../constants.js';\nimport {\n\tcurrent_reaction,\n\tcurrent_effect,\n\tremove_reactions,\n\tset_signal_status,\n\tmark_reactions,\n\tcurrent_skip_reaction,\n\texecute_reaction_fn,\n\tdestroy_effect_children,\n\tincrement_version\n} from '../runtime.js';\nimport { equals, safe_equals } from './equality.js';\n\nexport let updating_derived = false;\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {import('#client').Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived(fn) {\n\tlet flags = DERIVED | DIRTY;\n\tif (current_effect === null) flags |= UNOWNED;\n\n\t/** @type {import('#client').Derived<V>} */\n\tconst signal = {\n\t\tdeps: null,\n\t\tderiveds: null,\n\t\tequals,\n\t\tf: flags,\n\t\tfirst: null,\n\t\tfn,\n\t\tlast: null,\n\t\treactions: null,\n\t\tv: /** @type {V} */ (null),\n\t\tversion: 0\n\t};\n\n\tif (current_reaction !== null && (current_reaction.f & DERIVED) !== 0) {\n\t\tvar current_derived = /** @type {import('#client').Derived<V>} */ (current_reaction);\n\t\tif (current_derived.deriveds === null) {\n\t\t\tcurrent_derived.deriveds = [signal];\n\t\t} else {\n\t\t\tcurrent_derived.deriveds.push(signal);\n\t\t}\n\t}\n\n\treturn signal;\n}\n\n/**\n * @template V\n * @param {() => V} fn\n * @returns {import('#client').Derived<V>}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function derived_safe_equal(fn) {\n\tconst signal = derived(fn);\n\tsignal.equals = safe_equals;\n\treturn signal;\n}\n\n/**\n * @param {import('#client').Derived} signal\n * @returns {void}\n */\nfunction destroy_derived_children(signal) {\n\tdestroy_effect_children(signal);\n\tvar deriveds = signal.deriveds;\n\n\tif (deriveds !== null) {\n\t\tsignal.deriveds = null;\n\t\tfor (var i = 0; i < deriveds.length; i += 1) {\n\t\t\tdestroy_derived(deriveds[i]);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Derived} derived\n * @returns {void}\n */\nexport function update_derived(derived) {\n\tvar previous_updating_derived = updating_derived;\n\tupdating_derived = true;\n\tdestroy_derived_children(derived);\n\tvar value = execute_reaction_fn(derived);\n\tupdating_derived = previous_updating_derived;\n\n\tvar status =\n\t\t(current_skip_reaction || (derived.f & UNOWNED) !== 0) && derived.deps !== null\n\t\t\t? MAYBE_DIRTY\n\t\t\t: CLEAN;\n\n\tset_signal_status(derived, status);\n\n\tif (!derived.equals(value)) {\n\t\tderived.v = value;\n\t\tderived.version = increment_version();\n\t\tmark_reactions(derived, DIRTY, false);\n\t}\n}\n\n/**\n * @param {import('#client').Derived} signal\n * @returns {void}\n */\nexport function destroy_derived(signal) {\n\tdestroy_derived_children(signal);\n\tremove_reactions(signal, 0);\n\tset_signal_status(signal, DESTROYED);\n\n\t// TODO we need to ensure we remove the derived from any parent derives\n\n\tsignal.first =\n\t\tsignal.last =\n\t\tsignal.deps =\n\t\tsignal.reactions =\n\t\t// @ts-expect-error `signal.fn` cannot be `null` while the signal is alive\n\t\tsignal.fn =\n\t\t\tnull;\n}\n","import { DEV } from 'esm-env';\nimport {\n\tdefine_property,\n\tget_descriptors,\n\tget_prototype_of,\n\tis_frozen,\n\tobject_freeze\n} from './utils.js';\nimport { snapshot } from './proxy.js';\nimport {\n\tdestroy_effect,\n\teffect,\n\texecute_effect_teardown,\n\tunlink_effect\n} from './reactivity/effects.js';\nimport {\n\tEFFECT,\n\tRENDER_EFFECT,\n\tDIRTY,\n\tMAYBE_DIRTY,\n\tCLEAN,\n\tDERIVED,\n\tUNOWNED,\n\tDESTROYED,\n\tINERT,\n\tBRANCH_EFFECT,\n\tSTATE_SYMBOL,\n\tBLOCK_EFFECT,\n\tROOT_EFFECT,\n\tLEGACY_DERIVED_PROP,\n\tDISCONNECTED,\n\tSTATE_FROZEN_SYMBOL,\n\tINSPECT_EFFECT\n} from './constants.js';\nimport { flush_tasks } from './dom/task.js';\nimport { add_owner } from './dev/ownership.js';\nimport { mutate, set, source } from './reactivity/sources.js';\nimport { update_derived } from './reactivity/deriveds.js';\nimport * as e from './errors.js';\nimport { lifecycle_outside_component } from '../shared/errors.js';\n\nconst FLUSH_MICROTASK = 0;\nconst FLUSH_SYNC = 1;\n\n// Used for DEV time error handling\n/** @param {WeakSet<Error>} value */\nconst handled_errors = new WeakSet();\n// Used for controlling the flush of effects.\nlet current_scheduler_mode = FLUSH_MICROTASK;\n// Used for handling scheduling\nlet is_micro_task_queued = false;\n\nexport let is_flushing_effect = false;\nexport let is_destroying_effect = false;\n\n/** @param {boolean} value */\nexport function set_is_flushing_effect(value) {\n\tis_flushing_effect = value;\n}\n\n/** @param {boolean} value */\nexport function set_is_destroying_effect(value) {\n\tis_destroying_effect = value;\n}\n\nexport let inspect_effects = new Set();\n\n// Handle effect queues\n\n/** @type {import('#client').Effect[]} */\nlet current_queued_root_effects = [];\n\nlet flush_count = 0;\n// Handle signal reactivity tree dependencies and reactions\n\n/** @type {null | import('#client').Reaction} */\nexport let current_reaction = null;\n\n/** @param {null | import('#client').Reaction} reaction */\nexport function set_current_reaction(reaction) {\n\tcurrent_reaction = reaction;\n}\n\n/** @type {null | import('#client').Effect} */\nexport let current_effect = null;\n\n/** @param {null | import('#client').Effect} effect */\nexport function set_current_effect(effect) {\n\tcurrent_effect = effect;\n}\n\n/** @type {null | import('#client').Value[]} */\nexport let current_dependencies = null;\nlet current_dependencies_index = 0;\n/**\n * Tracks writes that the effect it's executed in doesn't listen to yet,\n * so that the dependency can be added to the effect later on if it then reads it\n * @type {null | import('#client').Source[]}\n */\nexport let current_untracked_writes = null;\n\n/** @param {null | import('#client').Source[]} value */\nexport function set_current_untracked_writes(value) {\n\tcurrent_untracked_writes = value;\n}\n\n/** @type {number} Used by sources and deriveds for handling updates to unowned deriveds */\nlet current_version = 0;\n\n// If we are working with a get() chain that has no active container,\n// to prevent memory leaks, we skip adding the reaction.\nexport let current_skip_reaction = false;\n// Handle collecting all signals which are read during a specific time frame\nexport let is_signals_recorded = false;\nlet captured_signals = new Set();\n\n// Handling runtime component context\n/** @type {import('#client').ComponentContext | null} */\nexport let current_component_context = null;\n\n/** @param {import('#client').ComponentContext | null} context */\nexport function set_current_component_context(context) {\n\tcurrent_component_context = context;\n}\n\n/**\n * The current component function. Different from current component context:\n * ```html\n * <!-- App.svelte -->\n * <Foo>\n *   <Bar /> <!-- context == Foo.svelte, function == App.svelte -->\n * </Foo>\n * ```\n * @type {import('#client').ComponentContext['function']}\n */\nexport let dev_current_component_function = null;\n\n/** @param {import('#client').ComponentContext['function']} fn */\nexport function set_dev_current_component_function(fn) {\n\tdev_current_component_function = fn;\n}\n\nexport function increment_version() {\n\treturn current_version++;\n}\n\n/** @returns {boolean} */\nexport function is_runes() {\n\treturn current_component_context !== null && current_component_context.l === null;\n}\n\n/**\n * Determines whether a derived or effect is dirty.\n * If it is MAYBE_DIRTY, will set the status to CLEAN\n * @param {import('#client').Reaction} reaction\n * @returns {boolean}\n */\nexport function check_dirtiness(reaction) {\n\tvar flags = reaction.f;\n\tvar is_dirty = (flags & DIRTY) !== 0;\n\n\tif (is_dirty) {\n\t\treturn true;\n\t}\n\n\tvar is_unowned = (flags & UNOWNED) !== 0;\n\tvar is_disconnected = (flags & DISCONNECTED) !== 0;\n\n\tif ((flags & MAYBE_DIRTY) !== 0) {\n\t\tvar dependencies = reaction.deps;\n\n\t\tif (dependencies !== null) {\n\t\t\tvar length = dependencies.length;\n\t\t\tvar reactions;\n\n\t\t\tfor (var i = 0; i < length; i++) {\n\t\t\t\tvar dependency = dependencies[i];\n\n\t\t\t\tif (!is_dirty && check_dirtiness(/** @type {import('#client').Derived} */ (dependency))) {\n\t\t\t\t\tupdate_derived(/** @type {import('#client').Derived} **/ (dependency));\n\t\t\t\t}\n\n\t\t\t\tvar version = dependency.version;\n\n\t\t\t\tif (is_unowned) {\n\t\t\t\t\t// If we're working with an unowned derived signal, then we need to check\n\t\t\t\t\t// if our dependency write version is higher. If it is then we can assume\n\t\t\t\t\t// that state has changed to a newer version and thus this unowned signal\n\t\t\t\t\t// is also dirty.\n\t\t\t\t\tif (version > /** @type {import('#client').Derived} */ (reaction).version) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!current_skip_reaction && !dependency?.reactions?.includes(reaction)) {\n\t\t\t\t\t\t// If we are working with an unowned signal as part of an effect (due to !current_skip_reaction)\n\t\t\t\t\t\t// and the version hasn't changed, we still need to check that this reaction\n\t\t\t\t\t\t// if linked to the dependency source  otherwise future updates will not be caught.\n\t\t\t\t\t\t(dependency.reactions ??= []).push(reaction);\n\t\t\t\t\t}\n\t\t\t\t} else if ((reaction.f & DIRTY) !== 0) {\n\t\t\t\t\t// `signal` might now be dirty, as a result of calling `check_dirtiness` and/or `update_derived`\n\t\t\t\t\treturn true;\n\t\t\t\t} else if (is_disconnected) {\n\t\t\t\t\t// It might be that the derived was was dereferenced from its dependencies but has now come alive again.\n\t\t\t\t\t// In thise case, we need to re-attach it to the graph and mark it dirty if any of its dependencies have\n\t\t\t\t\t// changed since.\n\t\t\t\t\tif (version > /** @type {import('#client').Derived} */ (reaction).version) {\n\t\t\t\t\t\tis_dirty = true;\n\t\t\t\t\t}\n\n\t\t\t\t\treactions = dependency.reactions;\n\t\t\t\t\tif (reactions === null) {\n\t\t\t\t\t\tdependency.reactions = [reaction];\n\t\t\t\t\t} else if (!reactions.includes(reaction)) {\n\t\t\t\t\t\treactions.push(reaction);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Unowned signals are always maybe dirty, as we instead check their dependency versions.\n\t\tif (!is_unowned) {\n\t\t\tset_signal_status(reaction, CLEAN);\n\t\t}\n\t\tif (is_disconnected) {\n\t\t\treaction.f ^= DISCONNECTED;\n\t\t}\n\t}\n\n\treturn is_dirty;\n}\n\n/**\n * @param {Error} error\n * @param {import(\"#client\").Effect} effect\n * @param {import(\"#client\").ComponentContext | null} component_context\n */\nfunction handle_error(error, effect, component_context) {\n\t// Given we don't yet have error boundaries, we will just always throw.\n\tif (!DEV || handled_errors.has(error) || component_context === null) {\n\t\tthrow error;\n\t}\n\n\tconst component_stack = [];\n\n\tconst effect_name = effect.fn?.name;\n\n\tif (effect_name) {\n\t\tcomponent_stack.push(effect_name);\n\t}\n\n\t/** @type {import(\"#client\").ComponentContext | null} */\n\tlet current_context = component_context;\n\n\twhile (current_context !== null) {\n\t\tvar filename = current_context.function?.filename;\n\n\t\tif (filename) {\n\t\t\tconst file = filename.split('/').at(-1);\n\t\t\tcomponent_stack.push(file);\n\t\t}\n\n\t\tcurrent_context = current_context.p;\n\t}\n\n\tconst indent = /Firefox/.test(navigator.userAgent) ? '  ' : '\\t';\n\tdefine_property(error, 'message', {\n\t\tvalue: error.message + `\\n${component_stack.map((name) => `\\n${indent}in ${name}`).join('')}\\n`\n\t});\n\n\tconst stack = error.stack;\n\n\t// Filter out internal files from callstack\n\tif (stack) {\n\t\tconst lines = stack.split('\\n');\n\t\tconst new_lines = [];\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tconst line = lines[i];\n\t\t\tif (line.includes('svelte/src/internal')) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tnew_lines.push(line);\n\t\t}\n\t\tdefine_property(error, 'stack', {\n\t\t\tvalue: error.stack + new_lines.join('\\n')\n\t\t});\n\t}\n\n\thandled_errors.add(error);\n\tthrow error;\n}\n\n/**\n * @template V\n * @param {import('#client').Reaction} signal\n * @returns {V}\n */\nexport function execute_reaction_fn(signal) {\n\tconst previous_dependencies = current_dependencies;\n\tconst previous_dependencies_index = current_dependencies_index;\n\tconst previous_untracked_writes = current_untracked_writes;\n\tconst previous_reaction = current_reaction;\n\tconst previous_skip_reaction = current_skip_reaction;\n\n\tcurrent_dependencies = /** @type {null | import('#client').Value[]} */ (null);\n\tcurrent_dependencies_index = 0;\n\tcurrent_untracked_writes = null;\n\tcurrent_reaction = (signal.f & (BRANCH_EFFECT | ROOT_EFFECT)) === 0 ? signal : null;\n\tcurrent_skip_reaction = !is_flushing_effect && (signal.f & UNOWNED) !== 0;\n\n\ttry {\n\t\tlet res = /** @type {Function} */ (0, signal.fn)();\n\t\tlet dependencies = /** @type {import('#client').Value<unknown>[]} **/ (signal.deps);\n\t\tif (current_dependencies !== null) {\n\t\t\tlet i;\n\t\t\tif (dependencies !== null) {\n\t\t\t\tconst deps_length = dependencies.length;\n\t\t\t\t// Include any dependencies up until the current_dependencies_index.\n\t\t\t\tconst full_current_dependencies =\n\t\t\t\t\tcurrent_dependencies_index === 0\n\t\t\t\t\t\t? current_dependencies\n\t\t\t\t\t\t: dependencies.slice(0, current_dependencies_index).concat(current_dependencies);\n\t\t\t\tconst current_dep_length = full_current_dependencies.length;\n\t\t\t\t// If we have more than 16 elements in the array then use a Set for faster performance\n\t\t\t\t// TODO: evaluate if we should always just use a Set or not here?\n\t\t\t\tconst full_current_dependencies_set =\n\t\t\t\t\tcurrent_dep_length > 16 && deps_length - current_dependencies_index > 1\n\t\t\t\t\t\t? new Set(full_current_dependencies)\n\t\t\t\t\t\t: null;\n\t\t\t\tfor (i = current_dependencies_index; i < deps_length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\t\tif (\n\t\t\t\t\t\tfull_current_dependencies_set !== null\n\t\t\t\t\t\t\t? !full_current_dependencies_set.has(dependency)\n\t\t\t\t\t\t\t: !full_current_dependencies.includes(dependency)\n\t\t\t\t\t) {\n\t\t\t\t\t\tremove_reaction(signal, dependency);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (dependencies !== null && current_dependencies_index > 0) {\n\t\t\t\tdependencies.length = current_dependencies_index + current_dependencies.length;\n\t\t\t\tfor (i = 0; i < current_dependencies.length; i++) {\n\t\t\t\t\tdependencies[current_dependencies_index + i] = current_dependencies[i];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tsignal.deps = /** @type {import('#client').Value<V>[]} **/ (\n\t\t\t\t\tdependencies = current_dependencies\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tif (!current_skip_reaction) {\n\t\t\t\tfor (i = current_dependencies_index; i < dependencies.length; i++) {\n\t\t\t\t\tconst dependency = dependencies[i];\n\t\t\t\t\tconst reactions = dependency.reactions;\n\n\t\t\t\t\tif (reactions === null) {\n\t\t\t\t\t\tdependency.reactions = [signal];\n\t\t\t\t\t} else if (reactions[reactions.length - 1] !== signal && !reactions.includes(signal)) {\n\t\t\t\t\t\treactions.push(signal);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (dependencies !== null && current_dependencies_index < dependencies.length) {\n\t\t\tremove_reactions(signal, current_dependencies_index);\n\t\t\tdependencies.length = current_dependencies_index;\n\t\t}\n\t\treturn res;\n\t} finally {\n\t\tcurrent_dependencies = previous_dependencies;\n\t\tcurrent_dependencies_index = previous_dependencies_index;\n\t\tcurrent_untracked_writes = previous_untracked_writes;\n\t\tcurrent_reaction = previous_reaction;\n\t\tcurrent_skip_reaction = previous_skip_reaction;\n\t}\n}\n\n/**\n * @template V\n * @param {import('#client').Reaction} signal\n * @param {import('#client').Value<V>} dependency\n * @returns {void}\n */\nfunction remove_reaction(signal, dependency) {\n\tconst reactions = dependency.reactions;\n\tlet reactions_length = 0;\n\tif (reactions !== null) {\n\t\treactions_length = reactions.length - 1;\n\t\tconst index = reactions.indexOf(signal);\n\t\tif (index !== -1) {\n\t\t\tif (reactions_length === 0) {\n\t\t\t\tdependency.reactions = null;\n\t\t\t} else {\n\t\t\t\t// Swap with last element and then remove.\n\t\t\t\treactions[index] = reactions[reactions_length];\n\t\t\t\treactions.pop();\n\t\t\t}\n\t\t}\n\t}\n\t// If the derived has no reactions, then we can disconnect it from the graph,\n\t// allowing it to either reconnect in the future, or be GC'd by the VM.\n\tif (reactions_length === 0 && (dependency.f & DERIVED) !== 0) {\n\t\tset_signal_status(dependency, MAYBE_DIRTY);\n\t\t// If we are working with a derived that is owned by an effect, then mark it as being\n\t\t// disconnected.\n\t\tif ((dependency.f & (UNOWNED | DISCONNECTED)) === 0) {\n\t\t\tdependency.f ^= DISCONNECTED;\n\t\t}\n\t\tremove_reactions(/** @type {import('#client').Derived} **/ (dependency), 0);\n\t}\n}\n\n/**\n * @param {import('#client').Reaction} signal\n * @param {number} start_index\n * @returns {void}\n */\nexport function remove_reactions(signal, start_index) {\n\tconst dependencies = signal.deps;\n\tif (dependencies !== null) {\n\t\tconst active_dependencies = start_index === 0 ? null : dependencies.slice(0, start_index);\n\t\tlet i;\n\t\tfor (i = start_index; i < dependencies.length; i++) {\n\t\t\tconst dependency = dependencies[i];\n\t\t\t// Avoid removing a reaction if we know that it is active (start_index will not be 0)\n\t\t\tif (active_dependencies === null || !active_dependencies.includes(dependency)) {\n\t\t\t\tremove_reaction(signal, dependency);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Reaction} signal\n * @param {boolean} [remove_dom]\n * @returns {void}\n */\nexport function destroy_effect_children(signal, remove_dom = true) {\n\tlet effect = signal.first;\n\tsignal.first = null;\n\tsignal.last = null;\n\tvar sibling;\n\twhile (effect !== null) {\n\t\tsibling = effect.next;\n\t\tdestroy_effect(effect, remove_dom);\n\t\teffect = sibling;\n\t}\n}\n\n/**\n * @param {import('#client').Effect} effect\n * @returns {void}\n */\nexport function execute_effect(effect) {\n\tvar flags = effect.f;\n\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn;\n\t}\n\n\tset_signal_status(effect, CLEAN);\n\n\tvar component_context = effect.ctx;\n\n\tvar previous_effect = current_effect;\n\tvar previous_component_context = current_component_context;\n\n\tcurrent_effect = effect;\n\tcurrent_component_context = component_context;\n\n\tif (DEV) {\n\t\tvar previous_component_fn = dev_current_component_function;\n\t\tdev_current_component_function = effect.component_function;\n\t}\n\n\ttry {\n\t\tif ((flags & BLOCK_EFFECT) === 0) {\n\t\t\tdestroy_effect_children(effect);\n\t\t}\n\n\t\texecute_effect_teardown(effect);\n\t\tvar teardown = execute_reaction_fn(effect);\n\t\teffect.teardown = typeof teardown === 'function' ? teardown : null;\n\t} catch (error) {\n\t\thandle_error(/** @type {Error} */ (error), effect, current_component_context);\n\t} finally {\n\t\tcurrent_effect = previous_effect;\n\t\tcurrent_component_context = previous_component_context;\n\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = previous_component_fn;\n\t\t}\n\t}\n}\n\nfunction infinite_loop_guard() {\n\tif (flush_count > 1000) {\n\t\tflush_count = 0;\n\t\te.effect_update_depth_exceeded();\n\t}\n\tflush_count++;\n}\n\n/**\n * @param {Array<import('#client').Effect>} root_effects\n * @returns {void}\n */\nfunction flush_queued_root_effects(root_effects) {\n\tvar length = root_effects.length;\n\tif (length === 0) {\n\t\treturn;\n\t}\n\tinfinite_loop_guard();\n\n\tvar previously_flushing_effect = is_flushing_effect;\n\tis_flushing_effect = true;\n\n\ttry {\n\t\tfor (var i = 0; i < length; i++) {\n\t\t\tvar effect = root_effects[i];\n\n\t\t\t// When working with custom elements, the root effects might not have a root\n\t\t\tif (effect.first === null && (effect.f & BRANCH_EFFECT) === 0) {\n\t\t\t\tflush_queued_effects([effect]);\n\t\t\t} else {\n\t\t\t\t/** @type {import('#client').Effect[]} */\n\t\t\t\tvar collected_effects = [];\n\n\t\t\t\tprocess_effects(effect, collected_effects);\n\t\t\t\tflush_queued_effects(collected_effects);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\tis_flushing_effect = previously_flushing_effect;\n\t}\n}\n\n/**\n * @param {Array<import('#client').Effect>} effects\n * @returns {void}\n */\nfunction flush_queued_effects(effects) {\n\tvar length = effects.length;\n\tif (length === 0) return;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar effect = effects[i];\n\n\t\tif ((effect.f & (DESTROYED | INERT)) === 0 && check_dirtiness(effect)) {\n\t\t\texecute_effect(effect);\n\n\t\t\t// Effects with no dependencies or teardown do not get added to the effect tree.\n\t\t\t// Deferred effects (e.g. `$effect(...)`) _are_ added to the tree because we\n\t\t\t// don't know if we need to keep them until they are executed. Doing the check\n\t\t\t// here (rather than in `execute_effect`) allows us to skip the work for\n\t\t\t// immediate effects.\n\t\t\tif (effect.deps === null && effect.first === null && effect.dom === null) {\n\t\t\t\tif (effect.teardown === null) {\n\t\t\t\t\t// remove this effect from the graph\n\t\t\t\t\tunlink_effect(effect);\n\t\t\t\t} else {\n\t\t\t\t\t// keep the effect in the graph, but free up some memory\n\t\t\t\t\teffect.fn = null;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction process_deferred() {\n\tis_micro_task_queued = false;\n\tif (flush_count > 1001) {\n\t\treturn;\n\t}\n\tconst previous_queued_root_effects = current_queued_root_effects;\n\tcurrent_queued_root_effects = [];\n\tflush_queued_root_effects(previous_queued_root_effects);\n\tif (!is_micro_task_queued) {\n\t\tflush_count = 0;\n\t}\n}\n\n/**\n * @param {import('#client').Effect} signal\n * @returns {void}\n */\nexport function schedule_effect(signal) {\n\tif (current_scheduler_mode === FLUSH_MICROTASK) {\n\t\tif (!is_micro_task_queued) {\n\t\t\tis_micro_task_queued = true;\n\t\t\tqueueMicrotask(process_deferred);\n\t\t}\n\t}\n\n\tvar effect = signal;\n\n\twhile (effect.parent !== null) {\n\t\teffect = effect.parent;\n\t\tvar flags = effect.f;\n\n\t\tif ((flags & BRANCH_EFFECT) !== 0) {\n\t\t\tif ((flags & CLEAN) === 0) return;\n\t\t\tset_signal_status(effect, MAYBE_DIRTY);\n\t\t}\n\t}\n\n\tcurrent_queued_root_effects.push(effect);\n}\n\n/**\n *\n * This function both runs render effects and collects user effects in topological order\n * from the starting effect passed in. Effects will be collected when they match the filtered\n * bitwise flag passed in only. The collected effects array will be populated with all the user\n * effects to be flushed.\n *\n * @param {import('#client').Effect} effect\n * @param {import('#client').Effect[]} collected_effects\n * @returns {void}\n */\nfunction process_effects(effect, collected_effects) {\n\tvar current_effect = effect.first;\n\tvar effects = [];\n\n\tmain_loop: while (current_effect !== null) {\n\t\tvar flags = current_effect.f;\n\t\t// TODO: we probably don't need to check for destroyed as it shouldn't be encountered?\n\t\tvar is_active = (flags & (DESTROYED | INERT)) === 0;\n\t\tvar is_branch = flags & BRANCH_EFFECT;\n\t\tvar is_clean = (flags & CLEAN) !== 0;\n\t\tvar child = current_effect.first;\n\n\t\t// Skip this branch if it's clean\n\t\tif (is_active && (!is_branch || !is_clean)) {\n\t\t\tif (is_branch) {\n\t\t\t\tset_signal_status(current_effect, CLEAN);\n\t\t\t}\n\n\t\t\tif ((flags & RENDER_EFFECT) !== 0) {\n\t\t\t\tif (!is_branch && check_dirtiness(current_effect)) {\n\t\t\t\t\texecute_effect(current_effect);\n\t\t\t\t\t// Child might have been mutated since running the effect\n\t\t\t\t\tchild = current_effect.first;\n\t\t\t\t}\n\n\t\t\t\tif (child !== null) {\n\t\t\t\t\tcurrent_effect = child;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t} else if ((flags & EFFECT) !== 0) {\n\t\t\t\tif (is_branch || is_clean) {\n\t\t\t\t\tif (child !== null) {\n\t\t\t\t\t\tcurrent_effect = child;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\teffects.push(current_effect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar sibling = current_effect.next;\n\n\t\tif (sibling === null) {\n\t\t\tlet parent = current_effect.parent;\n\n\t\t\twhile (parent !== null) {\n\t\t\t\tif (effect === parent) {\n\t\t\t\t\tbreak main_loop;\n\t\t\t\t}\n\t\t\t\tvar parent_sibling = parent.next;\n\t\t\t\tif (parent_sibling !== null) {\n\t\t\t\t\tcurrent_effect = parent_sibling;\n\t\t\t\t\tcontinue main_loop;\n\t\t\t\t}\n\t\t\t\tparent = parent.parent;\n\t\t\t}\n\t\t}\n\n\t\tcurrent_effect = sibling;\n\t}\n\n\t// We might be dealing with many effects here, far more than can be spread into\n\t// an array push call (callstack overflow). So let's deal with each effect in a loop.\n\tfor (var i = 0; i < effects.length; i++) {\n\t\tchild = effects[i];\n\t\tcollected_effects.push(child);\n\t\tprocess_effects(child, collected_effects);\n\t}\n}\n\n/**\n * Internal version of `flushSync` with the option to not flush previous effects.\n * Returns the result of the passed function, if given.\n * @param {() => any} [fn]\n * @param {boolean} [flush_previous]\n * @returns {any}\n */\nexport function flush_sync(fn, flush_previous = true) {\n\tvar previous_scheduler_mode = current_scheduler_mode;\n\tvar previous_queued_root_effects = current_queued_root_effects;\n\n\ttry {\n\t\tinfinite_loop_guard();\n\n\t\t/** @type {import('#client').Effect[]} */\n\t\tconst root_effects = [];\n\n\t\tcurrent_scheduler_mode = FLUSH_SYNC;\n\t\tcurrent_queued_root_effects = root_effects;\n\t\tis_micro_task_queued = false;\n\n\t\tif (flush_previous) {\n\t\t\tflush_queued_root_effects(previous_queued_root_effects);\n\t\t}\n\n\t\tvar result = fn?.();\n\n\t\tflush_tasks();\n\t\tif (current_queued_root_effects.length > 0 || root_effects.length > 0) {\n\t\t\tflush_sync();\n\t\t}\n\n\t\tflush_count = 0;\n\n\t\treturn result;\n\t} finally {\n\t\tcurrent_scheduler_mode = previous_scheduler_mode;\n\t\tcurrent_queued_root_effects = previous_queued_root_effects;\n\t}\n}\n\n/**\n * Returns a promise that resolves once any pending state changes have been applied.\n * @returns {Promise<void>}\n */\nexport async function tick() {\n\tawait Promise.resolve();\n\t// By calling flush_sync we guarantee that any pending state changes are applied after one tick.\n\t// TODO look into whether we can make flushing subsequent updates synchronously in the future.\n\tflush_sync();\n}\n\n/**\n * @template V\n * @param {import('#client').Value<V>} signal\n * @returns {V}\n */\nexport function get(signal) {\n\tconst flags = signal.f;\n\tif ((flags & DESTROYED) !== 0) {\n\t\treturn signal.v;\n\t}\n\n\tif (is_signals_recorded) {\n\t\tcaptured_signals.add(signal);\n\t}\n\n\t// Register the dependency on the current reaction signal.\n\tif (current_reaction !== null) {\n\t\tconst unowned = (current_reaction.f & UNOWNED) !== 0;\n\t\tconst dependencies = current_reaction.deps;\n\t\tif (\n\t\t\tcurrent_dependencies === null &&\n\t\t\tdependencies !== null &&\n\t\t\tdependencies[current_dependencies_index] === signal &&\n\t\t\t!(unowned && current_effect !== null)\n\t\t) {\n\t\t\tcurrent_dependencies_index++;\n\t\t} else if (\n\t\t\tdependencies === null ||\n\t\t\tcurrent_dependencies_index === 0 ||\n\t\t\tdependencies[current_dependencies_index - 1] !== signal\n\t\t) {\n\t\t\tif (current_dependencies === null) {\n\t\t\t\tcurrent_dependencies = [signal];\n\t\t\t} else if (current_dependencies[current_dependencies.length - 1] !== signal) {\n\t\t\t\tcurrent_dependencies.push(signal);\n\t\t\t}\n\t\t}\n\t\tif (\n\t\t\tcurrent_untracked_writes !== null &&\n\t\t\tcurrent_effect !== null &&\n\t\t\t(current_effect.f & CLEAN) !== 0 &&\n\t\t\t(current_effect.f & BRANCH_EFFECT) === 0 &&\n\t\t\tcurrent_untracked_writes.includes(signal)\n\t\t) {\n\t\t\tset_signal_status(current_effect, DIRTY);\n\t\t\tschedule_effect(current_effect);\n\t\t}\n\t}\n\n\tif (\n\t\t(flags & DERIVED) !== 0 &&\n\t\tcheck_dirtiness(/** @type {import('#client').Derived} */ (signal))\n\t) {\n\t\tupdate_derived(/** @type {import('#client').Derived} **/ (signal));\n\t}\n\n\treturn signal.v;\n}\n\n/**\n * Invokes a function and captures all signals that are read during the invocation,\n * then invalidates them.\n * @param {() => any} fn\n */\nexport function invalidate_inner_signals(fn) {\n\tvar previous_is_signals_recorded = is_signals_recorded;\n\tvar previous_captured_signals = captured_signals;\n\tis_signals_recorded = true;\n\tcaptured_signals = new Set();\n\tvar captured = captured_signals;\n\tvar signal;\n\ttry {\n\t\tuntrack(fn);\n\t} finally {\n\t\tis_signals_recorded = previous_is_signals_recorded;\n\t\tif (is_signals_recorded) {\n\t\t\tfor (signal of captured_signals) {\n\t\t\t\tprevious_captured_signals.add(signal);\n\t\t\t}\n\t\t}\n\t\tcaptured_signals = previous_captured_signals;\n\t}\n\tfor (signal of captured) {\n\t\t// Go one level up because derived signals created as part of props in legacy mode\n\t\tif ((signal.f & LEGACY_DERIVED_PROP) !== 0) {\n\t\t\tfor (const dep of /** @type {import('#client').Derived} */ (signal).deps || []) {\n\t\t\t\tif ((dep.f & DERIVED) === 0) {\n\t\t\t\t\tmutate(dep, null /* doesnt matter */);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tmutate(signal, null /* doesnt matter */);\n\t\t}\n\t}\n}\n\n/**\n * @param {import('#client').Value} signal\n * @param {number} to_status should be DIRTY or MAYBE_DIRTY\n * @param {boolean} force_schedule\n * @returns {void}\n */\nexport function mark_reactions(signal, to_status, force_schedule) {\n\tvar reactions = signal.reactions;\n\tif (reactions === null) return;\n\n\tvar runes = is_runes();\n\tvar length = reactions.length;\n\n\tfor (var i = 0; i < length; i++) {\n\t\tvar reaction = reactions[i];\n\t\tvar flags = reaction.f;\n\n\t\tif (DEV && (flags & INSPECT_EFFECT) !== 0) {\n\t\t\tinspect_effects.add(reaction);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// We skip any effects that are already dirty. Additionally, we also\n\t\t// skip if the reaction is the same as the current effect (except if we're not in runes or we\n\t\t// are in force schedule mode).\n\t\tif ((flags & DIRTY) !== 0 || ((!force_schedule || !runes) && reaction === current_effect)) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tset_signal_status(reaction, to_status);\n\n\t\t// If the signal is not clean, then skip over it  with the exception of unowned signals that\n\t\t// are already maybe dirty. Unowned signals might be dirty because they are not captured as part of an\n\t\t// effect.\n\t\tvar maybe_dirty = (flags & MAYBE_DIRTY) !== 0;\n\t\tvar unowned = (flags & UNOWNED) !== 0;\n\n\t\tif ((flags & CLEAN) !== 0 || (maybe_dirty && unowned)) {\n\t\t\tif ((reaction.f & DERIVED) !== 0) {\n\t\t\t\tmark_reactions(\n\t\t\t\t\t/** @type {import('#client').Derived} */ (reaction),\n\t\t\t\t\tMAYBE_DIRTY,\n\t\t\t\t\tforce_schedule\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tschedule_effect(/** @type {import('#client').Effect} */ (reaction));\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Use `untrack` to prevent something from being treated as an `$effect`/`$derived` dependency.\n *\n * https://svelte-5-preview.vercel.app/docs/functions#untrack\n * @template T\n * @param {() => T} fn\n * @returns {T}\n */\nexport function untrack(fn) {\n\tconst previous_reaction = current_reaction;\n\ttry {\n\t\tcurrent_reaction = null;\n\t\treturn fn();\n\t} finally {\n\t\tcurrent_reaction = previous_reaction;\n\t}\n}\n\nconst STATUS_MASK = ~(DIRTY | MAYBE_DIRTY | CLEAN);\n\n/**\n * @param {import('#client').Signal} signal\n * @param {number} status\n * @returns {void}\n */\nexport function set_signal_status(signal, status) {\n\tsignal.f = (signal.f & STATUS_MASK) | status;\n}\n\n/**\n * @template V\n * @param {V | import('#client').Value<V>} val\n * @returns {val is import('#client').Value<V>}\n */\nexport function is_signal(val) {\n\treturn (\n\t\ttypeof val === 'object' &&\n\t\tval !== null &&\n\t\ttypeof (/** @type {import('#client').Value<V>} */ (val).f) === 'number'\n\t);\n}\n\n/**\n * Retrieves the context that belongs to the closest parent component with the specified `key`.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#getcontext\n * @template T\n * @param {any} key\n * @returns {T}\n */\nexport function getContext(key) {\n\tconst context_map = get_or_init_context_map('getContext');\n\tconst result = /** @type {T} */ (context_map.get(key));\n\n\tif (DEV) {\n\t\tconst fn = /** @type {import('#client').ComponentContext} */ (current_component_context)\n\t\t\t.function;\n\t\tif (fn) {\n\t\t\tadd_owner(result, fn, true);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Associates an arbitrary `context` object with the current component and the specified `key`\n * and returns that object. The context is then available to children of the component\n * (including slotted content) with `getContext`.\n *\n * Like lifecycle functions, this must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#setcontext\n * @template T\n * @param {any} key\n * @param {T} context\n * @returns {T}\n */\nexport function setContext(key, context) {\n\tconst context_map = get_or_init_context_map('setContext');\n\tcontext_map.set(key, context);\n\treturn context;\n}\n\n/**\n * Checks whether a given `key` has been set in the context of a parent component.\n * Must be called during component initialisation.\n *\n * https://svelte.dev/docs/svelte#hascontext\n * @param {any} key\n * @returns {boolean}\n */\nexport function hasContext(key) {\n\tconst context_map = get_or_init_context_map('hasContext');\n\treturn context_map.has(key);\n}\n\n/**\n * Retrieves the whole context map that belongs to the closest parent component.\n * Must be called during component initialisation. Useful, for example, if you\n * programmatically create a component and want to pass the existing context to it.\n *\n * https://svelte.dev/docs/svelte#getallcontexts\n * @template {Map<any, any>} [T=Map<any, any>]\n * @returns {T}\n */\nexport function getAllContexts() {\n\tconst context_map = get_or_init_context_map('getAllContexts');\n\n\tif (DEV) {\n\t\tconst fn = current_component_context?.function;\n\t\tif (fn) {\n\t\t\tfor (const value of context_map.values()) {\n\t\t\t\tadd_owner(value, fn, true);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn /** @type {T} */ (context_map);\n}\n\n/**\n * @param {string} name\n * @returns {Map<unknown, unknown>}\n */\nfunction get_or_init_context_map(name) {\n\tif (current_component_context === null) {\n\t\tlifecycle_outside_component(name);\n\t}\n\n\treturn (current_component_context.c ??= new Map(\n\t\tget_parent_context(current_component_context) || undefined\n\t));\n}\n\n/**\n * @param {import('#client').ComponentContext} component_context\n * @returns {Map<unknown, unknown> | null}\n */\nfunction get_parent_context(component_context) {\n\tlet parent = component_context.p;\n\twhile (parent !== null) {\n\t\tconst context_map = parent.c;\n\t\tif (context_map !== null) {\n\t\t\treturn context_map;\n\t\t}\n\t\tparent = parent.p;\n\t}\n\treturn null;\n}\n\n/**\n * @param {import('#client').Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update(signal, d = 1) {\n\tvar value = +get(signal);\n\tset(signal, value + d);\n\treturn value;\n}\n\n/**\n * @param {import('#client').Value<number>} signal\n * @param {1 | -1} [d]\n * @returns {number}\n */\nexport function update_pre(signal, d = 1) {\n\treturn set(signal, +get(signal) + d);\n}\n\n/**\n * @param {Record<string, unknown>} obj\n * @param {string[]} keys\n * @returns {Record<string, unknown>}\n */\nexport function exclude_from_object(obj, keys) {\n\tobj = { ...obj };\n\tlet key;\n\tfor (key of keys) {\n\t\tdelete obj[key];\n\t}\n\treturn obj;\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {() => V} fallback lazy because could contain side effects\n * @returns {V}\n */\nexport function value_or_fallback(value, fallback) {\n\treturn value === undefined ? fallback() : value;\n}\n\n/**\n * @template V\n * @param {V} value\n * @param {() => Promise<V>} fallback lazy because could contain side effects\n * @returns {Promise<V>}\n */\nexport async function value_or_fallback_async(value, fallback) {\n\treturn value === undefined ? fallback() : value;\n}\n\n/**\n * @param {Record<string, unknown>} props\n * @param {any} runes\n * @param {Function} [fn]\n * @returns {void}\n */\nexport function push(props, runes = false, fn) {\n\tcurrent_component_context = {\n\t\tp: current_component_context,\n\t\tc: null,\n\t\te: null,\n\t\tm: false,\n\t\ts: props,\n\t\tx: null,\n\t\tl: null\n\t};\n\n\tif (!runes) {\n\t\tcurrent_component_context.l = {\n\t\t\ts: null,\n\t\t\tu: null,\n\t\t\tr1: [],\n\t\t\tr2: source(false)\n\t\t};\n\t}\n\n\tif (DEV) {\n\t\t// component function\n\t\tcurrent_component_context.function = fn;\n\t\tdev_current_component_function = fn;\n\t}\n}\n\n/**\n * @template {Record<string, any>} T\n * @param {T} [component]\n * @returns {T}\n */\nexport function pop(component) {\n\tconst context_stack_item = current_component_context;\n\tif (context_stack_item !== null) {\n\t\tif (component !== undefined) {\n\t\t\tcontext_stack_item.x = component;\n\t\t}\n\t\tconst effects = context_stack_item.e;\n\t\tif (effects !== null) {\n\t\t\tcontext_stack_item.e = null;\n\t\t\tfor (var i = 0; i < effects.length; i++) {\n\t\t\t\teffect(effects[i]);\n\t\t\t}\n\t\t}\n\t\tcurrent_component_context = context_stack_item.p;\n\t\tif (DEV) {\n\t\t\tdev_current_component_function = context_stack_item.p?.function ?? null;\n\t\t}\n\t\tcontext_stack_item.m = true;\n\t}\n\t// Micro-optimization: Don't set .a above to the empty object\n\t// so it can be garbage-collected when the return here is unused\n\treturn component || /** @type {T} */ ({});\n}\n\n/**\n * Possibly traverse an object and read all its properties so that they're all reactive in case this is `$state`.\n * Does only check first level of an object for performance reasons (heuristic should be good for 99% of all cases).\n * @param {any} value\n * @returns {void}\n */\nexport function deep_read_state(value) {\n\tif (typeof value !== 'object' || !value || value instanceof EventTarget) {\n\t\treturn;\n\t}\n\n\tif (STATE_SYMBOL in value) {\n\t\tdeep_read(value);\n\t} else if (!Array.isArray(value)) {\n\t\tfor (let key in value) {\n\t\t\tconst prop = value[key];\n\t\t\tif (typeof prop === 'object' && prop && STATE_SYMBOL in prop) {\n\t\t\t\tdeep_read(prop);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Deeply traverse an object and read all its properties\n * so that they're all reactive in case this is `$state`\n * @param {any} value\n * @param {Set<any>} visited\n * @returns {void}\n */\nexport function deep_read(value, visited = new Set()) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue !== null &&\n\t\t// We don't want to traverse DOM elements\n\t\t!(value instanceof EventTarget) &&\n\t\t!visited.has(value)\n\t) {\n\t\tvisited.add(value);\n\t\t// When working with a possible ReactiveDate, this\n\t\t// will ensure we capture changes to it.\n\t\tif (value instanceof Date) {\n\t\t\tvalue.getTime();\n\t\t}\n\t\tfor (let key in value) {\n\t\t\ttry {\n\t\t\t\tdeep_read(value[key], visited);\n\t\t\t} catch (e) {\n\t\t\t\t// continue\n\t\t\t}\n\t\t}\n\t\tconst proto = get_prototype_of(value);\n\t\tif (\n\t\t\tproto !== Object.prototype &&\n\t\t\tproto !== Array.prototype &&\n\t\t\tproto !== Map.prototype &&\n\t\t\tproto !== Set.prototype &&\n\t\t\tproto !== Date.prototype\n\t\t) {\n\t\t\tconst descriptors = get_descriptors(proto);\n\t\t\tfor (let key in descriptors) {\n\t\t\t\tconst get = descriptors[key].get;\n\t\t\t\tif (get) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tget.call(value);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\t// continue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * @template V\n * @param {V | import('#client').Value<V>} value\n * @returns {V}\n */\nexport function unwrap(value) {\n\tif (is_signal(value)) {\n\t\t// @ts-ignore\n\t\treturn get(value);\n\t}\n\t// @ts-ignore\n\treturn value;\n}\n\nif (DEV) {\n\t/**\n\t * @param {string} rune\n\t */\n\tfunction throw_rune_error(rune) {\n\t\tif (!(rune in globalThis)) {\n\t\t\t// TODO if people start adjusting the \"this can contain runes\" config through v-p-s more, adjust this message\n\t\t\t/** @type {any} */\n\t\t\tlet value; // let's hope noone modifies this global, but belts and braces\n\t\t\tObject.defineProperty(globalThis, rune, {\n\t\t\t\tconfigurable: true,\n\t\t\t\t// eslint-disable-next-line getter-return\n\t\t\t\tget: () => {\n\t\t\t\t\tif (value !== undefined) {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t}\n\n\t\t\t\t\te.rune_outside_svelte(rune);\n\t\t\t\t},\n\t\t\t\tset: (v) => {\n\t\t\t\t\tvalue = v;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t}\n\n\tthrow_rune_error('$state');\n\tthrow_rune_error('$effect');\n\tthrow_rune_error('$derived');\n\tthrow_rune_error('$inspect');\n\tthrow_rune_error('$props');\n\tthrow_rune_error('$bindable');\n}\n\n/**\n * Expects a value that was wrapped with `freeze` and makes it frozen in DEV.\n * @template T\n * @param {T} value\n * @returns {Readonly<T>}\n */\nexport function freeze(value) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue != null &&\n\t\t!is_frozen(value) &&\n\t\t!(STATE_FROZEN_SYMBOL in value)\n\t) {\n\t\t// If the object is already proxified, then snapshot the value\n\t\tif (STATE_SYMBOL in value) {\n\t\t\tvalue = snapshot(value);\n\t\t}\n\t\tdefine_property(value, STATE_FROZEN_SYMBOL, {\n\t\t\tvalue: true,\n\t\t\twritable: true,\n\t\t\tenumerable: false\n\t\t});\n\t\t// Freeze the object in DEV\n\t\tif (DEV) {\n\t\t\tobject_freeze(value);\n\t\t}\n\t}\n\treturn value;\n}\n","import { DEV } from 'esm-env';\nimport { HYDRATION_END, HYDRATION_START, HYDRATION_ERROR } from '../../../constants.js';\nimport * as w from '../warnings.js';\n\n/**\n * Use this variable to guard everything related to hydration code so it can be treeshaken out\n * if the user doesn't use the `hydrate` method and these code paths are therefore not needed.\n */\nexport let hydrating = false;\n\n/** @param {boolean} value */\nexport function set_hydrating(value) {\n\thydrating = value;\n}\n\n/**\n * Array of nodes to traverse for hydration. This will be null if we're not hydrating, but for\n * the sake of simplicity we're not going to use `null` checks everywhere and instead rely on\n * the `hydrating` flag to tell whether or not we're in hydration mode at which point this is set.\n * @type {import('#client').TemplateNode[]}\n */\nexport let hydrate_nodes = /** @type {any} */ (null);\n\n/** @type {import('#client').TemplateNode} */\nexport let hydrate_start;\n\n/** @param {import('#client').TemplateNode[]} nodes */\nexport function set_hydrate_nodes(nodes) {\n\thydrate_nodes = nodes;\n\thydrate_start = nodes && nodes[0];\n}\n\n/**\n * This function is only called when `hydrating` is true. If passed a `<!--[-->` opening\n * hydration marker, it finds the corresponding closing marker and sets `hydrate_nodes`\n * to everything between the markers, before returning the closing marker.\n * @param {Node} node\n * @returns {Node}\n */\nexport function hydrate_anchor(node) {\n\tif (node.nodeType !== 8) {\n\t\treturn node;\n\t}\n\n\tvar current = /** @type {Node | null} */ (node);\n\n\t// TODO this could have false positives, if a user comment consisted of `[`. need to tighten that up\n\tif (/** @type {Comment} */ (current).data !== HYDRATION_START) {\n\t\treturn node;\n\t}\n\n\t/** @type {Node[]} */\n\tvar nodes = [];\n\tvar depth = 0;\n\n\twhile ((current = /** @type {Node} */ (current).nextSibling) !== null) {\n\t\tif (current.nodeType === 8) {\n\t\t\tvar data = /** @type {Comment} */ (current).data;\n\n\t\t\tif (data === HYDRATION_START) {\n\t\t\t\tdepth += 1;\n\t\t\t} else if (data[0] === HYDRATION_END) {\n\t\t\t\tif (depth === 0) {\n\t\t\t\t\thydrate_nodes = /** @type {import('#client').TemplateNode[]} */ (nodes);\n\t\t\t\t\thydrate_start = /** @type {import('#client').TemplateNode} */ (nodes[0]);\n\t\t\t\t\treturn current;\n\t\t\t\t}\n\n\t\t\t\tdepth -= 1;\n\t\t\t}\n\t\t}\n\n\t\tnodes.push(current);\n\t}\n\n\tlet location;\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\tconst loc = node.parentNode?.__svelte_meta?.loc;\n\t\tif (loc) {\n\t\t\tlocation = `${loc.file}:${loc.line}:${loc.column}`;\n\t\t}\n\t}\n\n\tw.hydration_mismatch(location);\n\tthrow HYDRATION_ERROR;\n}\n","import { hydrate_anchor, hydrate_start, hydrating } from './hydration.js';\nimport { DEV } from 'esm-env';\nimport { init_array_prototype_warnings } from '../dev/equality.js';\nimport { current_effect } from '../runtime.js';\nimport { HYDRATION_ANCHOR } from '../../../constants.js';\n\n// export these for reference in the compiled code, making global name deduplication unnecessary\n/** @type {Window} */\nexport var $window;\n\n/** @type {Document} */\nexport var $document;\n\n/**\n * Initialize these lazily to avoid issues when using the runtime in a server context\n * where these globals are not available while avoiding a separate server entry point\n */\nexport function init_operations() {\n\tif ($window !== undefined) {\n\t\treturn;\n\t}\n\n\t$window = window;\n\t$document = document;\n\n\tvar element_prototype = Element.prototype;\n\n\t// the following assignments improve perf of lookups on DOM nodes\n\t// @ts-expect-error\n\telement_prototype.__click = undefined;\n\t// @ts-expect-error\n\telement_prototype.__className = '';\n\t// @ts-expect-error\n\telement_prototype.__attributes = null;\n\t// @ts-expect-error\n\telement_prototype.__e = undefined;\n\n\t// @ts-expect-error\n\tText.prototype.__t = undefined;\n\n\tif (DEV) {\n\t\t// @ts-expect-error\n\t\telement_prototype.__svelte_meta = null;\n\n\t\tinit_array_prototype_warnings();\n\t}\n}\n\n/** @returns {Text} */\nexport function empty() {\n\treturn document.createTextNode('');\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function child(node) {\n\tconst child = node.firstChild;\n\tif (!hydrating) return child;\n\n\t// Child can be null if we have an element with a single child, like `<p>{text}</p>`, where `text` is empty\n\tif (child === null) {\n\t\treturn node.appendChild(empty());\n\t}\n\n\treturn hydrate_anchor(child);\n}\n\n/**\n * @param {DocumentFragment | import('#client').TemplateNode[]} fragment\n * @param {boolean} is_text\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function first_child(fragment, is_text) {\n\tif (!hydrating) {\n\t\t// when not hydrating, `fragment` is a `DocumentFragment` (the result of calling `open_frag`)\n\t\treturn /** @type {DocumentFragment} */ (fragment).firstChild;\n\t}\n\n\t// if an {expression} is empty during SSR, there might be no\n\t// text node to hydrate  we must therefore create one\n\tif (is_text && hydrate_start?.nodeType !== 3) {\n\t\tvar text = empty();\n\t\tvar dom = /** @type {import('#client').TemplateNode[]} */ (\n\t\t\t/** @type {import('#client').Effect} */ (current_effect).dom\n\t\t);\n\n\t\tdom.unshift(text);\n\t\thydrate_start?.before(text);\n\n\t\treturn text;\n\t}\n\n\treturn hydrate_anchor(hydrate_start);\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @param {boolean} is_text\n * @returns {Node | null}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function sibling(node, is_text = false) {\n\tvar next_sibling = /** @type {import('#client').TemplateNode} */ (node.nextSibling);\n\n\tif (!hydrating) {\n\t\treturn next_sibling;\n\t}\n\n\tvar type = next_sibling.nodeType;\n\n\tif (type === 8 && /** @type {Comment} */ (next_sibling).data === HYDRATION_ANCHOR) {\n\t\treturn sibling(next_sibling, is_text);\n\t}\n\n\t// if a sibling {expression} is empty during SSR, there might be no\n\t// text node to hydrate  we must therefore create one\n\tif (is_text && type !== 3) {\n\t\tvar text = empty();\n\t\tvar dom = /** @type {import('#client').TemplateNode[]} */ (\n\t\t\t/** @type {import('#client').Effect} */ (current_effect).dom\n\t\t);\n\n\t\tdom.unshift(text);\n\t\tnext_sibling?.before(text);\n\n\t\treturn text;\n\t}\n\n\treturn hydrate_anchor(/** @type {Node} */ (next_sibling));\n}\n\n/**\n * @template {Node} N\n * @param {N} node\n * @returns {void}\n */\nexport function clear_text_content(node) {\n\tnode.textContent = '';\n}\n\n/** @param {string} name */\n/*#__NO_SIDE_EFFECTS__*/\nexport function create_element(name) {\n\treturn document.createElement(name);\n}\n","import { teardown } from '../../reactivity/effects.js';\nimport { all_registered_events, root_event_handles } from '../../render.js';\nimport { define_property, is_array } from '../../utils.js';\nimport { hydrating } from '../hydration.js';\nimport { queue_micro_task } from '../task.js';\n\n/**\n * SSR adds onload and onerror attributes to catch those events before the hydration.\n * This function detects those cases, removes the attributes and replays the events.\n * @param {HTMLElement} dom\n */\nexport function replay_events(dom) {\n\tif (!hydrating) return;\n\n\tif (dom.onload) {\n\t\tdom.removeAttribute('onload');\n\t}\n\tif (dom.onerror) {\n\t\tdom.removeAttribute('onerror');\n\t}\n\t// @ts-expect-error\n\tconst event = dom.__e;\n\tif (event !== undefined) {\n\t\t// @ts-expect-error\n\t\tdom.__e = undefined;\n\t\tqueueMicrotask(() => {\n\t\t\tif (dom.isConnected) {\n\t\t\t\tdom.dispatchEvent(event);\n\t\t\t}\n\t\t});\n\t}\n}\n\n/**\n * @param {string} event_name\n * @param {EventTarget} dom\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} options\n */\nexport function create_event(event_name, dom, handler, options) {\n\t/**\n\t * @this {EventTarget}\n\t */\n\tfunction target_handler(/** @type {Event} */ event) {\n\t\tif (!options.capture) {\n\t\t\t// Only call in the bubble phase, else delegated events would be called before the capturing events\n\t\t\thandle_event_propagation(dom, event);\n\t\t}\n\t\tif (!event.cancelBubble) {\n\t\t\treturn handler.call(this, event);\n\t\t}\n\t}\n\n\t// Chrome has a bug where pointer events don't work when attached to a DOM element that has been cloned\n\t// with cloneNode() and the DOM element is disconnected from the document. To ensure the event works, we\n\t// defer the attachment till after it's been appended to the document. TODO: remove this once Chrome fixes\n\t// this bug. The same applies to wheel events.\n\tif (event_name.startsWith('pointer') || event_name === 'wheel') {\n\t\tqueue_micro_task(() => {\n\t\t\tdom.addEventListener(event_name, target_handler, options);\n\t\t});\n\t} else {\n\t\tdom.addEventListener(event_name, target_handler, options);\n\t}\n\n\treturn target_handler;\n}\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @template {HTMLElement} Element\n * @template {keyof HTMLElementEventMap} Type\n * @overload\n * @param {Element} element\n * @param {Type} type\n * @param {(this: Element, event: HTMLElementEventMap[Type]) => any} handler\n * @param {AddEventListenerOptions} [options]\n * @returns {() => void}\n */\n\n/**\n * Attaches an event handler to an element and returns a function that removes the handler. Using this\n * rather than `addEventListener` will preserve the correct order relative to handlers added declaratively\n * (with attributes like `onclick`), which use event delegation for performance reasons\n *\n * @overload\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n * @returns {() => void}\n */\n\n/**\n * @param {EventTarget} element\n * @param {string} type\n * @param {EventListener} handler\n * @param {AddEventListenerOptions} [options]\n */\nexport function on(element, type, handler, options = {}) {\n\tvar target_handler = create_event(type, element, handler, options);\n\n\treturn () => {\n\t\telement.removeEventListener(type, target_handler, options);\n\t};\n}\n\n/**\n * @param {string} event_name\n * @param {Element} dom\n * @param {EventListener} handler\n * @param {boolean} capture\n * @param {boolean} [passive]\n * @returns {void}\n */\nexport function event(event_name, dom, handler, capture, passive) {\n\tvar options = { capture, passive };\n\tvar target_handler = create_event(event_name, dom, handler, options);\n\n\t// @ts-ignore\n\tif (dom === document.body || dom === window || dom === document) {\n\t\tteardown(() => {\n\t\t\tdom.removeEventListener(event_name, target_handler, options);\n\t\t});\n\t}\n}\n\n/**\n * @param {Array<string>} events\n * @returns {void}\n */\nexport function delegate(events) {\n\tfor (var i = 0; i < events.length; i++) {\n\t\tall_registered_events.add(events[i]);\n\t}\n\n\tfor (var fn of root_event_handles) {\n\t\tfn(events);\n\t}\n}\n\n/**\n * @param {EventTarget} handler_element\n * @param {Event} event\n * @returns {void}\n */\nexport function handle_event_propagation(handler_element, event) {\n\tvar owner_document = /** @type {Node} */ (handler_element).ownerDocument;\n\tvar event_name = event.type;\n\tvar path = event.composedPath?.() || [];\n\tvar current_target = /** @type {null | Element} */ (path[0] || event.target);\n\n\t// composedPath contains list of nodes the event has propagated through.\n\t// We check __root to skip all nodes below it in case this is a\n\t// parent of the __root node, which indicates that there's nested\n\t// mounted apps. In this case we don't want to trigger events multiple times.\n\tvar path_idx = 0;\n\n\t// @ts-expect-error is added below\n\tvar handled_at = event.__root;\n\n\tif (handled_at) {\n\t\tvar at_idx = path.indexOf(handled_at);\n\t\tif (\n\t\t\tat_idx !== -1 &&\n\t\t\t(handler_element === document || handler_element === /** @type {any} */ (window))\n\t\t) {\n\t\t\t// This is the fallback document listener or a window listener, but the event was already handled\n\t\t\t// -> ignore, but set handle_at to document/window so that we're resetting the event\n\t\t\t// chain in case someone manually dispatches the same event object again.\n\t\t\t// @ts-expect-error\n\t\t\tevent.__root = handler_element;\n\t\t\treturn;\n\t\t}\n\n\t\t// We're deliberately not skipping if the index is higher, because\n\t\t// someone could create an event programmatically and emit it multiple times,\n\t\t// in which case we want to handle the whole propagation chain properly each time.\n\t\t// (this will only be a false negative if the event is dispatched multiple times and\n\t\t// the fallback document listener isn't reached in between, but that's super rare)\n\t\tvar handler_idx = path.indexOf(handler_element);\n\t\tif (handler_idx === -1) {\n\t\t\t// handle_idx can theoretically be -1 (happened in some JSDOM testing scenarios with an event listener on the window object)\n\t\t\t// so guard against that, too, and assume that everything was handled at this point.\n\t\t\treturn;\n\t\t}\n\n\t\tif (at_idx <= handler_idx) {\n\t\t\tpath_idx = at_idx;\n\t\t}\n\t}\n\n\tcurrent_target = /** @type {Element} */ (path[path_idx] || event.target);\n\t// there can only be one delegated event per element, and we either already handled the current target,\n\t// or this is the very first target in the chain which has a non-delegated listener, in which case it's safe\n\t// to handle a possible delegated event on it later (through the root delegation listener for example).\n\tif (current_target === handler_element) return;\n\n\t// Proxy currentTarget to correct target\n\tdefine_property(event, 'currentTarget', {\n\t\tconfigurable: true,\n\t\tget() {\n\t\t\treturn current_target || owner_document;\n\t\t}\n\t});\n\n\ttry {\n\t\t/**\n\t\t * @type {unknown}\n\t\t */\n\t\tvar throw_error;\n\t\t/**\n\t\t * @type {unknown[]}\n\t\t */\n\t\tvar other_errors = [];\n\n\t\twhile (current_target !== null) {\n\t\t\t/** @type {null | Element} */\n\t\t\tvar parent_element =\n\t\t\t\tcurrent_target.parentNode || /** @type {any} */ (current_target).host || null;\n\n\t\t\ttry {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvar delegated = current_target['__' + event_name];\n\n\t\t\t\tif (delegated !== undefined && !(/** @type {any} */ (current_target).disabled)) {\n\t\t\t\t\tif (is_array(delegated)) {\n\t\t\t\t\t\tvar [fn, ...data] = delegated;\n\t\t\t\t\t\tfn.apply(current_target, [event, ...data]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tdelegated.call(current_target, event);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tif (throw_error) {\n\t\t\t\t\tother_errors.push(error);\n\t\t\t\t} else {\n\t\t\t\t\tthrow_error = error;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (event.cancelBubble || parent_element === handler_element || parent_element === null) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcurrent_target = parent_element;\n\t\t}\n\n\t\tif (throw_error) {\n\t\t\tfor (let error of other_errors) {\n\t\t\t\t// Throw the rest of the errors, one-by-one on a microtask\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tthrow error;\n\t\t\t\t});\n\t\t\t}\n\t\t\tthrow throw_error;\n\t\t}\n\t} finally {\n\t\t// @ts-expect-error is used above\n\t\tevent.__root = handler_element;\n\t\t// @ts-expect-error is used above\n\t\tcurrent_target = handler_element;\n\t}\n}\n","import { hydrate_anchor, hydrate_nodes, hydrating, set_hydrate_nodes } from '../hydration.js';\nimport { empty } from '../operations.js';\nimport { block } from '../../reactivity/effects.js';\nimport { HYDRATION_END, HYDRATION_START } from '../../../../constants.js';\n\n/**\n * @type {Node | undefined}\n */\nlet head_anchor;\n\nexport function reset_head_anchor() {\n\thead_anchor = undefined;\n}\n\n/**\n * @param {(anchor: Node) => import('#client').Dom | void} render_fn\n * @returns {void}\n */\nexport function head(render_fn) {\n\t// The head function may be called after the first hydration pass and ssr comment nodes may still be present,\n\t// therefore we need to skip that when we detect that we're not in hydration mode.\n\tlet previous_hydrate_nodes = null;\n\tlet was_hydrating = hydrating;\n\n\t/** @type {Comment | Text} */\n\tvar anchor;\n\n\tif (hydrating) {\n\t\tprevious_hydrate_nodes = hydrate_nodes;\n\n\t\t// There might be multiple head blocks in our app, so we need to account for each one needing independent hydration.\n\t\tif (head_anchor === undefined) {\n\t\t\thead_anchor = /** @type {import('#client').TemplateNode} */ (document.head.firstChild);\n\t\t}\n\n\t\twhile (\n\t\t\thead_anchor.nodeType !== 8 ||\n\t\t\t/** @type {Comment} */ (head_anchor).data !== HYDRATION_START\n\t\t) {\n\t\t\thead_anchor = /** @type {import('#client').TemplateNode} */ (head_anchor.nextSibling);\n\t\t}\n\n\t\thead_anchor = /** @type {import('#client').TemplateNode} */ (hydrate_anchor(head_anchor));\n\t\thead_anchor = /** @type {import('#client').TemplateNode} */ (head_anchor.nextSibling);\n\t} else {\n\t\tanchor = document.head.appendChild(empty());\n\t}\n\n\ttry {\n\t\tblock(() => render_fn(anchor));\n\t} finally {\n\t\tif (was_hydrating) {\n\t\t\tset_hydrate_nodes(/** @type {import('#client').TemplateNode[]} */ (previous_hydrate_nodes));\n\t\t}\n\t}\n}\n","import { DEV } from 'esm-env';\nimport { clear_text_content, create_element, empty, init_operations } from './dom/operations.js';\nimport { HYDRATION_ERROR, HYDRATION_START, PassiveDelegatedEvents } from '../../constants.js';\nimport { flush_sync, push, pop, current_component_context } from './runtime.js';\nimport { effect_root, branch } from './reactivity/effects.js';\nimport {\n\thydrate_anchor,\n\thydrate_nodes,\n\thydrating,\n\tset_hydrate_nodes,\n\tset_hydrating\n} from './dom/hydration.js';\nimport { array_from } from './utils.js';\nimport { handle_event_propagation } from './dom/elements/events.js';\nimport { reset_head_anchor } from './dom/blocks/svelte-head.js';\nimport * as w from './warnings.js';\nimport * as e from './errors.js';\nimport { validate_component } from '../shared/validate.js';\n\n/** @type {Set<string>} */\nexport const all_registered_events = new Set();\n\n/** @type {Set<(events: Array<string>) => void>} */\nexport const root_event_handles = new Set();\n\n/**\n * This is normally true  block effects should run their intro transitions \n * but is false during hydration and mounting (unless `options.intro` is `true`)\n * and when creating the children of a `<svelte:element>` that just changed tag\n */\nexport let should_intro = true;\n\n/** @param {boolean} value */\nexport function set_should_intro(value) {\n\tshould_intro = value;\n}\n\n/**\n * @param {Element} text\n * @param {string} value\n * @returns {void}\n */\nexport function set_text(text, value) {\n\t// @ts-expect-error\n\tconst prev = (text.__t ??= text.nodeValue);\n\n\tif (prev !== value) {\n\t\t// @ts-expect-error\n\t\ttext.nodeValue = text.__t = value;\n\t}\n}\n\n/**\n * @param {Comment} anchor\n * @param {void | ((anchor: Comment, slot_props: Record<string, unknown>) => void)} slot_fn\n * @param {Record<string, unknown>} slot_props\n * @param {null | ((anchor: Comment) => void)} fallback_fn\n */\nexport function slot(anchor, slot_fn, slot_props, fallback_fn) {\n\tif (slot_fn === undefined) {\n\t\tif (fallback_fn !== null) {\n\t\t\tfallback_fn(anchor);\n\t\t}\n\t} else {\n\t\tslot_fn(anchor, slot_props);\n\t}\n}\n\n/**\n * Mounts a component to the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {import('../../index.js').ComponentType<import('../../index.js').SvelteComponent<Props>> | import('../../index.js').Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tanchor?: Node;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}: {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tanchor?: Node;\n * \t\tevents?: Record<string, (e: any) => any>;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function mount(component, options) {\n\tif (DEV) {\n\t\tvalidate_component(component);\n\t}\n\n\tconst anchor = options.anchor ?? options.target.appendChild(empty());\n\t// Don't flush previous effects to ensure order of outer effects stays consistent\n\treturn flush_sync(() => _mount(component, { ...options, anchor }), false);\n}\n\n/**\n * Hydrates a component on the given target and returns the exports and potentially the props (if compiled with `accessors: true`) of the component\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @param {import('../../index.js').ComponentType<import('../../index.js').SvelteComponent<Props>> | import('../../index.js').Component<Props, Exports, any>} component\n * @param {{} extends Props ? {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops?: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t} : {\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tprops: Props;\n * \t\tevents?: Record<string, (e: any) => any>;\n *  \tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t\trecover?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nexport function hydrate(component, options) {\n\tif (DEV) {\n\t\tvalidate_component(component);\n\t}\n\n\tconst target = options.target;\n\tconst previous_hydrate_nodes = hydrate_nodes;\n\n\ttry {\n\t\t// Don't flush previous effects to ensure order of outer effects stays consistent\n\t\treturn flush_sync(() => {\n\t\t\tset_hydrating(true);\n\n\t\t\tvar node = target.firstChild;\n\t\t\twhile (\n\t\t\t\tnode &&\n\t\t\t\t(node.nodeType !== 8 || /** @type {Comment} */ (node).data !== HYDRATION_START)\n\t\t\t) {\n\t\t\t\tnode = node.nextSibling;\n\t\t\t}\n\n\t\t\tif (!node) {\n\t\t\t\tthrow HYDRATION_ERROR;\n\t\t\t}\n\n\t\t\tconst anchor = hydrate_anchor(node);\n\t\t\tconst instance = _mount(component, { ...options, anchor });\n\n\t\t\t// flush_sync will run this callback and then synchronously run any pending effects,\n\t\t\t// which don't belong to the hydration phase anymore - therefore reset it here\n\t\t\tset_hydrating(false);\n\n\t\t\treturn instance;\n\t\t}, false);\n\t} catch (error) {\n\t\tif (error === HYDRATION_ERROR) {\n\t\t\tif (options.recover === false) {\n\t\t\t\te.hydration_failed();\n\t\t\t}\n\n\t\t\t// If an error occured above, the operations might not yet have been initialised.\n\t\t\tinit_operations();\n\t\t\tclear_text_content(target);\n\n\t\t\tset_hydrating(false);\n\t\t\treturn mount(component, options);\n\t\t}\n\n\t\tthrow error;\n\t} finally {\n\t\tset_hydrating(!!previous_hydrate_nodes);\n\t\tset_hydrate_nodes(previous_hydrate_nodes);\n\t\treset_head_anchor();\n\t}\n}\n\n/**\n * @template {Record<string, any>} Exports\n * @param {import('../../index.js').ComponentType<import('../../index.js').SvelteComponent<any>> | import('../../index.js').Component<any>} Component\n * @param {{\n * \t\ttarget: Document | Element | ShadowRoot;\n * \t\tanchor: Node;\n * \t\tprops?: any;\n * \t\tevents?: any;\n * \t\tcontext?: Map<any, any>;\n * \t\tintro?: boolean;\n * \t}} options\n * @returns {Exports}\n */\nfunction _mount(Component, { target, anchor, props = {}, events, context, intro = false }) {\n\tinit_operations();\n\n\tconst registered_events = new Set();\n\n\tconst bound_event_listener = handle_event_propagation.bind(null, target);\n\tconst bound_document_event_listener = handle_event_propagation.bind(null, document);\n\n\t/** @param {Array<string>} events */\n\tconst event_handle = (events) => {\n\t\tfor (let i = 0; i < events.length; i++) {\n\t\t\tconst event_name = events[i];\n\t\t\tif (!registered_events.has(event_name)) {\n\t\t\t\tregistered_events.add(event_name);\n\t\t\t\t// Add the event listener to both the container and the document.\n\t\t\t\t// The container listener ensures we catch events from within in case\n\t\t\t\t// the outer content stops propagation of the event.\n\t\t\t\ttarget.addEventListener(\n\t\t\t\t\tevent_name,\n\t\t\t\t\tbound_event_listener,\n\t\t\t\t\tPassiveDelegatedEvents.includes(event_name)\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tpassive: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: undefined\n\t\t\t\t);\n\t\t\t\t// The document listener ensures we catch events that originate from elements that were\n\t\t\t\t// manually moved outside of the container (e.g. via manual portals).\n\t\t\t\tdocument.addEventListener(\n\t\t\t\t\tevent_name,\n\t\t\t\t\tbound_document_event_listener,\n\t\t\t\t\tPassiveDelegatedEvents.includes(event_name)\n\t\t\t\t\t\t? {\n\t\t\t\t\t\t\t\tpassive: true\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t: undefined\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t};\n\n\tevent_handle(array_from(all_registered_events));\n\troot_event_handles.add(event_handle);\n\n\t/** @type {Exports} */\n\t// @ts-expect-error will be defined because the render effect runs synchronously\n\tlet component = undefined;\n\n\tconst unmount = effect_root(() => {\n\t\tbranch(() => {\n\t\t\tif (context) {\n\t\t\t\tpush({});\n\t\t\t\tvar ctx = /** @type {import('#client').ComponentContext} */ (current_component_context);\n\t\t\t\tctx.c = context;\n\t\t\t}\n\n\t\t\tif (events) {\n\t\t\t\t// We can't spread the object or else we'd lose the state proxy stuff, if it is one\n\t\t\t\t/** @type {any} */ (props).$$events = events;\n\t\t\t}\n\n\t\t\tshould_intro = intro;\n\t\t\t// @ts-expect-error the public typings are not what the actual function looks like\n\t\t\tcomponent = Component(anchor, props) || {};\n\t\t\tshould_intro = true;\n\n\t\t\tif (context) {\n\t\t\t\tpop();\n\t\t\t}\n\t\t});\n\n\t\treturn () => {\n\t\t\tfor (const event_name of registered_events) {\n\t\t\t\ttarget.removeEventListener(event_name, bound_event_listener);\n\t\t\t\tdocument.removeEventListener(event_name, bound_event_listener);\n\t\t\t}\n\t\t\troot_event_handles.delete(event_handle);\n\t\t\tmounted_components.delete(component);\n\t\t};\n\t});\n\n\tmounted_components.set(component, unmount);\n\treturn component;\n}\n\n/**\n * References of the components that were mounted or hydrated.\n * Uses a `WeakMap` to avoid memory leaks.\n */\nlet mounted_components = new WeakMap();\n\n/**\n * Unmounts a component that was previously mounted using `mount` or `hydrate`.\n * @param {Record<string, any>} component\n */\nexport function unmount(component) {\n\tconst fn = mounted_components.get(component);\n\tif (DEV && !fn) {\n\t\tw.lifecycle_double_unmount();\n\t\t// eslint-disable-next-line no-console\n\t\tconsole.trace('stack trace');\n\t}\n\tfn?.();\n}\n\n/**\n * @param {Record<string, any>} props\n * @returns {Record<string, any>}\n */\nexport function sanitize_slots(props) {\n\tconst sanitized = { ...props.$$slots };\n\tif (props.children) sanitized.default = props.children;\n\treturn sanitized;\n}\n\n/**\n * @param {Node} target\n * @param {string} style_sheet_id\n * @param {string} styles\n */\nexport async function append_styles(target, style_sheet_id, styles) {\n\t// Wait a tick so that the template is added to the dom, else getRootNode() will yield wrong results\n\t// If it turns out that this results in noticeable flickering, we need to do something like doing the\n\t// append outside and adding code in mount that appends all stylesheets (similar to how we do it with event delegation)\n\tawait Promise.resolve();\n\tconst append_styles_to = get_root_for_style(target);\n\tif (!append_styles_to.getElementById(style_sheet_id)) {\n\t\tconst style = create_element('style');\n\t\tstyle.id = style_sheet_id;\n\t\tstyle.textContent = styles;\n\t\tconst target = /** @type {Document} */ (append_styles_to).head || append_styles_to;\n\t\ttarget.appendChild(style);\n\t}\n}\n\n/**\n * @param {Node} node\n */\nfunction get_root_for_style(node) {\n\tif (!node) return document;\n\tconst root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n\tif (root && /** @type {ShadowRoot} */ (root).host) {\n\t\treturn /** @type {ShadowRoot} */ (root);\n\t}\n\treturn /** @type {Document} */ (node.ownerDocument);\n}\n","import { hydrate_nodes, hydrate_start, hydrating } from './hydration.js';\nimport { empty } from './operations.js';\nimport { create_fragment_from_html } from './reconciler.js';\nimport { current_effect } from '../runtime.js';\nimport { TEMPLATE_FRAGMENT, TEMPLATE_USE_IMPORT_NODE } from '../../../constants.js';\nimport { is_array } from '../utils.js';\nimport { queue_micro_task } from './task.js';\n\n/**\n * @template {import(\"#client\").TemplateNode | import(\"#client\").TemplateNode[]} T\n * @param {T} dom\n * @param {import(\"#client\").Effect} effect\n */\nexport function push_template_node(\n\tdom,\n\teffect = /** @type {import('#client').Effect} */ (current_effect)\n) {\n\tvar current_dom = effect.dom;\n\tif (current_dom === null) {\n\t\teffect.dom = dom;\n\t} else {\n\t\tif (!is_array(current_dom)) {\n\t\t\tcurrent_dom = effect.dom = [current_dom];\n\t\t}\n\n\t\tif (is_array(dom)) {\n\t\t\tcurrent_dom.push(...dom);\n\t\t} else {\n\t\t\tcurrent_dom.push(dom);\n\t\t}\n\t}\n\treturn dom;\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template(content, flags) {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar use_import_node = (flags & TEMPLATE_USE_IMPORT_NODE) !== 0;\n\n\t/** @type {Node} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tpush_template_node(is_fragment ? hydrate_nodes : hydrate_start);\n\t\t\treturn hydrate_start;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tnode = create_fragment_from_html(content);\n\t\t\tif (!is_fragment) node = /** @type {Node} */ (node.firstChild);\n\t\t}\n\n\t\tvar clone = use_import_node ? document.importNode(node, true) : node.cloneNode(true);\n\n\t\tpush_template_node(\n\t\t\tis_fragment\n\t\t\t\t? /** @type {import('#client').TemplateNode[]} */ ([...clone.childNodes])\n\t\t\t\t: /** @type {import('#client').TemplateNode} */ (clone)\n\t\t);\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function template_with_script(content, flags) {\n\tvar first = true;\n\tvar fn = template(content, flags);\n\n\treturn () => {\n\t\tif (hydrating) return fn();\n\n\t\tvar node = /** @type {Element | DocumentFragment} */ (fn());\n\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\trun_scripts(node);\n\t\t}\n\n\t\treturn node;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @param {'svg' | 'math'} ns\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function ns_template(content, flags, ns = 'svg') {\n\tvar is_fragment = (flags & TEMPLATE_FRAGMENT) !== 0;\n\tvar fn = template(`<${ns}>${content}</${ns}>`, 0); // we don't need to worry about using importNode for namespaced elements\n\n\t/** @type {Element | DocumentFragment} */\n\tvar node;\n\n\treturn () => {\n\t\tif (hydrating) {\n\t\t\tpush_template_node(is_fragment ? hydrate_nodes : hydrate_start);\n\t\t\treturn hydrate_start;\n\t\t}\n\n\t\tif (!node) {\n\t\t\tvar wrapper = /** @type {Element} */ (fn());\n\n\t\t\tif ((flags & TEMPLATE_FRAGMENT) === 0) {\n\t\t\t\tnode = /** @type {Element} */ (wrapper.firstChild);\n\t\t\t} else {\n\t\t\t\tnode = document.createDocumentFragment();\n\t\t\t\twhile (wrapper.firstChild) {\n\t\t\t\t\tnode.appendChild(wrapper.firstChild);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar clone = node.cloneNode(true);\n\n\t\tpush_template_node(\n\t\t\tis_fragment\n\t\t\t\t? /** @type {import('#client').TemplateNode[]} */ ([...clone.childNodes])\n\t\t\t\t: /** @type {import('#client').TemplateNode} */ (clone)\n\t\t);\n\n\t\treturn clone;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function svg_template_with_script(content, flags) {\n\tvar first = true;\n\tvar fn = ns_template(content, flags);\n\n\treturn () => {\n\t\tif (hydrating) return fn();\n\n\t\tvar node = /** @type {Element | DocumentFragment} */ (fn());\n\n\t\tif (first) {\n\t\t\tfirst = false;\n\t\t\trun_scripts(node);\n\t\t}\n\n\t\treturn node;\n\t};\n}\n\n/**\n * @param {string} content\n * @param {number} flags\n * @returns {() => Node | Node[]}\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function mathml_template(content, flags) {\n\treturn ns_template(content, flags, 'math');\n}\n\n/**\n * Creating a document fragment from HTML that contains script tags will not execute\n * the scripts. We need to replace the script tags with new ones so that they are executed.\n * @param {Element | DocumentFragment} node\n */\nfunction run_scripts(node) {\n\t// scripts were SSR'd, in which case they will run\n\tif (hydrating) return;\n\n\tconst scripts =\n\t\t/** @type {HTMLElement} */ (node).tagName === 'SCRIPT'\n\t\t\t? [/** @type {HTMLScriptElement} */ (node)]\n\t\t\t: node.querySelectorAll('script');\n\tfor (const script of scripts) {\n\t\tvar clone = document.createElement('script');\n\t\tfor (var attribute of script.attributes) {\n\t\t\tclone.setAttribute(attribute.name, attribute.value);\n\t\t}\n\n\t\tclone.textContent = script.textContent;\n\t\t// If node === script tag, replaceWith will do nothing because there's no parent yet,\n\t\t// waiting until that's the case using an effect solves this.\n\t\t// Don't do it in other circumstances or we could accidentally execute scripts\n\t\t// in an adjacent @html tag that was instantiated in the meantime.\n\t\tif (script === node) {\n\t\t\tqueue_micro_task(() => script.replaceWith(clone));\n\t\t} else {\n\t\t\tscript.replaceWith(clone);\n\t\t}\n\t}\n}\n\n/**\n * @param {Text | Comment | Element} anchor\n */\n/*#__NO_SIDE_EFFECTS__*/\nexport function text(anchor) {\n\tif (!hydrating) return push_template_node(empty());\n\n\tvar node = hydrate_start;\n\n\tif (!node) {\n\t\t// if an {expression} is empty during SSR, `hydrate_nodes` will be empty.\n\t\t// we need to insert an empty text node\n\t\tanchor.before((node = empty()));\n\t}\n\n\tpush_template_node(node);\n\treturn node;\n}\n\nexport function comment() {\n\t// we're not delegating to `template` here for performance reasons\n\tif (hydrating) {\n\t\tpush_template_node(hydrate_nodes);\n\t\treturn hydrate_start;\n\t}\n\n\tvar frag = document.createDocumentFragment();\n\tvar anchor = empty();\n\tfrag.append(anchor);\n\tpush_template_node([anchor]);\n\n\treturn frag;\n}\n\n/**\n * Assign the created (or in hydration mode, traversed) dom elements to the current block\n * and insert the elements into the dom (in client mode).\n * @param {Text | Comment | Element} anchor\n * @param {DocumentFragment | Element} dom\n */\nexport function append(anchor, dom) {\n\tif (hydrating) return;\n\t// We intentionally do not assign the `dom` property of the effect here because it's far too\n\t// late. If we try, we will capture additional DOM elements that we cannot control the lifecycle\n\t// for and will inevitably cause memory leaks. See https://github.com/sveltejs/svelte/pull/11832\n\n\tanchor.before(/** @type {Node} */ (dom));\n}\n","import { proxy } from '../internal/client/proxy.js';\nimport { user_pre_effect } from '../internal/client/reactivity/effects.js';\nimport { hydrate, mount, unmount } from '../internal/client/render.js';\nimport { define_property } from '../internal/client/utils.js';\n\n/**\n * Takes the same options as a Svelte 4 component and the component function and returns a Svelte 4 compatible component.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {import('svelte').ComponentConstructorOptions<Props> & {\n * \tcomponent: import('svelte').ComponentType<import('svelte').SvelteComponent<Props, Events, Slots>> | import('svelte').Component<Props>;\n * \timmutable?: boolean;\n * \thydrate?: boolean;\n * \trecover?: boolean;\n * }} options\n * @returns {import('svelte').SvelteComponent<Props, Events, Slots> & Exports}\n */\nexport function createClassComponent(options) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn new Svelte4Component(options);\n}\n\n/**\n * Takes the component function and returns a Svelte 4 compatible component constructor.\n *\n * @deprecated Use this only as a temporary solution to migrate your imperative component code to Svelte 5.\n *\n * @template {Record<string, any>} Props\n * @template {Record<string, any>} Exports\n * @template {Record<string, any>} Events\n * @template {Record<string, any>} Slots\n *\n * @param {import('svelte').SvelteComponent<Props, Events, Slots> | import('svelte').Component<Props>} component\n * @returns {import('svelte').ComponentType<import('svelte').SvelteComponent<Props, Events, Slots> & Exports>}\n */\nexport function asClassComponent(component) {\n\t// @ts-expect-error $$prop_def etc are not actually defined\n\treturn class extends Svelte4Component {\n\t\t/** @param {any} options */\n\t\tconstructor(options) {\n\t\t\tsuper({\n\t\t\t\tcomponent,\n\t\t\t\t...options\n\t\t\t});\n\t\t}\n\t};\n}\n\nclass Svelte4Component {\n\t/** @type {any} */\n\t#events;\n\n\t/** @type {Record<string, any>} */\n\t#instance;\n\n\t/**\n\t * @param {import('svelte').ComponentConstructorOptions & {\n\t *  component: any;\n\t * \timmutable?: boolean;\n\t * \thydrate?: boolean;\n\t * \trecover?: false;\n\t * }} options\n\t */\n\tconstructor(options) {\n\t\t// Using proxy state here isn't completely mirroring the Svelte 4 behavior, because mutations to a property\n\t\t// cause fine-grained updates to only the places where that property is used, and not the entire property.\n\t\t// Reactive statements and actions (the things where this matters) are handling this properly regardless, so it should be fine in practise.\n\t\tconst props = proxy({ ...(options.props || {}), $$events: {} }, false);\n\t\tthis.#instance = (options.hydrate ? hydrate : mount)(options.component, {\n\t\t\ttarget: options.target,\n\t\t\tprops,\n\t\t\tcontext: options.context,\n\t\t\tintro: options.intro,\n\t\t\trecover: options.recover\n\t\t});\n\n\t\tthis.#events = props.$$events;\n\n\t\tfor (const key of Object.keys(this.#instance)) {\n\t\t\tif (key === '$set' || key === '$destroy' || key === '$on') continue;\n\t\t\tdefine_property(this, key, {\n\t\t\t\tget() {\n\t\t\t\t\treturn this.#instance[key];\n\t\t\t\t},\n\t\t\t\t/** @param {any} value */\n\t\t\t\tset(value) {\n\t\t\t\t\tthis.#instance[key] = value;\n\t\t\t\t},\n\t\t\t\tenumerable: true\n\t\t\t});\n\t\t}\n\n\t\tthis.#instance.$set = /** @param {Record<string, any>} next */ (next) => {\n\t\t\tObject.assign(props, next);\n\t\t};\n\t\tthis.#instance.$destroy = () => {\n\t\t\tunmount(this.#instance);\n\t\t};\n\t}\n\n\t/** @param {Record<string, any>} props */\n\t$set(props) {\n\t\tthis.#instance.$set(props);\n\t}\n\n\t/**\n\t * @param {string} event\n\t * @param {(...args: any[]) => any} callback\n\t * @returns {any}\n\t */\n\t$on(event, callback) {\n\t\tthis.#events[event] = this.#events[event] || [];\n\n\t\t/** @param {any[]} args */\n\t\tconst cb = (...args) => callback.call(this, ...args);\n\t\tthis.#events[event].push(cb);\n\t\treturn () => {\n\t\t\tthis.#events[event] = this.#events[event].filter(/** @param {any} fn */ (fn) => fn !== cb);\n\t\t};\n\t}\n\n\t$destroy() {\n\t\tthis.#instance.$destroy();\n\t}\n}\n\n/**\n * Runs the given function once immediately on the server, and works like `$effect.pre` on the client.\n *\n * @deprecated Use this only as a temporary solution to migrate your component code to Svelte 5.\n * @param {() => void | (() => void)} fn\n * @returns {void}\n */\nexport function run(fn) {\n\tuser_pre_effect(fn);\n}\n","import { createClassComponent } from '../../../../legacy/legacy-client.js';\nimport { destroy_effect, render_effect } from '../../reactivity/effects.js';\nimport { append } from '../template.js';\nimport { define_property, object_keys } from '../../utils.js';\n\n/**\n * @typedef {Object} CustomElementPropDefinition\n * @property {string} [attribute]\n * @property {boolean} [reflect]\n * @property {'String'|'Boolean'|'Number'|'Array'|'Object'} [type]\n */\n\n/** @type {any} */\nlet SvelteElement;\n\nif (typeof HTMLElement === 'function') {\n\tSvelteElement = class extends HTMLElement {\n\t\t/** The Svelte component constructor */\n\t\t$$ctor;\n\t\t/** Slots */\n\t\t$$s;\n\t\t/** @type {any} The Svelte component instance */\n\t\t$$c;\n\t\t/** Whether or not the custom element is connected */\n\t\t$$cn = false;\n\t\t/** @type {Record<string, any>} Component props data */\n\t\t$$d = {};\n\t\t/** `true` if currently in the process of reflecting component props back to attributes */\n\t\t$$r = false;\n\t\t/** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */\n\t\t$$p_d = {};\n\t\t/** @type {Record<string, EventListenerOrEventListenerObject[]>} Event listeners */\n\t\t$$l = {};\n\t\t/** @type {Map<EventListenerOrEventListenerObject, Function>} Event listener unsubscribe functions */\n\t\t$$l_u = new Map();\n\t\t/** @type {any} The managed render effect for reflecting attributes */\n\t\t$$me;\n\n\t\t/**\n\t\t * @param {*} $$componentCtor\n\t\t * @param {*} $$slots\n\t\t * @param {*} use_shadow_dom\n\t\t */\n\t\tconstructor($$componentCtor, $$slots, use_shadow_dom) {\n\t\t\tsuper();\n\t\t\tthis.$$ctor = $$componentCtor;\n\t\t\tthis.$$s = $$slots;\n\t\t\tif (use_shadow_dom) {\n\t\t\t\tthis.attachShadow({ mode: 'open' });\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type\n\t\t * @param {EventListenerOrEventListenerObject} listener\n\t\t * @param {boolean | AddEventListenerOptions} [options]\n\t\t */\n\t\taddEventListener(type, listener, options) {\n\t\t\t// We can't determine upfront if the event is a custom event or not, so we have to\n\t\t\t// listen to both. If someone uses a custom event with the same name as a regular\n\t\t\t// browser event, this fires twice - we can't avoid that.\n\t\t\tthis.$$l[type] = this.$$l[type] || [];\n\t\t\tthis.$$l[type].push(listener);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t}\n\t\t\tsuper.addEventListener(type, listener, options);\n\t\t}\n\n\t\t/**\n\t\t * @param {string} type\n\t\t * @param {EventListenerOrEventListenerObject} listener\n\t\t * @param {boolean | AddEventListenerOptions} [options]\n\t\t */\n\t\tremoveEventListener(type, listener, options) {\n\t\t\tsuper.removeEventListener(type, listener, options);\n\t\t\tif (this.$$c) {\n\t\t\t\tconst unsub = this.$$l_u.get(listener);\n\t\t\t\tif (unsub) {\n\t\t\t\t\tunsub();\n\t\t\t\t\tthis.$$l_u.delete(listener);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tasync connectedCallback() {\n\t\t\tthis.$$cn = true;\n\t\t\tif (!this.$$c) {\n\t\t\t\t// We wait one tick to let possible child slot elements be created/mounted\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tif (!this.$$cn || this.$$c) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t/** @param {string} name */\n\t\t\t\tfunction create_slot(name) {\n\t\t\t\t\t/**\n\t\t\t\t\t * @param {Element} anchor\n\t\t\t\t\t */\n\t\t\t\t\treturn (anchor) => {\n\t\t\t\t\t\tconst slot = document.createElement('slot');\n\t\t\t\t\t\tif (name !== 'default') slot.name = name;\n\n\t\t\t\t\t\tappend(anchor, slot);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t/** @type {Record<string, any>} */\n\t\t\t\tconst $$slots = {};\n\t\t\t\tconst existing_slots = get_custom_elements_slots(this);\n\t\t\t\tfor (const name of this.$$s) {\n\t\t\t\t\tif (name in existing_slots) {\n\t\t\t\t\t\tif (name === 'default' && !this.$$d.children) {\n\t\t\t\t\t\t\tthis.$$d.children = create_slot(name);\n\t\t\t\t\t\t\t$$slots.default = true;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t$$slots[name] = create_slot(name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (const attribute of this.attributes) {\n\t\t\t\t\t// this.$$data takes precedence over this.attributes\n\t\t\t\t\tconst name = this.$$g_p(attribute.name);\n\t\t\t\t\tif (!(name in this.$$d)) {\n\t\t\t\t\t\tthis.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, 'toProp');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Port over props that were set programmatically before ce was initialized\n\t\t\t\tfor (const key in this.$$p_d) {\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tif (!(key in this.$$d) && this[key] !== undefined) {\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tthis.$$d[key] = this[key]; // don't transform, these were set through JavaScript\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tdelete this[key]; // remove the property that shadows the getter/setter\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$c = createClassComponent({\n\t\t\t\t\tcomponent: this.$$ctor,\n\t\t\t\t\ttarget: this.shadowRoot || this,\n\t\t\t\t\tprops: {\n\t\t\t\t\t\t...this.$$d,\n\t\t\t\t\t\t$$slots,\n\t\t\t\t\t\t$$host: this\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\t// Reflect component props as attributes\n\t\t\t\tthis.$$me = render_effect(() => {\n\t\t\t\t\tthis.$$r = true;\n\t\t\t\t\tfor (const key of object_keys(this.$$c)) {\n\t\t\t\t\t\tif (!this.$$p_d[key]?.reflect) continue;\n\t\t\t\t\t\tthis.$$d[key] = this.$$c[key];\n\t\t\t\t\t\tconst attribute_value = get_custom_element_value(\n\t\t\t\t\t\t\tkey,\n\t\t\t\t\t\t\tthis.$$d[key],\n\t\t\t\t\t\t\tthis.$$p_d,\n\t\t\t\t\t\t\t'toAttribute'\n\t\t\t\t\t\t);\n\t\t\t\t\t\tif (attribute_value == null) {\n\t\t\t\t\t\t\tthis.removeAttribute(this.$$p_d[key].attribute || key);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.setAttribute(this.$$p_d[key].attribute || key, attribute_value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis.$$r = false;\n\t\t\t\t});\n\n\t\t\t\tfor (const type in this.$$l) {\n\t\t\t\t\tfor (const listener of this.$$l[type]) {\n\t\t\t\t\t\tconst unsub = this.$$c.$on(type, listener);\n\t\t\t\t\t\tthis.$$l_u.set(listener, unsub);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.$$l = {};\n\t\t\t}\n\t\t}\n\n\t\t// We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte\n\t\t// and setting attributes through setAttribute etc, this is helpful\n\n\t\t/**\n\t\t * @param {string} attr\n\t\t * @param {string} _oldValue\n\t\t * @param {string} newValue\n\t\t */\n\t\tattributeChangedCallback(attr, _oldValue, newValue) {\n\t\t\tif (this.$$r) return;\n\t\t\tattr = this.$$g_p(attr);\n\t\t\tthis.$$d[attr] = get_custom_element_value(attr, newValue, this.$$p_d, 'toProp');\n\t\t\tthis.$$c?.$set({ [attr]: this.$$d[attr] });\n\t\t}\n\n\t\tdisconnectedCallback() {\n\t\t\tthis.$$cn = false;\n\t\t\t// In a microtask, because this could be a move within the DOM\n\t\t\tPromise.resolve().then(() => {\n\t\t\t\tif (!this.$$cn && this.$$c) {\n\t\t\t\t\tthis.$$c.$destroy();\n\t\t\t\t\tdestroy_effect(this.$$me);\n\t\t\t\t\tthis.$$c = undefined;\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * @param {string} attribute_name\n\t\t */\n\t\t$$g_p(attribute_name) {\n\t\t\treturn (\n\t\t\t\tobject_keys(this.$$p_d).find(\n\t\t\t\t\t(key) =>\n\t\t\t\t\t\tthis.$$p_d[key].attribute === attribute_name ||\n\t\t\t\t\t\t(!this.$$p_d[key].attribute && key.toLowerCase() === attribute_name)\n\t\t\t\t) || attribute_name\n\t\t\t);\n\t\t}\n\t};\n}\n\n/**\n * @param {string} prop\n * @param {any} value\n * @param {Record<string, CustomElementPropDefinition>} props_definition\n * @param {'toAttribute' | 'toProp'} [transform]\n */\nfunction get_custom_element_value(prop, value, props_definition, transform) {\n\tconst type = props_definition[prop]?.type;\n\tvalue = type === 'Boolean' && typeof value !== 'boolean' ? value != null : value;\n\tif (!transform || !props_definition[prop]) {\n\t\treturn value;\n\t} else if (transform === 'toAttribute') {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value == null ? null : JSON.stringify(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value ? '' : null;\n\t\t\tcase 'Number':\n\t\t\t\treturn value == null ? null : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t} else {\n\t\tswitch (type) {\n\t\t\tcase 'Object':\n\t\t\tcase 'Array':\n\t\t\t\treturn value && JSON.parse(value);\n\t\t\tcase 'Boolean':\n\t\t\t\treturn value; // conversion already handled above\n\t\t\tcase 'Number':\n\t\t\t\treturn value != null ? +value : value;\n\t\t\tdefault:\n\t\t\t\treturn value;\n\t\t}\n\t}\n}\n\n/**\n * @param {HTMLElement} element\n */\nfunction get_custom_elements_slots(element) {\n\t/** @type {Record<string, true>} */\n\tconst result = {};\n\telement.childNodes.forEach((node) => {\n\t\tresult[/** @type {Element} node */ (node).slot || 'default'] = true;\n\t});\n\treturn result;\n}\n\n/**\n * @internal\n *\n * Turn a Svelte component into a custom element.\n * @param {any} Component  A Svelte component function\n * @param {Record<string, CustomElementPropDefinition>} props_definition  The props to observe\n * @param {string[]} slots  The slots to create\n * @param {string[]} exports  Explicitly exported values, other than props\n * @param {boolean} use_shadow_dom  Whether to use shadow DOM\n * @param {(ce: new () => HTMLElement) => new () => HTMLElement} [extend]\n */\nexport function create_custom_element(\n\tComponent,\n\tprops_definition,\n\tslots,\n\texports,\n\tuse_shadow_dom,\n\textend\n) {\n\tlet Class = class extends SvelteElement {\n\t\tconstructor() {\n\t\t\tsuper(Component, slots, use_shadow_dom);\n\t\t\tthis.$$p_d = props_definition;\n\t\t}\n\t\tstatic get observedAttributes() {\n\t\t\treturn object_keys(props_definition).map((key) =>\n\t\t\t\t(props_definition[key].attribute || key).toLowerCase()\n\t\t\t);\n\t\t}\n\t};\n\tobject_keys(props_definition).forEach((prop) => {\n\t\tdefine_property(Class.prototype, prop, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c && prop in this.$$c ? this.$$c[prop] : this.$$d[prop];\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tvalue = get_custom_element_value(prop, value, props_definition);\n\t\t\t\tthis.$$d[prop] = value;\n\t\t\t\tthis.$$c?.$set({ [prop]: value });\n\t\t\t}\n\t\t});\n\t});\n\texports.forEach((property) => {\n\t\tdefine_property(Class.prototype, property, {\n\t\t\tget() {\n\t\t\t\treturn this.$$c?.[property];\n\t\t\t}\n\t\t});\n\t});\n\tif (extend) {\n\t\t// @ts-expect-error - assigning here is fine\n\t\tClass = extend(Class);\n\t}\n\tComponent.element = /** @type {any} */ Class;\n\treturn Class;\n}\n"],"names":["is_array","array_from","object_keys","is_frozen","define_property","get_descriptor","object_prototype","array_prototype","get_prototype_of","DERIVED","EFFECT","RENDER_EFFECT","BLOCK_EFFECT","BRANCH_EFFECT","ROOT_EFFECT","UNOWNED","DISCONNECTED","CLEAN","DIRTY","MAYBE_DIRTY","INERT","DESTROYED","EFFECT_RAN","EFFECT_TRANSPARENT","LEGACY_DERIVED_PROP","STATE_SYMBOL","STATE_FROZEN_SYMBOL","LOADING_ATTR_SYMBOL","equals","value","safe_not_equal","a","b","safe_equals","EACH_ITEM_REACTIVE","EACH_INDEX_REACTIVE","EACH_KEYED","EACH_IS_CONTROLLED","EACH_IS_ANIMATED","EACH_IS_STRICT_EQUALS","PROPS_IS_IMMUTABLE","PROPS_IS_RUNES","PROPS_IS_UPDATED","PROPS_IS_LAZY_INITIAL","TEMPLATE_FRAGMENT","TEMPLATE_USE_IMPORT_NODE","HYDRATION_START","HYDRATION_END","HYDRATION_ANCHOR","HYDRATION_END_ELSE","HYDRATION_ERROR","UNINITIALIZED","PassiveDelegatedEvents","effect_in_teardown","rune","effect_in_unowned_derived","effect_orphan","effect_update_depth_exceeded","hydration_failed","props_invalid_value","key","state_unsafe_mutation","source","v","mutable_source","initial_value","_a","s","current_component_context","set","initialized","current_reaction","is_runes","e.state_unsafe_mutation","increment_version","mark_reactions","current_effect","current_dependencies","set_signal_status","schedule_effect","current_untracked_writes","set_current_untracked_writes","create_fragment_from_html","html","elem","remove","current","i","node","validate_effect","e.effect_orphan","e.effect_in_unowned_derived","is_destroying_effect","e.effect_in_teardown","push_effect","effect","parent_effect","parent_last","create_effect","type","fn","sync","is_root","previously_flushing_effect","is_flushing_effect","set_is_flushing_effect","execute_effect","inert","user_effect","defer","context","signal","user_pre_effect","render_effect","effect_root","destroy_effect","template_effect","block","flags","branch","execute_effect_teardown","teardown","previously_destroying_effect","previous_reaction","set_is_destroying_effect","set_current_reaction","remove_dom","dom","destroy_effect_children","remove_reactions","transition","parent","unlink_effect","prev","next","pause_effect","callback","transitions","pause_children","run_out_transitions","remaining","check","local","child","sibling","transparent","resume_effect","resume_children","check_dirtiness","hydration_mismatch","location","proxy","immutable","metadata","prototype","state_proxy_handler","update_version","d","target","prop","descriptor","boolean","ls","length","receiver","get","has","untrack","not_has","get_proxied_value","is","noop","is_promise","run_all","arr","is_micro_task_queued","current_queued_micro_tasks","process_micro_tasks","tasks","queue_micro_task","flush_tasks","derived","current_derived","derived_safe_equal","destroy_derived_children","deriveds","destroy_derived","update_derived","execute_reaction_fn","status","current_skip_reaction","FLUSH_MICROTASK","FLUSH_SYNC","current_scheduler_mode","current_queued_root_effects","flush_count","reaction","set_current_effect","current_dependencies_index","current_version","set_current_component_context","is_dirty","is_unowned","is_disconnected","dependencies","reactions","dependency","version","handle_error","error","component_context","previous_dependencies","previous_dependencies_index","previous_untracked_writes","previous_skip_reaction","res","deps_length","full_current_dependencies","full_current_dependencies_set","remove_reaction","reactions_length","index","start_index","active_dependencies","previous_effect","previous_component_context","infinite_loop_guard","e.effect_update_depth_exceeded","flush_queued_root_effects","root_effects","flush_queued_effects","collected_effects","process_effects","effects","process_deferred","previous_queued_root_effects","main_loop","is_active","is_branch","is_clean","parent_sibling","flush_sync","flush_previous","previous_scheduler_mode","result","tick","unowned","to_status","force_schedule","runes","maybe_dirty","STATUS_MASK","is_signal","val","value_or_fallback","fallback","push","props","pop","component","context_stack_item","unwrap","hydrating","set_hydrating","hydrate_nodes","hydrate_start","set_hydrate_nodes","nodes","hydrate_anchor","depth","data","w.hydration_mismatch","$window","$document","init_operations","element_prototype","empty","first_child","fragment","is_text","next_sibling","text","clear_text_content","create_element","name","delegate","events","all_registered_events","root_event_handles","handle_event_propagation","handler_element","event","owner_document","event_name","path","current_target","path_idx","handled_at","at_idx","handler_idx","throw_error","other_errors","parent_element","delegated","head_anchor","reset_head_anchor","head","render_fn","previous_hydrate_nodes","was_hydrating","anchor","set_text","slot","slot_fn","slot_props","fallback_fn","mount","options","_mount","hydrate","instance","e.hydration_failed","Component","intro","registered_events","bound_event_listener","bound_document_event_listener","event_handle","unmount","ctx","mounted_components","append_styles","style_sheet_id","styles","append_styles_to","get_root_for_style","style","root","push_template_node","current_dom","template","content","is_fragment","use_import_node","clone","comment","frag","append","createClassComponent","Svelte4Component","asClassComponent","_events","_instance","__privateAdd","__privateSet","__privateGet","cb","args","SvelteElement","$$componentCtor","$$slots","use_shadow_dom","__publicField","listener","unsub","create_slot","existing_slots","get_custom_elements_slots","attribute","get_custom_element_value","attribute_value","attr","_oldValue","newValue","attribute_name","props_definition","transform","element","create_custom_element","slots","exports","extend","Class","property"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21]}