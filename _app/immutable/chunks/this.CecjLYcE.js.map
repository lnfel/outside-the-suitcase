{"version":3,"file":"this.CecjLYcE.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/dom/elements/bindings/this.js"],"sourcesContent":["import { STATE_SYMBOL } from '../../../constants.js';\nimport { effect, render_effect } from '../../../reactivity/effects.js';\nimport { untrack } from '../../../runtime.js';\nimport { queue_micro_task } from '../../task.js';\n\n/**\n * @param {any} bound_value\n * @param {Element} element_or_component\n * @returns {boolean}\n */\nfunction is_bound_this(bound_value, element_or_component) {\n\t// Find the original target if the value is proxied.\n\tvar proxy_target = bound_value && bound_value[STATE_SYMBOL]?.t;\n\treturn bound_value === element_or_component || proxy_target === element_or_component;\n}\n\n/**\n * @param {Element} element_or_component\n * @param {(value: unknown, ...parts: unknown[]) => void} update\n * @param {(...parts: unknown[]) => unknown} get_value\n * @param {() => unknown[]} [get_parts] Set if the this binding is used inside an each block,\n * \t\t\t\t\t\t\t\t\t\treturns all the parts of the each block context that are used in the expression\n * @returns {void}\n */\nexport function bind_this(element_or_component, update, get_value, get_parts) {\n\teffect(() => {\n\t\t/** @type {unknown[]} */\n\t\tvar old_parts;\n\n\t\t/** @type {unknown[]} */\n\t\tvar parts;\n\n\t\trender_effect(() => {\n\t\t\told_parts = parts;\n\t\t\t// We only track changes to the parts, not the value itself to avoid unnecessary reruns.\n\t\t\tparts = get_parts?.() || [];\n\n\t\t\tuntrack(() => {\n\t\t\t\tif (element_or_component !== get_value(...parts)) {\n\t\t\t\t\tupdate(element_or_component, ...parts);\n\t\t\t\t\t// If this is an effect rerun (cause: each block context changes), then nullfiy the binding at\n\t\t\t\t\t// the previous position if it isn't already taken over by a different effect.\n\t\t\t\t\tif (old_parts && is_bound_this(get_value(...old_parts), element_or_component)) {\n\t\t\t\t\t\tupdate(null, ...old_parts);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\n\t\treturn () => {\n\t\t\t// We cannot use effects in the teardown phase, we we use a microtask instead.\n\t\t\tqueue_micro_task(() => {\n\t\t\t\tif (parts && is_bound_this(get_value(...parts), element_or_component)) {\n\t\t\t\t\tupdate(null, ...parts);\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\t});\n}\n"],"names":["is_bound_this","bound_value","element_or_component","proxy_target","_a","STATE_SYMBOL","bind_this","update","get_value","get_parts","effect","old_parts","parts","render_effect","untrack","queue_micro_task"],"mappings":"6EAUA,SAASA,EAAcC,EAAaC,EAAsB,OAEzD,IAAIC,EAAeF,KAAeG,EAAAH,EAAYI,CAAY,IAAxB,YAAAD,EAA2B,GAC7D,OAAOH,IAAgBC,GAAwBC,IAAiBD,CACjE,CAUO,SAASI,EAAUJ,EAAsBK,EAAQC,EAAWC,EAAW,CAC7EC,EAAO,IAAM,CAEZ,IAAIC,EAGAC,EAEJ,OAAAC,EAAc,IAAM,CACnBF,EAAYC,EAEZA,EAAyB,CAAA,EAEzBE,EAAQ,IAAM,CACTZ,IAAyBM,EAAU,GAAGI,CAAK,IAC9CL,EAAOL,EAAsB,GAAGU,CAAK,EAGjCD,GAAaX,EAAcQ,EAAU,GAAGG,CAAS,EAAGT,CAAoB,GAC3EK,EAAO,KAAM,GAAGI,CAAS,EAG/B,CAAI,CACJ,CAAG,EAEM,IAAM,CAEZI,EAAiB,IAAM,CAClBH,GAASZ,EAAcQ,EAAU,GAAGI,CAAK,EAAGV,CAAoB,GACnEK,EAAO,KAAM,GAAGK,CAAK,CAE1B,CAAI,CACJ,CACA,CAAE,CACF","x_google_ignoreList":[0]}