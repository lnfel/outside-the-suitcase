const le=()=>{};function dt(e){return!!e&&(typeof e=="object"||typeof e=="function")&&typeof e.then=="function"}function Pe(e,t,n){if(e==null)return t(void 0),le;const s=e.subscribe(t,n);return s.unsubscribe?()=>s.unsubscribe():s}let S=null;function ye(e){S=e}function xe(e){const t=[];let n=e,s=null;for(;n!==null;){const r=n.nodeType,u=n.nextSibling;if(r===8){const o=n.data;if(o.startsWith("ssr:")){const c=o.slice(4);if(s===null)s=c;else{if(c===s)return t;t.push(n)}n=u;continue}}s!==null&&t.push(n),n=u}return null}function pt(e,t){let n=e;if(S!==null)if(t&&(n=n.firstChild),n.nodeType===8){let s=n.$$fragment;s===void 0&&(s=xe(n),n.$$fragment=void 0),ye(s)}else ye([n.firstChild])}const ke=Object,Ee=Array,we=Ee.isArray,mt=Ee.from,ht=ke.defineProperty,ne=ke.getOwnPropertyDescriptor,k=typeof window<"u",G=k?Node.prototype:{},Ye=k?Element.prototype:{},fe=k?EventTarget.prototype:{},Te=Map.prototype,Le=G.appendChild,Ge=G.cloneNode,He=Te.set,Ve=Te.get;fe.__click=void 0;fe.__nodeValue=" ";fe.__className="";const qe=k?ne(G,"firstChild").get:null,We=k?ne(G,"nextSibling").get:null,Be=k?ne(G,"textContent").set:null,Ke=k?ne(Ye,"className").set:null;function gt(e,t){Le.call(e,t)}function yt(e,t,n){He.call(e,t,n)}function bt(e,t){return Ve.call(e,t)}function vt(e,t){return Ge.call(e,t)}function xt(e){const t=qe.call(e);if(S!==null)if(t===null){const n=document.createTextNode("");return e.appendChild(n),n}else return ie(t);return t}function kt(e){if(S!==null){const t=e[0];return S!==null&&t!==null?ie(t):t}return qe.call(e)}function Et(e){const t=We.call(e);return S!==null&&t!==null?ie(t):t}function wt(e,t){Ke.call(e,t)}function Tt(e,t){Be.call(e,t)}function ie(e){if(e.nodeType===8&&e.data.startsWith("ssr:")&&S.at(-1)!==e){const t=xe(e),s=(t.at(-1)||e).nextSibling;return s.$$fragment=t,s}return e}const qt=k?document:void 0,Se=1,ae=2,H=4,V=8,A=16,_e=32,W=64,se=128,h=256,m=512,D=1024,j=2048,re=4096,de=H|V|A|_e,Ne=0,Xe=1,je=Number.MAX_SAFE_INTEGER,P=Symbol();let z=Ne,Q=!1,Z=!1,i=[],C=[],ue=[],Y=0,b=null,l=null,a=null,d=0,U=1,X=1,v=!1,ce=!1,M=null,O=!1,J=!1,q=new Set,y=null,f=null;function ze(e){return{effects:null,props:e,parent:f,accessors:null,context:null,immutable:!1,mounted:!1,runes:!1,update_callbacks:null}}function ee(e){const t=e||f;return t!==null&&t.runes}function Je(e,t){return e===t}function Ce(e,t,n){return{block:n,consumers:null,context:null,dependencies:null,destroy:null,equals:null,flags:e,init:null,read:0,references:null,value:t}}function Qe(e,t){const n=e.references;n===null?e.references=[t]:n.push(t)}function pe(e){const t=e.flags;if(t&m||e.value===P)return!0;if(t&D){const n=e.dependencies;if(n!==null){const s=n.length;let r;for(r=0;r<s;r++){const u=n[r];if(u.flags&D&&!pe(u)){x(u,h);continue}if(u.flags&m||u.value===P)if(u.flags&ae){if(Me(u,!0),e.flags&m)return!0}else return!0}}}return!1}function Fe(e){const t=e.init,n=a,s=d,r=U,u=b,o=y,c=f,g=O,E=(e.flags&A)!==0,K=v;a=null,d=0,X===je?X=1:X++,U=X,b=e,y=e.block,f=e.context,O=l===null&&(e.flags&se)!==0,v=!1,E&&f?.update_callbacks!=null&&f.update_callbacks.execute();try{let w;E?w=t(e.block):w=t();let _=e.dependencies;if(a!==null){let p;if(te(e,d,!1),_!==null&&d>0)for(_.length=d+a.length,p=0;p<a.length;p++)_[d+p]=a[p];else e.dependencies=_=a;if(!O)for(p=d;p<_.length;p++){const T=_[p];T.consumers===null?T.consumers=[e]:T.consumers.push(e)}}else _!==null&&d<_.length&&(te(e,d,!1),_.length=d);return w}finally{a=n,d=s,U=r,b=u,y=o,f=c,O=g,v=K}}function te(e,t,n){const s=e.dependencies;if(s!==null){let r;for(r=t;r<s.length;r++){const u=s[r],o=u.consumers;let c=0;if(o!==null)if(c=o.length-1,c===0)u.consumers=null;else{const g=o.indexOf(e);o[g]=o[c],o.pop()}n&&c===0&&u.flags&se&&te(u,0,!0)}}}function De(e){const t=e.references;if(e.references=null,t!==null){let n;for(n=0;n<t.length;n++)ge(t[n])}}function Ze(e,t){if(e!==null)throw t}function Ie(e){if(e.flags&re)return;const t=e.value,n=l;l=e;try{De(e),t!==null&&t();const r=Fe(e);typeof r=="function"&&(e.value=r)}catch(r){const u=e.block;if(u!==null)Ze(u,r);else throw r}finally{l=n}const s=e.context;ee(s)&&e.flags&V&&i.length>0&&nt(s)}function I(e){const t=e.length;if(t>0){if(Y>100)throw new Error("Maximum update depth exceeded. This can happen when a reactive block or effect repeatedly sets a new value. Svelte limits the number of nested updates to prevent infinite loops.");Y++;let n;for(n=0;n<t;n++){const s=e[n],r=s.flags;!(r&re)&&!(r&j)&&(pe(s)?(x(s,h),Ie(s)):r&D&&x(s,h))}e.length=0}}function et(){if(Q=!1,Y>101)return;const e=i,t=C;i=[],C=[],I(e),I(t),Q||(Y=0)}function B(e,t){const n=e.flags;t||n&_e?(Ie(e),x(e,h)):(z===Ne&&(Q||(Q=!0,queueMicrotask(et))),n&H?C.push(e):i.push(e))}function Ae(){Z=!1;const e=ue.slice();ue=[];for(let t=0;t<e.length;t++)e[t]()}function St(e){Z||(Z=!0,setTimeout(Ae,0)),ue.push(e)}function tt(){const e=[];for(let t=0;t<i.length;t++){const n=i[t];n.flags&A&&n.context===f&&(e.push(n),i.splice(t,1),t--)}I(e)}function nt(e){const t=[];for(let n=0;n<i.length;n++){const s=i[n];s.flags&V&&s.context===e&&(t.push(s),i.splice(n,1),n--)}I(t)}function Re(e){const t=z,n=i,s=C;try{const r=[],u=[];z=Xe,Y=0,i=r,C=u,I(n),I(s),(i.length>0||u.length>0)&&Re(),Z&&Ae()}finally{z=t,i=n,C=s}}async function Nt(){await Promise.resolve(),Re()}function Me(e,t){const n=Fe(e),s=O||l===null&&e.flags&se?m:h;x(e,s);const r=e.equals;r(n,e.value)||(e.value=n,me(e,m,t))}function Ct(e,t,n){let s=n[t];const r=s===void 0;r&&(s={store:null,last_value:null,value:Oe(P),unsubscribe:le},ft(s.value,()=>{s.last_value=s.value.value}),n[t]=s),(r||s.store!==e)&&(s.unsubscribe(),s.store=e??null,s.unsubscribe=st(e,s.value));const u=F(s.value);return u===P?s.last_value:u}function st(e,t){return e==null?(oe(t,void 0),le):Pe(e,s=>{ce=!0,oe(t,s),ce=!1})}function Ft(e){_t(()=>{let t;for(t in e){const n=e[t];n.unsubscribe(),ge(n.value)}})}function F(e){const t=e.flags;if(t&re)return P;if(J&&q.add(e),b!==null&&!(b.flags&W)&&!v){const n=(b.flags&se)!==0,s=b.dependencies;a===null&&s!==null&&s[d]===e&&!(n&&l!==null)?d++:a===null?a=[e]:e.read!==U&&a.push(e),n||(e.read=U)}return t&ae&&pe(e)&&Me(e,!1),e.value}function oe(e,t){return he(e,t),t}function rt(e){const t=M;M=null;try{const n=e();return M===null?n:M}finally{M=t}}function Dt(e){const t=J,n=q;J=!0,q=new Set;try{L(e)}finally{J=t;let r;for(r of q)n.add(r);q=n}let s;for(s of q)ut(s,null);return q}function ut(e,t){return he(e,L(()=>F(e))),t}function ct(e,t){const n=e.flags;(!(n&j)&&t||n&j&&!t)&&(e.flags^=j,!t&&n&de&&!(n&h)&&B(e,!1));const s=e.references;if(s!==null){let r;for(r=0;r<s.length;r++)ct(s[r],t)}}function me(e,t,n){const s=ee(e.context),r=e.consumers;if(r!==null){const u=r.length;let o;for(o=0;o<u;o++){const c=r[o],g=c.flags;g&m||!s&&c===l||!n&&c===l||(x(c,t),g&h&&(c.flags&de?B(c,!1):me(c,D,n)))}}}function he(e,t){if(!v&&!ce&&b!==null&&ee(e.context)&&b.flags&ae)throw new Error(`Unsafe mutations during Svelte's render or derived phase are not permitted in runes mode. This can lead to unexpected errors and possibly cause infinite loops.

If this mutation is not meant to be reactive do not use the "$state" rune for that declaration.`);if(e.flags&Se&&!e.equals(t,e.value)){const n=e.context;if(e.value=t,ee(n)&&l!==null&&l.consumers===null&&l.flags&h&&a!==null&&a.includes(e)&&(x(l,m),B(l,!1)),me(e,m,!0),l===null&&i.length===0){const s=n?.update_callbacks;if(s!=null){s.before.forEach(u=>u());const r=lt(()=>{ge(r),s.after.forEach(u=>u())})}}}}function ge(e){const t=e.value,n=e.destroy;if(De(e),te(e,0,!0),e.init=null,e.references=null,e.destroy=null,e.context=null,e.block=null,e.value=null,e.dependencies=null,e.consumers=null,x(e,re),n!==null)if(we(n)){let s;for(s=0;s<n.length;s++)n[s]()}else n();t!==null&&e.flags&de&&t()}function Oe(e,t){const n=Ce(Se|h,e,null);return n.context=f,n.equals=$e(t),n}function $e(e){if(e!==void 0)return e;const t=f;return t&&!t.immutable?at:Je}function L(e){const t=v;try{return v=!0,e()}finally{v=t}}function N(e,t,n,s,r){const u=Ce(e|m,null,s);return u.init=t,u.context=f,r&&B(u,n),l!==null&&!(e&W)&&Qe(l,u),u}function ot(e){if(l===null)throw new Error("The Svelte $effect rune can only be used during component initialisation.");const t=l.flags&A&&f!==null&&!f.mounted,n=N(H,e,!1,y,!t);if(t){let s=f.effects;s===null&&(s=f.effects=[]),s.push(n)}return n}function It(e){return N(H,e,!1,y,!0)}function lt(e){return N(H|W,e,!1,y,!0)}function At(e,t){return N(V|W,e,t,y,!0)}function Rt(e){const t=l!==null&&(l.flags&A)!==0;return N(V,()=>{const n=e();return tt(),n},t,y,!0)}function be(e){return N(_e,e,!0,y,!0)}function Mt(e,t=y,n=!1,s=!0){let r=A;return n&&(r|=W),N(r,e,s,t,!0)}function ft(e,t){let n=e.destroy;n===null?e.destroy=t:we(n)?n.push(t):e.destroy=[n,t]}function x(e,t){const n=e.flags;n&t||(n&D?e.flags^=D:n&h?e.flags^=h:n&m&&(e.flags^=m),e.flags^=t)}function $(e){return typeof e=="object"&&e!==null&&typeof e.flags=="number"}function Ot(e,t,n,s){const r=$(e)?F(e):e,u=rt(()=>r[t]),o=Object.getOwnPropertyDescriptor(r,t)?.set;let c=r[t];const g=c===void 0&&n!==void 0;if($(u)&&u.value===c&&o===void 0&&$e()===u.equals)return g&&oe(u,s?n():n),u;g&&(c=s?n():n);const E=Oe(c),K=f.immutable;let w=!1,_=!1,p=!0;if(be(()=>{const R=($(e)?F(e):e)[t];if(p){p=!1;return}if(w){w=!1;return}ve(K,R,E.value)&&(_=!0,L(()=>he(E,R)))}),$(u)&&o!==void 0){let T=!g;be(()=>{const R=F(E);if(T){T=!1;return}if(_){_=!1;return}ve(K,R,u.value)&&(w=!0,L(()=>o(R)))})}return E}function $t(e,t){return()=>($(e)?F(e):e)[t]}function ve(e,t,n){return e?it(t,n):Ue(t,n)}function it(e,t){return e!=e?t==t:e!==t}function Ue(e,t){return e!=e?t==t:e!==t||e!==null&&typeof e=="object"||typeof e=="function"}function at(e,t){return!Ue(e,t)}function _t(e){ot(()=>()=>L(e))}function Ut(e,t=!1,n=!1){const s=ze(e);s.runes=t,s.immutable=n,f=s}function Pt(e){const t=f;if(t!==null){const n=t.effects;if(n!==null){t.effects=null;for(let s=0;s<n.length;s++)B(n[s],!1)}f=t.parent,t.mounted=!0}}export{qt as $,S as A,xe as B,ye as C,yt as D,bt as E,pt as F,Ie as G,ft as H,ge as I,dt as J,Re as K,mt as L,vt as M,wt as N,he as O,St as P,ct as Q,At as R,at as S,lt as T,P as U,It as V,Ot as a,Rt as b,Pt as c,ht as d,$t as e,Oe as f,F as g,kt as h,Et as i,xt as j,Ft as k,Ct as l,ut as m,we as n,$ as o,Ut as p,L as q,Mt as r,oe as s,Nt as t,ot as u,f as v,Dt as w,y as x,gt as y,Tt as z};
