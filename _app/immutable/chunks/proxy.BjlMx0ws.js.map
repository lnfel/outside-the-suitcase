{"version":3,"file":"proxy.BjlMx0ws.js","sources":["../../../../../../node_modules/.pnpm/svelte@5.0.0-next.164/node_modules/svelte/src/internal/client/proxy.js"],"sourcesContent":["import { DEV } from 'esm-env';\nimport { get, current_component_context, untrack, current_effect } from './runtime.js';\nimport {\n\tarray_prototype,\n\tdefine_property,\n\tget_descriptor,\n\tget_descriptors,\n\tget_prototype_of,\n\tis_array,\n\tis_frozen,\n\tobject_prototype\n} from './utils.js';\nimport { check_ownership, widen_ownership } from './dev/ownership.js';\nimport { mutable_source, source, set } from './reactivity/sources.js';\nimport { STATE_FROZEN_SYMBOL, STATE_SYMBOL } from './constants.js';\nimport { UNINITIALIZED } from '../../constants.js';\nimport * as e from './errors.js';\n\n/**\n * @template T\n * @param {T} value\n * @param {boolean} [immutable]\n * @param {import('#client').ProxyMetadata | null} [parent]\n * @param {import('#client').Source<T>} [prev] dev mode only\n * @returns {import('#client').ProxyStateObject<T> | T}\n */\nexport function proxy(value, immutable = true, parent = null, prev) {\n\tif (\n\t\ttypeof value === 'object' &&\n\t\tvalue != null &&\n\t\t!is_frozen(value) &&\n\t\t!(STATE_FROZEN_SYMBOL in value)\n\t) {\n\t\t// If we have an existing proxy, return it...\n\t\tif (STATE_SYMBOL in value) {\n\t\t\tconst metadata = /** @type {import('#client').ProxyMetadata<T>} */ (value[STATE_SYMBOL]);\n\n\t\t\t// ...unless the proxy belonged to a different object, because\n\t\t\t// someone copied the state symbol using `Reflect.ownKeys(...)`\n\t\t\tif (metadata.t === value || metadata.p === value) {\n\t\t\t\tif (DEV) {\n\t\t\t\t\t// Since original parent relationship gets lost, we need to copy over ancestor owners\n\t\t\t\t\t// into current metadata. The object might still exist on both, so we need to widen it.\n\t\t\t\t\twiden_ownership(metadata, metadata);\n\t\t\t\t\tmetadata.parent = parent;\n\t\t\t\t}\n\n\t\t\t\treturn metadata.p;\n\t\t\t}\n\t\t}\n\n\t\tconst prototype = get_prototype_of(value);\n\n\t\tif (prototype === object_prototype || prototype === array_prototype) {\n\t\t\tconst proxy = new Proxy(value, state_proxy_handler);\n\n\t\t\tdefine_property(value, STATE_SYMBOL, {\n\t\t\t\tvalue: /** @type {import('#client').ProxyMetadata} */ ({\n\t\t\t\t\ts: new Map(),\n\t\t\t\t\tv: source(0),\n\t\t\t\t\ta: is_array(value),\n\t\t\t\t\ti: immutable,\n\t\t\t\t\tp: proxy,\n\t\t\t\t\tt: value\n\t\t\t\t}),\n\t\t\t\twritable: true,\n\t\t\t\tenumerable: false\n\t\t\t});\n\n\t\t\tif (DEV) {\n\t\t\t\t// @ts-expect-error\n\t\t\t\tvalue[STATE_SYMBOL].parent = parent;\n\n\t\t\t\tif (prev) {\n\t\t\t\t\t// Reuse owners from previous state; necessary because reassignment is not guaranteed to have correct component context.\n\t\t\t\t\t// If no previous proxy exists we play it safe and assume ownerless state\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tconst prev_owners = prev?.v?.[STATE_SYMBOL]?.owners;\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tvalue[STATE_SYMBOL].owners = prev_owners ? new Set(prev_owners) : null;\n\t\t\t\t} else {\n\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\tvalue[STATE_SYMBOL].owners =\n\t\t\t\t\t\tparent === null\n\t\t\t\t\t\t\t? current_component_context !== null\n\t\t\t\t\t\t\t\t? new Set([current_component_context.function])\n\t\t\t\t\t\t\t\t: null\n\t\t\t\t\t\t\t: new Set();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn proxy;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template {import('#client').ProxyStateObject} T\n * @param {T} value\n * @param {Map<T, Record<string | symbol, any>>} already_unwrapped\n * @returns {Record<string | symbol, any>}\n */\nfunction unwrap(value, already_unwrapped) {\n\tif (typeof value === 'object' && value != null && STATE_SYMBOL in value) {\n\t\tconst unwrapped = already_unwrapped.get(value);\n\t\tif (unwrapped !== undefined) {\n\t\t\treturn unwrapped;\n\t\t}\n\n\t\tif (is_array(value)) {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst array = [];\n\t\t\talready_unwrapped.set(value, array);\n\t\t\tfor (const element of value) {\n\t\t\t\tarray.push(unwrap(element, already_unwrapped));\n\t\t\t}\n\t\t\treturn array;\n\t\t} else {\n\t\t\t/** @type {Record<string | symbol, any>} */\n\t\t\tconst obj = {};\n\t\t\tconst keys = Reflect.ownKeys(value);\n\t\t\tconst descriptors = get_descriptors(value);\n\t\t\talready_unwrapped.set(value, obj);\n\n\t\t\tfor (const key of keys) {\n\t\t\t\tif (key === STATE_SYMBOL) continue;\n\t\t\t\tif (descriptors[key].get) {\n\t\t\t\t\tdefine_property(obj, key, descriptors[key]);\n\t\t\t\t} else {\n\t\t\t\t\t/** @type {T} */\n\t\t\t\t\tconst property = value[key];\n\t\t\t\t\tobj[key] = unwrap(property, already_unwrapped);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn obj;\n\t\t}\n\t}\n\n\treturn value;\n}\n\n/**\n * @template T\n * @param {T} value\n * @returns {T}\n */\nexport function snapshot(value) {\n\treturn /** @type {T} */ (\n\t\tunwrap(/** @type {import('#client').ProxyStateObject} */ (value), new Map())\n\t);\n}\n\n/**\n * @param {import('#client').Source<number>} signal\n * @param {1 | -1} [d]\n */\nfunction update_version(signal, d = 1) {\n\tset(signal, signal.v + d);\n}\n\n/** @type {ProxyHandler<import('#client').ProxyStateObject<any>>} */\nconst state_proxy_handler = {\n\tdefineProperty(target, prop, descriptor) {\n\t\tif (descriptor.value) {\n\t\t\t/** @type {import('#client').ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\t\tconst s = metadata.s.get(prop);\n\t\t\tif (s !== undefined) set(s, proxy(descriptor.value, metadata.i, metadata));\n\t\t}\n\n\t\treturn Reflect.defineProperty(target, prop, descriptor);\n\t},\n\n\tdeleteProperty(target, prop) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst s = metadata.s.get(prop);\n\t\tconst is_array = metadata.a;\n\t\tconst boolean = delete target[prop];\n\n\t\t// If we have mutated an array directly, and the deletion\n\t\t// was successful we will also need to update the length\n\t\t// before updating the field or the version. This is to\n\t\t// ensure any effects observing length can execute before\n\t\t// effects that listen to the fields â€“ otherwise they will\n\t\t// operate an an index that no longer exists.\n\t\tif (is_array && boolean) {\n\t\t\tconst ls = metadata.s.get('length');\n\t\t\tconst length = target.length - 1;\n\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\tset(ls, length);\n\t\t\t}\n\t\t}\n\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\n\t\tif (boolean) {\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn boolean;\n\t},\n\n\tget(target, prop, receiver) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn Reflect.get(target, STATE_SYMBOL);\n\t\t}\n\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\n\t\t// create a source, but only if it's an own property and not a prototype property\n\t\tif (s === undefined && (!(prop in target) || get_descriptor(target, prop)?.writable)) {\n\t\t\ts = (metadata.i ? source : mutable_source)(proxy(target[prop], metadata.i, metadata));\n\t\t\tmetadata.s.set(prop, s);\n\t\t}\n\n\t\tif (s !== undefined) {\n\t\t\tconst value = get(s);\n\t\t\treturn value === UNINITIALIZED ? undefined : value;\n\t\t}\n\n\t\treturn Reflect.get(target, prop, receiver);\n\t},\n\n\tgetOwnPropertyDescriptor(target, prop) {\n\t\tconst descriptor = Reflect.getOwnPropertyDescriptor(target, prop);\n\t\tif (descriptor && 'value' in descriptor) {\n\t\t\t/** @type {import('#client').ProxyMetadata} */\n\t\t\tconst metadata = target[STATE_SYMBOL];\n\t\t\tconst s = metadata.s.get(prop);\n\n\t\t\tif (s) {\n\t\t\t\tdescriptor.value = get(s);\n\t\t\t}\n\t\t}\n\n\t\treturn descriptor;\n\t},\n\n\thas(target, prop) {\n\t\tif (prop === STATE_SYMBOL) {\n\t\t\treturn true;\n\t\t}\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tconst has = Reflect.has(target, prop);\n\n\t\tlet s = metadata.s.get(prop);\n\t\tif (\n\t\t\ts !== undefined ||\n\t\t\t(current_effect !== null && (!has || get_descriptor(target, prop)?.writable))\n\t\t) {\n\t\t\tif (s === undefined) {\n\t\t\t\ts = (metadata.i ? source : mutable_source)(\n\t\t\t\t\thas ? proxy(target[prop], metadata.i, metadata) : UNINITIALIZED\n\t\t\t\t);\n\t\t\t\tmetadata.s.set(prop, s);\n\t\t\t}\n\t\t\tconst value = get(s);\n\t\t\tif (value === UNINITIALIZED) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn has;\n\t},\n\n\tset(target, prop, value, receiver) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\t\tlet s = metadata.s.get(prop);\n\t\t// If we haven't yet created a source for this property, we need to ensure\n\t\t// we do so otherwise if we read it later, then the write won't be tracked and\n\t\t// the heuristics of effects will be different vs if we had read the proxied\n\t\t// object property before writing to that property.\n\t\tif (s === undefined) {\n\t\t\t// the read creates a signal\n\t\t\tuntrack(() => receiver[prop]);\n\t\t\ts = metadata.s.get(prop);\n\t\t}\n\t\tif (s !== undefined) {\n\t\t\tset(s, proxy(value, metadata.i, metadata));\n\t\t}\n\t\tconst is_array = metadata.a;\n\t\tconst not_has = !(prop in target);\n\n\t\tif (DEV) {\n\t\t\t/** @type {import('#client').ProxyMetadata | undefined} */\n\t\t\tconst prop_metadata = value?.[STATE_SYMBOL];\n\t\t\tif (prop_metadata && prop_metadata?.parent !== metadata) {\n\t\t\t\twiden_ownership(metadata, prop_metadata);\n\t\t\t}\n\t\t\tcheck_ownership(metadata);\n\t\t}\n\n\t\t// variable.length = value -> clear all signals with index >= value\n\t\tif (is_array && prop === 'length') {\n\t\t\tfor (let i = value; i < target.length; i += 1) {\n\t\t\t\tconst s = metadata.s.get(i + '');\n\t\t\t\tif (s !== undefined) set(s, UNINITIALIZED);\n\t\t\t}\n\t\t}\n\n\t\t// Set the new value before updating any signals so that any listeners get the new value\n\t\t// @ts-ignore\n\t\ttarget[prop] = value;\n\n\t\tif (not_has) {\n\t\t\t// If we have mutated an array directly, we might need to\n\t\t\t// signal that length has also changed. Do it before updating metadata\n\t\t\t// to ensure that iterating over the array as a result of a metadata update\n\t\t\t// will not cause the length to be out of sync.\n\t\t\tif (is_array) {\n\t\t\t\tconst ls = metadata.s.get('length');\n\t\t\t\tconst length = target.length;\n\t\t\t\tif (ls !== undefined && ls.v !== length) {\n\t\t\t\t\tset(ls, length);\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdate_version(metadata.v);\n\t\t}\n\n\t\treturn true;\n\t},\n\n\townKeys(target) {\n\t\t/** @type {import('#client').ProxyMetadata} */\n\t\tconst metadata = target[STATE_SYMBOL];\n\n\t\tget(metadata.v);\n\t\treturn Reflect.ownKeys(target);\n\t}\n};\n\nif (DEV) {\n\tstate_proxy_handler.setPrototypeOf = () => {\n\t\te.state_prototype_fixed();\n\t};\n}\n\n/**\n * @param {any} value\n */\nexport function get_proxied_value(value) {\n\tif (value !== null && typeof value === 'object' && STATE_SYMBOL in value) {\n\t\tvar metadata = value[STATE_SYMBOL];\n\t\tif (metadata) {\n\t\t\treturn metadata.p;\n\t\t}\n\t}\n\treturn value;\n}\n\n/**\n * @param {any} a\n * @param {any} b\n */\nexport function is(a, b) {\n\treturn Object.is(get_proxied_value(a), get_proxied_value(b));\n}\n"],"names":["proxy","value","immutable","parent","prev","is_frozen","STATE_FROZEN_SYMBOL","STATE_SYMBOL","metadata","prototype","get_prototype_of","object_prototype","array_prototype","state_proxy_handler","define_property","source","is_array","update_version","signal","d","set","target","prop","descriptor","s","boolean","ls","length","UNINITIALIZED","receiver","_a","get_descriptor","mutable_source","get","has","current_effect","untrack","not_has","i","get_proxied_value","is","a","b"],"mappings":"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","x_google_ignoreList":[0]}