{"version":3,"file":"index-K4lY9HIg.js","sources":["../../../../src/lib/waveform-path/index.ts"],"sourcesContent":["/**\n * https://css-tricks.com/making-an-audio-waveform-visualizer-with-vanilla-javascript/\n * https://github.com/jerosoler/waveform-path\n */\n\ntype BaseOptions = {\n    channel?: number\n    samples?: number\n    top?: number\n    left?: number\n    type?: 'steps' | 'mirror' | 'bars'\n    paths?: any[]\n    animation?: boolean\n    animationframes?: number\n    normalize?: boolean\n}\n\ntype LinearPathOptions = BaseOptions & {\n    height?: number\n    width?: number\n}\n\ntype PolarPathOptions = BaseOptions & {\n    distance?: number\n    length?: number\n    startdeg?: number\n    enddeg?: number\n    invertdeg?: boolean\n    invertpath?: boolean\n}\n\nexport const getAudioData = async (url: string) => {\n    window.AudioContext = window.AudioContext || window.webkitAudioContext;\n    const audioContext = new AudioContext()\n    return fetch(url)\n    .then(response => response.arrayBuffer())\n    .then(arrayBuffer => audioContext.decodeAudioData(arrayBuffer))\n    .catch(error => {\n        console.error(error)\n    })\n}\n\nexport const linearPath = (audioBuffer: AudioBuffer, options: LinearPathOptions) => {\n    const { \n        channel = 0,\n        samples = audioBuffer.length,\n        height = 100,\n        width = 800,\n        top = 0,\n        left = 0,\n        type = 'steps',\n        paths = [{d:'Q', sx: 0, sy:0, x: 50, y: 100, ex:100, ey:0}],\n        animation = false,\n        animationframes = 10,\n        normalize = true,\n        } = options;\n\n    const framesData = getFramesData(audioBuffer, channel, animation, animationframes);\n    const filteredData = getFilterData(framesData, samples);\n    const normalizeData = (normalize ? getNormalizeData(filteredData) : filteredData);\n\n    let path = ``;\n    \n\n    const fixHeight = (type != 'bars' ?  (height+top*2) / 2 : height+top);\n    const fixWidth = width / samples;\n    const pathslength = paths.length;\n    const fixpathslength =  (type == 'mirror' ? pathslength*2 : pathslength);\n\n    const normalizeDataLength = normalizeData.length;\n\n    for(let f = 0; f < normalizeDataLength; f++) {\n        if(f>0) {\n            const pathlength = path.length;\n            const lastvalue = path.charAt(pathlength - 1);\n            if(lastvalue == \";\" || pathlength === 0) {\n                path+=' M 0 0 ;';\n            } else {\n                path += ';';\n            }\n        }\n        \n        let last_pos_x = -9999;\n        let last_pos_y = -9999;\n        \n        for (let i = 0; i < samples; i++) {\n\n            const positive =  (type != 'bars' ? (i % 2 ? 1: -1) : 1);\n            let mirror = 1;\n            for(let j = 0; j < fixpathslength; j++) {\n                let k = j;\n                if(j >= pathslength) {\n                    k = j - pathslength;\n                    mirror = -1;   \n                }\n                paths[k].minshow = paths[k].minshow ?? 0;\n                paths[k].maxshow = paths[k].maxshow ?? 1;\n                paths[k].normalize = paths[k].normalize ?? false;\n                const normalizeDataValue = (paths[k].normalize ? 1 : normalizeData[f][i]);\n                if(paths[k].minshow <= normalizeData[f][i] && paths[k].maxshow >= normalizeData[f][i]) {\n                    switch (paths[k].d) {\n                        // LineTo Commands\n                        case 'L': {\n                            const pos_x = (i * fixWidth)  + (fixWidth*paths[k].sx/100) + left;\n                            const pos_y = fixHeight + (normalizeDataValue * paths[k].sy / 100 * (type != 'bars' ? height/2 : height) * -positive*mirror);\n\n                            //const end_pos_x = ((i+1) * fixWidth) - (fixWidth*(1-(paths[k].ex/100))) + left;\n                            const end_pos_x = (i*fixWidth) + (fixWidth*paths[k].ex/100) + left;\n                            const end_pos_y = fixHeight + (normalizeDataValue * paths[k].ey / 100 * (type != 'bars' ? height/2 : height) * -positive*mirror);\n\n                            if(pos_x !== last_pos_x || pos_y !== last_pos_y) {   \n                                path += `M ${pos_x} ${pos_y} `;\n                            }\n\n                            path += `L ${end_pos_x} ${end_pos_y} `; \n                            \n                            last_pos_x = end_pos_x;\n                            last_pos_y = end_pos_y;                             \n                            break;\n                        }\n\n                        case 'H': {\n                            const pos_x = (i * fixWidth)  + (fixWidth*paths[k].sx/100) + left;\n                            const pos_y = fixHeight + (normalizeDataValue * paths[k].y / 100 * (type != 'bars' ? height/2 : height) * -positive*mirror);\n\n                            //const end_pos_x = ((i+1) * fixWidth) - (fixWidth*(1-(paths[k].ex/100))) + left;\n                            const end_pos_x = (i*fixWidth) + (fixWidth*paths[k].ex/100) + left;\n                            const end_pos_y = pos_y;\n\n                            if(pos_x !== last_pos_x || pos_y !== last_pos_y) {   \n                                path += `M ${pos_x} ${pos_y} `;\n                            }\n\n                            path += `H ${end_pos_x} `; \n                            \n                            last_pos_x = end_pos_x;\n                            last_pos_y = end_pos_y;                             \n                            break;\n                        }\n                        \n                        case 'V': {\n                            const pos_x = (i * fixWidth)  + (fixWidth*paths[k].x/100) + left;\n                            const pos_y = fixHeight + (normalizeDataValue * paths[k].sy / 100 * (type != 'bars' ? height/2 : height) * -positive*mirror);\n                            \n                            const end_pos_x = pos_x;\n                            const end_pos_y = fixHeight + (normalizeDataValue * paths[k].ey / 100 * (type != 'bars' ? height/2 : height) * -positive*mirror);\n                            \n                            if(pos_x !== last_pos_x || pos_y !== last_pos_y) {   \n                                path += `M ${pos_x} ${pos_y} `;\n                            }\n                            \n                            path += `V ${end_pos_y} `; \n\n                            last_pos_x = end_pos_x;\n                            last_pos_y = end_pos_y;\n                            break;\n                        }\n\n                        // Cubic Bézier Curve Commands\n                        case 'C': {\n                            const pos_x = (i * fixWidth)  + (fixWidth*paths[k].sx/100) + left;\n                            const pos_y = fixHeight  - (fixHeight*paths[k].sy/100)*positive;\n                            \n                            const center_pos_x = (i * fixWidth)  + (fixWidth*paths[k].x/100) + left;\n                            const center_pos_y = fixHeight + (normalizeDataValue * paths[k].y / 100 * (type != 'bars' ? height : height*2) * -positive*mirror);\n\n                            //const end_pos_x = ((i+1) * fixWidth) - (fixWidth*(1-(paths[k].ex/100))) + left;\n                            const end_pos_x = (i*fixWidth) + (fixWidth*paths[k].ex/100) + left;\n                            const end_pos_y = fixHeight - (fixHeight*paths[k].ey/100)*positive;\n\n                            if(pos_x !== last_pos_x || pos_y !== last_pos_y) {   \n                                path += `M ${pos_x} ${pos_y} `;\n                            }\n\n                            path += `C ${pos_x} ${pos_y} ${center_pos_x} ${center_pos_y} ${end_pos_x} ${end_pos_y} `; \n\n                            last_pos_x = end_pos_x;\n                            last_pos_y = end_pos_y;\n                            break;\n                        }\n\n                        // Quadratic Bézier Curve Commands\n                        case 'Q': {\n                            const pos_x = (i * fixWidth)  + (fixWidth*paths[k].sx/100) + left;\n                            const pos_y = fixHeight + (normalizeDataValue * paths[k].sy / 100 * (type != 'bars' ? height/2 : height) * -positive*mirror);\n\n                            const center_pos_x = (i * fixWidth)  + (fixWidth*paths[k].x/100) + left;\n                            const center_pos_y = fixHeight + (normalizeDataValue * paths[k].y / 100 * (type != 'bars' ? height : height*2) * -positive*mirror);\n\n                            //const end_pos_x = ((i+1) * fixWidth) - (fixWidth*(1-(paths[k].ex/100))) + left;\n                            const end_pos_x = (i*fixWidth) + (fixWidth*paths[k].ex/100) + left;\n                            const end_pos_y = fixHeight + (normalizeDataValue * paths[k].ey / 100 * (type != 'bars' ? height/2 : height) * -positive*mirror);\n\n                            if(pos_x !== last_pos_x || pos_y !== last_pos_y) {   \n                                path += `M ${pos_x} ${pos_y} `;\n                            }\n\n                            path += `Q ${center_pos_x} ${center_pos_y} ${end_pos_x} ${end_pos_y} `; \n                            \n                            last_pos_x = end_pos_x;\n                            last_pos_y = end_pos_y;                             \n                            break;\n                        }\n\n                        // Elliptical Arc Curve Commands\n                        case 'A': {\n                            const pos_x = (i * fixWidth)  + (fixWidth*paths[k].sx/100) + left;\n                            const pos_y = fixHeight + (normalizeDataValue * paths[k].sy / 100 * (type != 'bars' ? height/2 : height) * -positive*mirror);\n\n                            //const end_pos_x = ((i+1) * fixWidth) - (fixWidth*(1-(paths[k].ex/100))) + left;\n                            const end_pos_x = (i*fixWidth) + (fixWidth*paths[k].ex/100) + left;\n                            const end_pos_y = fixHeight + (normalizeDataValue * paths[k].ey / 100 * (type != 'bars' ? height/2 : height) * -positive*mirror);\n\n                            if(pos_x !== last_pos_x || pos_y !== last_pos_y) {   \n                                path += `M ${pos_x} ${pos_y} `;\n                            }\n                            const rx = paths[k].rx * fixWidth/100;\n                            const ry = paths[k].ry * fixWidth/100;\n                            let sweep = paths[k].sweep;\n                            if(positive == -1) {\n                                if(sweep == 1) {\n                                    sweep = 0;\n                                } else {\n                                    sweep = 1;\n                                }\n                            }\n                            if(mirror == -1) {\n                                if(sweep == 1) {\n                                    sweep = 0;\n                                } else {\n                                    sweep = 1;\n                                }\n                            }\n                            path += `A ${rx} ${ry} ${paths[k].angle} ${paths[k].arc} ${sweep} ${end_pos_x} ${end_pos_y} `; \n                            \n                            last_pos_x = end_pos_x;\n                            last_pos_y = end_pos_y;                             \n                            break;\n                        }\n\n                        // ClosePath Commands\n                        case 'Z': \n                            path += 'Z ';    \n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n            }       \n        }\n    }\n    return path;\n}\n\nexport const polarPath = (audioBuffer: AudioBuffer, options: PolarPathOptions) => {\n    const { \n        channel = 0,\n        samples = audioBuffer.length,\n        distance = 50,\n        length = 100,\n        top = 0,\n        left = 0,\n        type = 'steps',\n        startdeg = 0,\n        enddeg = 360,\n        invertdeg = false,\n        invertpath = false,\n        paths = [{d:'Q', sdeg: 0, sr:0, deg: 50, r: 100, edeg:100, er:0}],\n        animation = false,\n        animationframes = 10,\n        normalize = true,\n        } = options;\n    \n    const framesData = getFramesData(audioBuffer, channel, animation, animationframes);\n    const filteredData = getFilterData(framesData, samples);\n    const normalizeData = (normalize ? getNormalizeData(filteredData) : filteredData);\n\n    let path = ``;\n    const fixenddeg = (enddeg < startdeg ? enddeg+360 : enddeg);\n    const deg = (!invertdeg ? (fixenddeg-startdeg) / samples : (startdeg-fixenddeg) / samples );\n    const fixOrientation = (!invertdeg ? 90+startdeg : 90+startdeg+180 );\n    const invert = (!invertpath ? 1 : -1);\n    const pathslength = paths.length;\n    const fixpathslength =  (type == 'mirror' ? pathslength*2 : pathslength);\n    const pi180 = Math.PI / 180;\n\n    const normalizeDataLength = normalizeData.length;\n\n    for(let f = 0; f < normalizeDataLength; f++) {\n        if(f>0) {\n            const pathlength = path.length;\n            const lastvalue = path.charAt(pathlength - 1);\n            if(lastvalue == \";\" || pathlength === 0) {\n                path+=' M 0 0 ;';\n            } else {\n                path += ';';\n            }\n        }       \n\n        let last_pos_x = -9999;\n        let last_pos_y = -9999;\n        \n        for (let i = 0; i < samples; i++) {\n            const positive =  (type != 'bars' ? (i % 2 ? 1: -1) : 1);\n            let mirror = 1;\n            for(let j = 0; j < fixpathslength; j++) {\n                let k = j;\n                if(j >= pathslength) {\n                    k = j - pathslength;\n                    mirror = -1;   \n                }\n                paths[k].minshow = paths[k].minshow ?? 0;\n                paths[k].maxshow = paths[k].maxshow ?? 1;\n                paths[k].normalize = paths[k].normalize ?? false;\n                const normalizeDataValue = (paths[k].normalize ? 1 : normalizeData[f][i]);\n                if(paths[k].minshow <= normalizeData[f][i] && paths[k].maxshow >= normalizeData[f][i]) {\n                    switch (paths[k].d) {\n                        // LineTo Commands\n                        case 'L': {\n                            const angleStart =  ((deg*(i+paths[k].sdeg/100)) - fixOrientation) * pi180;\n                            const angleEnd =  ((deg*(i+paths[k].edeg/100)) - fixOrientation) * pi180;\n\n                            const pos_x = left + ((length*(paths[k].sr/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.cos(angleStart);\n                            const pos_y = top + ((length*(paths[k].sr/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.sin(angleStart);\n\n                            const end_pos_x = left + ((length*(paths[k].er/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.cos(angleEnd);\n                            const end_pos_y = top + ((length*(paths[k].er/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.sin(angleEnd);\n\n                            if(pos_x !== last_pos_x || pos_y !== last_pos_y) {   \n                                path += `M ${pos_x} ${pos_y} `;\n                            }\n\n                            path += `L ${end_pos_x} ${end_pos_y} `; \n                            \n                            last_pos_x = end_pos_x;\n                            last_pos_y = end_pos_y;                             \n                            break;\n                        }\n\n\n                        // Cubic Bézier Curve Commands\n                        case 'C': {\n                            const angleStart =  ((deg*(i+paths[k].sdeg/100)) - fixOrientation) * pi180;\n                            const angle =  ((deg*(i+paths[k].deg/100)) - fixOrientation) * pi180;\n                            const angleEnd =  ((deg*(i+paths[k].edeg/100)) - fixOrientation) * pi180;\n\n                            const pos_x = left + ((length*(paths[k].sr/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.cos(angleStart);\n                            const pos_y = top + ((length*(paths[k].sr/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.sin(angleStart);\n                            \n                            const center_pos_x = left + ((length*(paths[k].r/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.cos(angle);\n                            const center_pos_y = top + ((length*(paths[k].r/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.sin(angle);\n\n                            const end_pos_x = left + ((length*(paths[k].er/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.cos(angleEnd);\n                            const end_pos_y = top + ((length*(paths[k].er/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.sin(angleEnd);\n\n                            if(pos_x !== last_pos_x || pos_y !== last_pos_y) {   \n                                path += `M ${pos_x} ${pos_y} `;\n                            }\n\n                            path += `C ${pos_x} ${pos_y} ${center_pos_x} ${center_pos_y} ${end_pos_x} ${end_pos_y} `; \n\n                            last_pos_x = end_pos_x;\n                            last_pos_y = end_pos_y;\n                            break;\n                        }\n\n                        // Quadratic Bézier Curve Commands\n                        case 'Q': {\n                            const angleStart =  ((deg*(i+paths[k].sdeg/100)) - fixOrientation) * pi180;\n                            const angle =  ((deg*(i+paths[k].deg/100)) - fixOrientation) * pi180;\n                            const angleEnd =  ((deg*(i+paths[k].edeg/100)) - fixOrientation) * pi180;\n\n                            const pos_x = left + ((length*(paths[k].sr/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.cos(angleStart);\n                            const pos_y = top + ((length*(paths[k].sr/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.sin(angleStart);\n                            \n                            const center_pos_x = left + ((length*(paths[k].r/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.cos(angle);\n                            const center_pos_y = top + ((length*(paths[k].r/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.sin(angle);\n\n                            const end_pos_x = left + ((length*(paths[k].er/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.cos(angleEnd);\n                            const end_pos_y = top + ((length*(paths[k].er/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.sin(angleEnd);\n\n\n                            if(pos_x !== last_pos_x || pos_y !== last_pos_y) {   \n                                path += `M ${pos_x} ${pos_y} `;\n                            }\n\n                            path += `Q ${center_pos_x} ${center_pos_y} ${end_pos_x} ${end_pos_y} `; \n                            \n                            last_pos_x = end_pos_x;\n                            last_pos_y = end_pos_y;                             \n                            break;\n                        }\n\n                        // Elliptical Arc Curve Commands\n                        case 'A': {\n                            const angleStart =  ((deg*(i+paths[k].sdeg/100)) - fixOrientation) * pi180;\n                            const angleEnd =  ((deg*(i+paths[k].edeg/100)) - fixOrientation) * pi180;\n\n                            const pos_x = left + ((length*(paths[k].sr/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.cos(angleStart);\n                            const pos_y = top + ((length*(paths[k].sr/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.sin(angleStart);\n\n                            const end_pos_x = left + ((length*(paths[k].er/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.cos(angleEnd);\n                            const end_pos_y = top + ((length*(paths[k].er/100)*normalizeDataValue)* positive*mirror*invert + distance) * Math.sin(angleEnd);\n\n                            if(pos_x !== last_pos_x || pos_y !== last_pos_y) {   \n                                path += `M ${pos_x} ${pos_y} `;\n                            }\n\n                            const angle = deg * i * paths[k].angle / 100;\n                            const rx = paths[k].rx * deg/100;\n                            const ry = paths[k].ry * deg/100;\n\n                            let sweep = paths[k].sweep;\n                            if(positive == -1) {\n                                if(sweep == 1) {\n                                    sweep = 0;\n                                } else {\n                                    sweep = 1;\n                                }\n                            }\n                            if(mirror == -1) {\n                                if(sweep == 1) {\n                                    sweep = 0;\n                                } else {\n                                    sweep = 1;\n                                }\n                            }\n                            path += `A ${rx} ${ry} ${angle} ${paths[k].arc} ${sweep} ${end_pos_x} ${end_pos_y} `; \n                            \n                            last_pos_x = end_pos_x;\n                            last_pos_y = end_pos_y;                             \n                            break;\n                        }\n\n                        // ClosePath Commands\n                        case 'Z': \n                            path += 'Z ';    \n                            break;\n\n                        default:\n                            break;\n                    }\n                }\n            }       \n        }\n    }\n    return path;\n}\n\nconst getFramesData = (audioBuffer: AudioBuffer, channel: number, animation: boolean, animationframes: number) => {\n    const rawData = audioBuffer.getChannelData(channel);\n    \n    const framesData = [];\n    if(animation) {\n        const frames = audioBuffer.sampleRate / animationframes;\n        for (let index = 0; index < rawData.length; index += frames) {\n            const partraw = rawData.slice(index, index+frames);\n            framesData.push(partraw);\n        }\n    } else {\n        framesData.push(rawData);\n    }\n\n    return framesData;\n}\n\nconst getFilterData = (framesData: Float32Array[], samples: number) => {\n    const filteredData = [];\n    const framesDataLength = framesData.length;\n    for(let f = 0; f < framesDataLength; f++) {\n        const blockSize = Math.floor(framesData[f].length / samples); // the number of samples in each subdivision\n        const filteredDataBlock = [];\n        for (let i = 0; i < samples; i++) {\n            let blockStart = blockSize * i; // the location of the first sample in the block\n            let sum = 0;\n            for (let j = 0; j < blockSize; j++) {\n                sum = sum + Math.abs(framesData[f][blockStart + j]); // find the sum of all the samples in the block\n            }\n            filteredDataBlock.push(sum / blockSize); // divide the sum by the block size to get the average\n        }\n        filteredData.push(filteredDataBlock);\n    }\n    return filteredData;   \n}\n\nconst getNormalizeData = (filteredData: number[][]) => {\n    const multipliers = [];\n    const filteredDataLength = filteredData.length\n    for(let i = 0; i < filteredDataLength; i++) {\n        const multiplier = Math.max(...filteredData[i]);\n        multipliers.push(multiplier);\n    }\n    const maxMultiplier = Math.pow(Math.max(...multipliers), -1);\n\n    const normalizeData = [];\n    for(let i = 0; i < filteredDataLength; i++) {\n        const normalizeDataBlock = filteredData[i].map(n => n * maxMultiplier);\n        normalizeData.push(normalizeDataBlock);\n    }\n    return normalizeData;\n}\n"],"names":["polarPath","audioBuffer","options","channel","samples","distance","length","top","left","type","startdeg","enddeg","invertdeg","invertpath","paths","animation","animationframes","normalize","framesData","getFramesData","filteredData","getFilterData","normalizeData","getNormalizeData","path","fixenddeg","deg","fixOrientation","invert","pathslength","fixpathslength","pi180","normalizeDataLength","f","pathlength","last_pos_x","last_pos_y","positive","mirror","k","normalizeDataValue","angleStart","angleEnd","pos_x","pos_y","end_pos_x","end_pos_y","angle","center_pos_x","center_pos_y","rx","ry","sweep","rawData","frames","index","partraw","framesDataLength","blockSize","filteredDataBlock","i","blockStart","sum","j","multipliers","filteredDataLength","multiplier","maxMultiplier","normalizeDataBlock","n"],"mappings":"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"}